// IFC SDK : IFC2X3 C++ Early Classes
// Copyright (C) 2009-2018 CSTB   
//   
// For further information please contact
//                                       
//         eveBIM-support@cstb.fr        
//   or                                  
//         CSTB DTI/MIC                  
//         290, route des Lucioles       
//         BP 209                        
//         06904 Sophia Antipolis, France
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
// The full license is in Licence.txt file included with this
// distribution or is available at :
//     http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.


#include <ifc2x3/ExpressDataSet.h>

#include <ifc2x3/CopyOp.h>

using namespace ifc2x3;

ExpressDataSet::ExpressDataSet() : Step::BaseExpressDataSet() 
{
    m_refIfc2DCompositeCurveList.push_back(&m_Ifc2DCompositeCurve_Map);
    m_refIfcActionRequestList.push_back(&m_IfcActionRequest_Map);
    m_refIfcActorList.push_back(&m_IfcActor_Map);
    m_refIfcActorRoleList.push_back(&m_IfcActorRole_Map);
    m_refIfcActuatorTypeList.push_back(&m_IfcActuatorType_Map);
    m_refIfcAddressList.push_back(&m_IfcAddress_Map);
    m_refIfcAirTerminalBoxTypeList.push_back(&m_IfcAirTerminalBoxType_Map);
    m_refIfcAirTerminalTypeList.push_back(&m_IfcAirTerminalType_Map);
    m_refIfcAirToAirHeatRecoveryTypeList.push_back(&m_IfcAirToAirHeatRecoveryType_Map);
    m_refIfcAlarmTypeList.push_back(&m_IfcAlarmType_Map);
    m_refIfcAngularDimensionList.push_back(&m_IfcAngularDimension_Map);
    m_refIfcAnnotationList.push_back(&m_IfcAnnotation_Map);
    m_refIfcAnnotationCurveOccurrenceList.push_back(&m_IfcAnnotationCurveOccurrence_Map);
    m_refIfcAnnotationFillAreaList.push_back(&m_IfcAnnotationFillArea_Map);
    m_refIfcAnnotationFillAreaOccurrenceList.push_back(&m_IfcAnnotationFillAreaOccurrence_Map);
    m_refIfcAnnotationOccurrenceList.push_back(&m_IfcAnnotationOccurrence_Map);
    m_refIfcAnnotationSurfaceList.push_back(&m_IfcAnnotationSurface_Map);
    m_refIfcAnnotationSurfaceOccurrenceList.push_back(&m_IfcAnnotationSurfaceOccurrence_Map);
    m_refIfcAnnotationSymbolOccurrenceList.push_back(&m_IfcAnnotationSymbolOccurrence_Map);
    m_refIfcAnnotationTextOccurrenceList.push_back(&m_IfcAnnotationTextOccurrence_Map);
    m_refIfcApplicationList.push_back(&m_IfcApplication_Map);
    m_refIfcAppliedValueList.push_back(&m_IfcAppliedValue_Map);
    m_refIfcAppliedValueRelationshipList.push_back(&m_IfcAppliedValueRelationship_Map);
    m_refIfcApprovalList.push_back(&m_IfcApproval_Map);
    m_refIfcApprovalActorRelationshipList.push_back(&m_IfcApprovalActorRelationship_Map);
    m_refIfcApprovalPropertyRelationshipList.push_back(&m_IfcApprovalPropertyRelationship_Map);
    m_refIfcApprovalRelationshipList.push_back(&m_IfcApprovalRelationship_Map);
    m_refIfcArbitraryClosedProfileDefList.push_back(&m_IfcArbitraryClosedProfileDef_Map);
    m_refIfcArbitraryOpenProfileDefList.push_back(&m_IfcArbitraryOpenProfileDef_Map);
    m_refIfcArbitraryProfileDefWithVoidsList.push_back(&m_IfcArbitraryProfileDefWithVoids_Map);
    m_refIfcAssetList.push_back(&m_IfcAsset_Map);
    m_refIfcAsymmetricIShapeProfileDefList.push_back(&m_IfcAsymmetricIShapeProfileDef_Map);
    m_refIfcAxis1PlacementList.push_back(&m_IfcAxis1Placement_Map);
    m_refIfcAxis2Placement2DList.push_back(&m_IfcAxis2Placement2D_Map);
    m_refIfcAxis2Placement3DList.push_back(&m_IfcAxis2Placement3D_Map);
    m_refIfcBeamList.push_back(&m_IfcBeam_Map);
    m_refIfcBeamTypeList.push_back(&m_IfcBeamType_Map);
    m_refIfcBezierCurveList.push_back(&m_IfcBezierCurve_Map);
    m_refIfcBlobTextureList.push_back(&m_IfcBlobTexture_Map);
    m_refIfcBlockList.push_back(&m_IfcBlock_Map);
    m_refIfcBoilerTypeList.push_back(&m_IfcBoilerType_Map);
    m_refIfcBooleanClippingResultList.push_back(&m_IfcBooleanClippingResult_Map);
    m_refIfcBooleanResultList.push_back(&m_IfcBooleanResult_Map);
    m_refIfcBoundaryConditionList.push_back(&m_IfcBoundaryCondition_Map);
    m_refIfcBoundaryEdgeConditionList.push_back(&m_IfcBoundaryEdgeCondition_Map);
    m_refIfcBoundaryFaceConditionList.push_back(&m_IfcBoundaryFaceCondition_Map);
    m_refIfcBoundaryNodeConditionList.push_back(&m_IfcBoundaryNodeCondition_Map);
    m_refIfcBoundaryNodeConditionWarpingList.push_back(&m_IfcBoundaryNodeConditionWarping_Map);
    m_refIfcBoundedCurveList.push_back(&m_IfcBoundedCurve_Map);
    m_refIfcBoundedSurfaceList.push_back(&m_IfcBoundedSurface_Map);
    m_refIfcBoundingBoxList.push_back(&m_IfcBoundingBox_Map);
    m_refIfcBoxedHalfSpaceList.push_back(&m_IfcBoxedHalfSpace_Map);
    m_refIfcBSplineCurveList.push_back(&m_IfcBSplineCurve_Map);
    m_refIfcBuildingList.push_back(&m_IfcBuilding_Map);
    m_refIfcBuildingElementList.push_back(&m_IfcBuildingElement_Map);
    m_refIfcBuildingElementComponentList.push_back(&m_IfcBuildingElementComponent_Map);
    m_refIfcBuildingElementPartList.push_back(&m_IfcBuildingElementPart_Map);
    m_refIfcBuildingElementProxyList.push_back(&m_IfcBuildingElementProxy_Map);
    m_refIfcBuildingElementProxyTypeList.push_back(&m_IfcBuildingElementProxyType_Map);
    m_refIfcBuildingElementTypeList.push_back(&m_IfcBuildingElementType_Map);
    m_refIfcBuildingStoreyList.push_back(&m_IfcBuildingStorey_Map);
    m_refIfcCableCarrierFittingTypeList.push_back(&m_IfcCableCarrierFittingType_Map);
    m_refIfcCableCarrierSegmentTypeList.push_back(&m_IfcCableCarrierSegmentType_Map);
    m_refIfcCableSegmentTypeList.push_back(&m_IfcCableSegmentType_Map);
    m_refIfcCalendarDateList.push_back(&m_IfcCalendarDate_Map);
    m_refIfcCartesianPointList.push_back(&m_IfcCartesianPoint_Map);
    m_refIfcCartesianTransformationOperatorList.push_back(&m_IfcCartesianTransformationOperator_Map);
    m_refIfcCartesianTransformationOperator2DList.push_back(&m_IfcCartesianTransformationOperator2D_Map);
    m_refIfcCartesianTransformationOperator2DnonUniformList.push_back(&m_IfcCartesianTransformationOperator2DnonUniform_Map);
    m_refIfcCartesianTransformationOperator3DList.push_back(&m_IfcCartesianTransformationOperator3D_Map);
    m_refIfcCartesianTransformationOperator3DnonUniformList.push_back(&m_IfcCartesianTransformationOperator3DnonUniform_Map);
    m_refIfcCenterLineProfileDefList.push_back(&m_IfcCenterLineProfileDef_Map);
    m_refIfcChamferEdgeFeatureList.push_back(&m_IfcChamferEdgeFeature_Map);
    m_refIfcChillerTypeList.push_back(&m_IfcChillerType_Map);
    m_refIfcCircleList.push_back(&m_IfcCircle_Map);
    m_refIfcCircleHollowProfileDefList.push_back(&m_IfcCircleHollowProfileDef_Map);
    m_refIfcCircleProfileDefList.push_back(&m_IfcCircleProfileDef_Map);
    m_refIfcClassificationList.push_back(&m_IfcClassification_Map);
    m_refIfcClassificationItemList.push_back(&m_IfcClassificationItem_Map);
    m_refIfcClassificationItemRelationshipList.push_back(&m_IfcClassificationItemRelationship_Map);
    m_refIfcClassificationNotationList.push_back(&m_IfcClassificationNotation_Map);
    m_refIfcClassificationNotationFacetList.push_back(&m_IfcClassificationNotationFacet_Map);
    m_refIfcClassificationReferenceList.push_back(&m_IfcClassificationReference_Map);
    m_refIfcClosedShellList.push_back(&m_IfcClosedShell_Map);
    m_refIfcCoilTypeList.push_back(&m_IfcCoilType_Map);
    m_refIfcColourRgbList.push_back(&m_IfcColourRgb_Map);
    m_refIfcColourSpecificationList.push_back(&m_IfcColourSpecification_Map);
    m_refIfcColumnList.push_back(&m_IfcColumn_Map);
    m_refIfcColumnTypeList.push_back(&m_IfcColumnType_Map);
    m_refIfcComplexPropertyList.push_back(&m_IfcComplexProperty_Map);
    m_refIfcCompositeCurveList.push_back(&m_IfcCompositeCurve_Map);
    m_refIfcCompositeCurveSegmentList.push_back(&m_IfcCompositeCurveSegment_Map);
    m_refIfcCompositeProfileDefList.push_back(&m_IfcCompositeProfileDef_Map);
    m_refIfcCompressorTypeList.push_back(&m_IfcCompressorType_Map);
    m_refIfcCondenserTypeList.push_back(&m_IfcCondenserType_Map);
    m_refIfcConditionList.push_back(&m_IfcCondition_Map);
    m_refIfcConditionCriterionList.push_back(&m_IfcConditionCriterion_Map);
    m_refIfcConicList.push_back(&m_IfcConic_Map);
    m_refIfcConnectedFaceSetList.push_back(&m_IfcConnectedFaceSet_Map);
    m_refIfcConnectionCurveGeometryList.push_back(&m_IfcConnectionCurveGeometry_Map);
    m_refIfcConnectionGeometryList.push_back(&m_IfcConnectionGeometry_Map);
    m_refIfcConnectionPointEccentricityList.push_back(&m_IfcConnectionPointEccentricity_Map);
    m_refIfcConnectionPointGeometryList.push_back(&m_IfcConnectionPointGeometry_Map);
    m_refIfcConnectionPortGeometryList.push_back(&m_IfcConnectionPortGeometry_Map);
    m_refIfcConnectionSurfaceGeometryList.push_back(&m_IfcConnectionSurfaceGeometry_Map);
    m_refIfcConstraintList.push_back(&m_IfcConstraint_Map);
    m_refIfcConstraintAggregationRelationshipList.push_back(&m_IfcConstraintAggregationRelationship_Map);
    m_refIfcConstraintClassificationRelationshipList.push_back(&m_IfcConstraintClassificationRelationship_Map);
    m_refIfcConstraintRelationshipList.push_back(&m_IfcConstraintRelationship_Map);
    m_refIfcConstructionEquipmentResourceList.push_back(&m_IfcConstructionEquipmentResource_Map);
    m_refIfcConstructionMaterialResourceList.push_back(&m_IfcConstructionMaterialResource_Map);
    m_refIfcConstructionProductResourceList.push_back(&m_IfcConstructionProductResource_Map);
    m_refIfcConstructionResourceList.push_back(&m_IfcConstructionResource_Map);
    m_refIfcContextDependentUnitList.push_back(&m_IfcContextDependentUnit_Map);
    m_refIfcControlList.push_back(&m_IfcControl_Map);
    m_refIfcControllerTypeList.push_back(&m_IfcControllerType_Map);
    m_refIfcConversionBasedUnitList.push_back(&m_IfcConversionBasedUnit_Map);
    m_refIfcCooledBeamTypeList.push_back(&m_IfcCooledBeamType_Map);
    m_refIfcCoolingTowerTypeList.push_back(&m_IfcCoolingTowerType_Map);
    m_refIfcCoordinatedUniversalTimeOffsetList.push_back(&m_IfcCoordinatedUniversalTimeOffset_Map);
    m_refIfcCostItemList.push_back(&m_IfcCostItem_Map);
    m_refIfcCostScheduleList.push_back(&m_IfcCostSchedule_Map);
    m_refIfcCostValueList.push_back(&m_IfcCostValue_Map);
    m_refIfcCoveringList.push_back(&m_IfcCovering_Map);
    m_refIfcCoveringTypeList.push_back(&m_IfcCoveringType_Map);
    m_refIfcCraneRailAShapeProfileDefList.push_back(&m_IfcCraneRailAShapeProfileDef_Map);
    m_refIfcCraneRailFShapeProfileDefList.push_back(&m_IfcCraneRailFShapeProfileDef_Map);
    m_refIfcCrewResourceList.push_back(&m_IfcCrewResource_Map);
    m_refIfcCsgPrimitive3DList.push_back(&m_IfcCsgPrimitive3D_Map);
    m_refIfcCsgSolidList.push_back(&m_IfcCsgSolid_Map);
    m_refIfcCShapeProfileDefList.push_back(&m_IfcCShapeProfileDef_Map);
    m_refIfcCurrencyRelationshipList.push_back(&m_IfcCurrencyRelationship_Map);
    m_refIfcCurtainWallList.push_back(&m_IfcCurtainWall_Map);
    m_refIfcCurtainWallTypeList.push_back(&m_IfcCurtainWallType_Map);
    m_refIfcCurveList.push_back(&m_IfcCurve_Map);
    m_refIfcCurveBoundedPlaneList.push_back(&m_IfcCurveBoundedPlane_Map);
    m_refIfcCurveStyleList.push_back(&m_IfcCurveStyle_Map);
    m_refIfcCurveStyleFontList.push_back(&m_IfcCurveStyleFont_Map);
    m_refIfcCurveStyleFontAndScalingList.push_back(&m_IfcCurveStyleFontAndScaling_Map);
    m_refIfcCurveStyleFontPatternList.push_back(&m_IfcCurveStyleFontPattern_Map);
    m_refIfcDamperTypeList.push_back(&m_IfcDamperType_Map);
    m_refIfcDateAndTimeList.push_back(&m_IfcDateAndTime_Map);
    m_refIfcDefinedSymbolList.push_back(&m_IfcDefinedSymbol_Map);
    m_refIfcDerivedProfileDefList.push_back(&m_IfcDerivedProfileDef_Map);
    m_refIfcDerivedUnitList.push_back(&m_IfcDerivedUnit_Map);
    m_refIfcDerivedUnitElementList.push_back(&m_IfcDerivedUnitElement_Map);
    m_refIfcDiameterDimensionList.push_back(&m_IfcDiameterDimension_Map);
    m_refIfcDimensionalExponentsList.push_back(&m_IfcDimensionalExponents_Map);
    m_refIfcDimensionCalloutRelationshipList.push_back(&m_IfcDimensionCalloutRelationship_Map);
    m_refIfcDimensionCurveList.push_back(&m_IfcDimensionCurve_Map);
    m_refIfcDimensionCurveDirectedCalloutList.push_back(&m_IfcDimensionCurveDirectedCallout_Map);
    m_refIfcDimensionCurveTerminatorList.push_back(&m_IfcDimensionCurveTerminator_Map);
    m_refIfcDimensionPairList.push_back(&m_IfcDimensionPair_Map);
    m_refIfcDirectionList.push_back(&m_IfcDirection_Map);
    m_refIfcDiscreteAccessoryList.push_back(&m_IfcDiscreteAccessory_Map);
    m_refIfcDiscreteAccessoryTypeList.push_back(&m_IfcDiscreteAccessoryType_Map);
    m_refIfcDistributionChamberElementList.push_back(&m_IfcDistributionChamberElement_Map);
    m_refIfcDistributionChamberElementTypeList.push_back(&m_IfcDistributionChamberElementType_Map);
    m_refIfcDistributionControlElementList.push_back(&m_IfcDistributionControlElement_Map);
    m_refIfcDistributionControlElementTypeList.push_back(&m_IfcDistributionControlElementType_Map);
    m_refIfcDistributionElementList.push_back(&m_IfcDistributionElement_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcDistributionElementType_Map);
    m_refIfcDistributionFlowElementList.push_back(&m_IfcDistributionFlowElement_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcDistributionFlowElementType_Map);
    m_refIfcDistributionPortList.push_back(&m_IfcDistributionPort_Map);
    m_refIfcDocumentElectronicFormatList.push_back(&m_IfcDocumentElectronicFormat_Map);
    m_refIfcDocumentInformationList.push_back(&m_IfcDocumentInformation_Map);
    m_refIfcDocumentInformationRelationshipList.push_back(&m_IfcDocumentInformationRelationship_Map);
    m_refIfcDocumentReferenceList.push_back(&m_IfcDocumentReference_Map);
    m_refIfcDoorList.push_back(&m_IfcDoor_Map);
    m_refIfcDoorLiningPropertiesList.push_back(&m_IfcDoorLiningProperties_Map);
    m_refIfcDoorPanelPropertiesList.push_back(&m_IfcDoorPanelProperties_Map);
    m_refIfcDoorStyleList.push_back(&m_IfcDoorStyle_Map);
    m_refIfcDraughtingCalloutList.push_back(&m_IfcDraughtingCallout_Map);
    m_refIfcDraughtingCalloutRelationshipList.push_back(&m_IfcDraughtingCalloutRelationship_Map);
    m_refIfcDraughtingPreDefinedColourList.push_back(&m_IfcDraughtingPreDefinedColour_Map);
    m_refIfcDraughtingPreDefinedCurveFontList.push_back(&m_IfcDraughtingPreDefinedCurveFont_Map);
    m_refIfcDraughtingPreDefinedTextFontList.push_back(&m_IfcDraughtingPreDefinedTextFont_Map);
    m_refIfcDuctFittingTypeList.push_back(&m_IfcDuctFittingType_Map);
    m_refIfcDuctSegmentTypeList.push_back(&m_IfcDuctSegmentType_Map);
    m_refIfcDuctSilencerTypeList.push_back(&m_IfcDuctSilencerType_Map);
    m_refIfcEdgeList.push_back(&m_IfcEdge_Map);
    m_refIfcEdgeCurveList.push_back(&m_IfcEdgeCurve_Map);
    m_refIfcEdgeFeatureList.push_back(&m_IfcEdgeFeature_Map);
    m_refIfcEdgeLoopList.push_back(&m_IfcEdgeLoop_Map);
    m_refIfcElectricalBasePropertiesList.push_back(&m_IfcElectricalBaseProperties_Map);
    m_refIfcElectricalCircuitList.push_back(&m_IfcElectricalCircuit_Map);
    m_refIfcElectricalElementList.push_back(&m_IfcElectricalElement_Map);
    m_refIfcElectricApplianceTypeList.push_back(&m_IfcElectricApplianceType_Map);
    m_refIfcElectricDistributionPointList.push_back(&m_IfcElectricDistributionPoint_Map);
    m_refIfcElectricFlowStorageDeviceTypeList.push_back(&m_IfcElectricFlowStorageDeviceType_Map);
    m_refIfcElectricGeneratorTypeList.push_back(&m_IfcElectricGeneratorType_Map);
    m_refIfcElectricHeaterTypeList.push_back(&m_IfcElectricHeaterType_Map);
    m_refIfcElectricMotorTypeList.push_back(&m_IfcElectricMotorType_Map);
    m_refIfcElectricTimeControlTypeList.push_back(&m_IfcElectricTimeControlType_Map);
    m_refIfcElementList.push_back(&m_IfcElement_Map);
    m_refIfcElementarySurfaceList.push_back(&m_IfcElementarySurface_Map);
    m_refIfcElementAssemblyList.push_back(&m_IfcElementAssembly_Map);
    m_refIfcElementComponentList.push_back(&m_IfcElementComponent_Map);
    m_refIfcElementComponentTypeList.push_back(&m_IfcElementComponentType_Map);
    m_refIfcElementQuantityList.push_back(&m_IfcElementQuantity_Map);
    m_refIfcElementTypeList.push_back(&m_IfcElementType_Map);
    m_refIfcEllipseList.push_back(&m_IfcEllipse_Map);
    m_refIfcEllipseProfileDefList.push_back(&m_IfcEllipseProfileDef_Map);
    m_refIfcEnergyConversionDeviceList.push_back(&m_IfcEnergyConversionDevice_Map);
    m_refIfcEnergyConversionDeviceTypeList.push_back(&m_IfcEnergyConversionDeviceType_Map);
    m_refIfcEnergyPropertiesList.push_back(&m_IfcEnergyProperties_Map);
    m_refIfcEnvironmentalImpactValueList.push_back(&m_IfcEnvironmentalImpactValue_Map);
    m_refIfcEquipmentElementList.push_back(&m_IfcEquipmentElement_Map);
    m_refIfcEquipmentStandardList.push_back(&m_IfcEquipmentStandard_Map);
    m_refIfcEvaporativeCoolerTypeList.push_back(&m_IfcEvaporativeCoolerType_Map);
    m_refIfcEvaporatorTypeList.push_back(&m_IfcEvaporatorType_Map);
    m_refIfcExtendedMaterialPropertiesList.push_back(&m_IfcExtendedMaterialProperties_Map);
    m_refIfcExternallyDefinedHatchStyleList.push_back(&m_IfcExternallyDefinedHatchStyle_Map);
    m_refIfcExternallyDefinedSurfaceStyleList.push_back(&m_IfcExternallyDefinedSurfaceStyle_Map);
    m_refIfcExternallyDefinedSymbolList.push_back(&m_IfcExternallyDefinedSymbol_Map);
    m_refIfcExternallyDefinedTextFontList.push_back(&m_IfcExternallyDefinedTextFont_Map);
    m_refIfcExternalReferenceList.push_back(&m_IfcExternalReference_Map);
    m_refIfcExtrudedAreaSolidList.push_back(&m_IfcExtrudedAreaSolid_Map);
    m_refIfcFaceList.push_back(&m_IfcFace_Map);
    m_refIfcFaceBasedSurfaceModelList.push_back(&m_IfcFaceBasedSurfaceModel_Map);
    m_refIfcFaceBoundList.push_back(&m_IfcFaceBound_Map);
    m_refIfcFaceOuterBoundList.push_back(&m_IfcFaceOuterBound_Map);
    m_refIfcFaceSurfaceList.push_back(&m_IfcFaceSurface_Map);
    m_refIfcFacetedBrepList.push_back(&m_IfcFacetedBrep_Map);
    m_refIfcFacetedBrepWithVoidsList.push_back(&m_IfcFacetedBrepWithVoids_Map);
    m_refIfcFailureConnectionConditionList.push_back(&m_IfcFailureConnectionCondition_Map);
    m_refIfcFanTypeList.push_back(&m_IfcFanType_Map);
    m_refIfcFastenerList.push_back(&m_IfcFastener_Map);
    m_refIfcFastenerTypeList.push_back(&m_IfcFastenerType_Map);
    m_refIfcFeatureElementList.push_back(&m_IfcFeatureElement_Map);
    m_refIfcFeatureElementAdditionList.push_back(&m_IfcFeatureElementAddition_Map);
    m_refIfcFeatureElementSubtractionList.push_back(&m_IfcFeatureElementSubtraction_Map);
    m_refIfcFillAreaStyleList.push_back(&m_IfcFillAreaStyle_Map);
    m_refIfcFillAreaStyleHatchingList.push_back(&m_IfcFillAreaStyleHatching_Map);
    m_refIfcFillAreaStyleTilesList.push_back(&m_IfcFillAreaStyleTiles_Map);
    m_refIfcFillAreaStyleTileSymbolWithStyleList.push_back(&m_IfcFillAreaStyleTileSymbolWithStyle_Map);
    m_refIfcFilterTypeList.push_back(&m_IfcFilterType_Map);
    m_refIfcFireSuppressionTerminalTypeList.push_back(&m_IfcFireSuppressionTerminalType_Map);
    m_refIfcFlowControllerList.push_back(&m_IfcFlowController_Map);
    m_refIfcFlowControllerTypeList.push_back(&m_IfcFlowControllerType_Map);
    m_refIfcFlowFittingList.push_back(&m_IfcFlowFitting_Map);
    m_refIfcFlowFittingTypeList.push_back(&m_IfcFlowFittingType_Map);
    m_refIfcFlowInstrumentTypeList.push_back(&m_IfcFlowInstrumentType_Map);
    m_refIfcFlowMeterTypeList.push_back(&m_IfcFlowMeterType_Map);
    m_refIfcFlowMovingDeviceList.push_back(&m_IfcFlowMovingDevice_Map);
    m_refIfcFlowMovingDeviceTypeList.push_back(&m_IfcFlowMovingDeviceType_Map);
    m_refIfcFlowSegmentList.push_back(&m_IfcFlowSegment_Map);
    m_refIfcFlowSegmentTypeList.push_back(&m_IfcFlowSegmentType_Map);
    m_refIfcFlowStorageDeviceList.push_back(&m_IfcFlowStorageDevice_Map);
    m_refIfcFlowStorageDeviceTypeList.push_back(&m_IfcFlowStorageDeviceType_Map);
    m_refIfcFlowTerminalList.push_back(&m_IfcFlowTerminal_Map);
    m_refIfcFlowTerminalTypeList.push_back(&m_IfcFlowTerminalType_Map);
    m_refIfcFlowTreatmentDeviceList.push_back(&m_IfcFlowTreatmentDevice_Map);
    m_refIfcFlowTreatmentDeviceTypeList.push_back(&m_IfcFlowTreatmentDeviceType_Map);
    m_refIfcFluidFlowPropertiesList.push_back(&m_IfcFluidFlowProperties_Map);
    m_refIfcFootingList.push_back(&m_IfcFooting_Map);
    m_refIfcFuelPropertiesList.push_back(&m_IfcFuelProperties_Map);
    m_refIfcFurnishingElementList.push_back(&m_IfcFurnishingElement_Map);
    m_refIfcFurnishingElementTypeList.push_back(&m_IfcFurnishingElementType_Map);
    m_refIfcFurnitureStandardList.push_back(&m_IfcFurnitureStandard_Map);
    m_refIfcFurnitureTypeList.push_back(&m_IfcFurnitureType_Map);
    m_refIfcGasTerminalTypeList.push_back(&m_IfcGasTerminalType_Map);
    m_refIfcGeneralMaterialPropertiesList.push_back(&m_IfcGeneralMaterialProperties_Map);
    m_refIfcGeneralProfilePropertiesList.push_back(&m_IfcGeneralProfileProperties_Map);
    m_refIfcGeometricCurveSetList.push_back(&m_IfcGeometricCurveSet_Map);
    m_refIfcGeometricRepresentationContextList.push_back(&m_IfcGeometricRepresentationContext_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcGeometricRepresentationItem_Map);
    m_refIfcGeometricRepresentationSubContextList.push_back(&m_IfcGeometricRepresentationSubContext_Map);
    m_refIfcGeometricSetList.push_back(&m_IfcGeometricSet_Map);
    m_refIfcGridList.push_back(&m_IfcGrid_Map);
    m_refIfcGridAxisList.push_back(&m_IfcGridAxis_Map);
    m_refIfcGridPlacementList.push_back(&m_IfcGridPlacement_Map);
    m_refIfcGroupList.push_back(&m_IfcGroup_Map);
    m_refIfcHalfSpaceSolidList.push_back(&m_IfcHalfSpaceSolid_Map);
    m_refIfcHeatExchangerTypeList.push_back(&m_IfcHeatExchangerType_Map);
    m_refIfcHumidifierTypeList.push_back(&m_IfcHumidifierType_Map);
    m_refIfcHygroscopicMaterialPropertiesList.push_back(&m_IfcHygroscopicMaterialProperties_Map);
    m_refIfcImageTextureList.push_back(&m_IfcImageTexture_Map);
    m_refIfcInventoryList.push_back(&m_IfcInventory_Map);
    m_refIfcIrregularTimeSeriesList.push_back(&m_IfcIrregularTimeSeries_Map);
    m_refIfcIrregularTimeSeriesValueList.push_back(&m_IfcIrregularTimeSeriesValue_Map);
    m_refIfcIShapeProfileDefList.push_back(&m_IfcIShapeProfileDef_Map);
    m_refIfcJunctionBoxTypeList.push_back(&m_IfcJunctionBoxType_Map);
    m_refIfcLaborResourceList.push_back(&m_IfcLaborResource_Map);
    m_refIfcLampTypeList.push_back(&m_IfcLampType_Map);
    m_refIfcLibraryInformationList.push_back(&m_IfcLibraryInformation_Map);
    m_refIfcLibraryReferenceList.push_back(&m_IfcLibraryReference_Map);
    m_refIfcLightDistributionDataList.push_back(&m_IfcLightDistributionData_Map);
    m_refIfcLightFixtureTypeList.push_back(&m_IfcLightFixtureType_Map);
    m_refIfcLightIntensityDistributionList.push_back(&m_IfcLightIntensityDistribution_Map);
    m_refIfcLightSourceList.push_back(&m_IfcLightSource_Map);
    m_refIfcLightSourceAmbientList.push_back(&m_IfcLightSourceAmbient_Map);
    m_refIfcLightSourceDirectionalList.push_back(&m_IfcLightSourceDirectional_Map);
    m_refIfcLightSourceGoniometricList.push_back(&m_IfcLightSourceGoniometric_Map);
    m_refIfcLightSourcePositionalList.push_back(&m_IfcLightSourcePositional_Map);
    m_refIfcLightSourceSpotList.push_back(&m_IfcLightSourceSpot_Map);
    m_refIfcLineList.push_back(&m_IfcLine_Map);
    m_refIfcLinearDimensionList.push_back(&m_IfcLinearDimension_Map);
    m_refIfcLocalPlacementList.push_back(&m_IfcLocalPlacement_Map);
    m_refIfcLocalTimeList.push_back(&m_IfcLocalTime_Map);
    m_refIfcLoopList.push_back(&m_IfcLoop_Map);
    m_refIfcLShapeProfileDefList.push_back(&m_IfcLShapeProfileDef_Map);
    m_refIfcManifoldSolidBrepList.push_back(&m_IfcManifoldSolidBrep_Map);
    m_refIfcMappedItemList.push_back(&m_IfcMappedItem_Map);
    m_refIfcMaterialList.push_back(&m_IfcMaterial_Map);
    m_refIfcMaterialClassificationRelationshipList.push_back(&m_IfcMaterialClassificationRelationship_Map);
    m_refIfcMaterialDefinitionRepresentationList.push_back(&m_IfcMaterialDefinitionRepresentation_Map);
    m_refIfcMaterialLayerList.push_back(&m_IfcMaterialLayer_Map);
    m_refIfcMaterialLayerSetList.push_back(&m_IfcMaterialLayerSet_Map);
    m_refIfcMaterialLayerSetUsageList.push_back(&m_IfcMaterialLayerSetUsage_Map);
    m_refIfcMaterialListList.push_back(&m_IfcMaterialList_Map);
    m_refIfcMaterialPropertiesList.push_back(&m_IfcMaterialProperties_Map);
    m_refIfcMeasureWithUnitList.push_back(&m_IfcMeasureWithUnit_Map);
    m_refIfcMechanicalConcreteMaterialPropertiesList.push_back(&m_IfcMechanicalConcreteMaterialProperties_Map);
    m_refIfcMechanicalFastenerList.push_back(&m_IfcMechanicalFastener_Map);
    m_refIfcMechanicalFastenerTypeList.push_back(&m_IfcMechanicalFastenerType_Map);
    m_refIfcMechanicalMaterialPropertiesList.push_back(&m_IfcMechanicalMaterialProperties_Map);
    m_refIfcMechanicalSteelMaterialPropertiesList.push_back(&m_IfcMechanicalSteelMaterialProperties_Map);
    m_refIfcMemberList.push_back(&m_IfcMember_Map);
    m_refIfcMemberTypeList.push_back(&m_IfcMemberType_Map);
    m_refIfcMetricList.push_back(&m_IfcMetric_Map);
    m_refIfcMonetaryUnitList.push_back(&m_IfcMonetaryUnit_Map);
    m_refIfcMotorConnectionTypeList.push_back(&m_IfcMotorConnectionType_Map);
    m_refIfcMoveList.push_back(&m_IfcMove_Map);
    m_refIfcNamedUnitList.push_back(&m_IfcNamedUnit_Map);
    m_refIfcObjectList.push_back(&m_IfcObject_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcObjectDefinition_Map);
    m_refIfcObjectiveList.push_back(&m_IfcObjective_Map);
    m_refIfcObjectPlacementList.push_back(&m_IfcObjectPlacement_Map);
    m_refIfcOccupantList.push_back(&m_IfcOccupant_Map);
    m_refIfcOffsetCurve2DList.push_back(&m_IfcOffsetCurve2D_Map);
    m_refIfcOffsetCurve3DList.push_back(&m_IfcOffsetCurve3D_Map);
    m_refIfcOneDirectionRepeatFactorList.push_back(&m_IfcOneDirectionRepeatFactor_Map);
    m_refIfcOpeningElementList.push_back(&m_IfcOpeningElement_Map);
    m_refIfcOpenShellList.push_back(&m_IfcOpenShell_Map);
    m_refIfcOpticalMaterialPropertiesList.push_back(&m_IfcOpticalMaterialProperties_Map);
    m_refIfcOrderActionList.push_back(&m_IfcOrderAction_Map);
    m_refIfcOrganizationList.push_back(&m_IfcOrganization_Map);
    m_refIfcOrganizationRelationshipList.push_back(&m_IfcOrganizationRelationship_Map);
    m_refIfcOrientedEdgeList.push_back(&m_IfcOrientedEdge_Map);
    m_refIfcOutletTypeList.push_back(&m_IfcOutletType_Map);
    m_refIfcOwnerHistoryList.push_back(&m_IfcOwnerHistory_Map);
    m_refIfcParameterizedProfileDefList.push_back(&m_IfcParameterizedProfileDef_Map);
    m_refIfcPathList.push_back(&m_IfcPath_Map);
    m_refIfcPerformanceHistoryList.push_back(&m_IfcPerformanceHistory_Map);
    m_refIfcPermeableCoveringPropertiesList.push_back(&m_IfcPermeableCoveringProperties_Map);
    m_refIfcPermitList.push_back(&m_IfcPermit_Map);
    m_refIfcPersonList.push_back(&m_IfcPerson_Map);
    m_refIfcPersonAndOrganizationList.push_back(&m_IfcPersonAndOrganization_Map);
    m_refIfcPhysicalComplexQuantityList.push_back(&m_IfcPhysicalComplexQuantity_Map);
    m_refIfcPhysicalQuantityList.push_back(&m_IfcPhysicalQuantity_Map);
    m_refIfcPhysicalSimpleQuantityList.push_back(&m_IfcPhysicalSimpleQuantity_Map);
    m_refIfcPileList.push_back(&m_IfcPile_Map);
    m_refIfcPipeFittingTypeList.push_back(&m_IfcPipeFittingType_Map);
    m_refIfcPipeSegmentTypeList.push_back(&m_IfcPipeSegmentType_Map);
    m_refIfcPixelTextureList.push_back(&m_IfcPixelTexture_Map);
    m_refIfcPlacementList.push_back(&m_IfcPlacement_Map);
    m_refIfcPlanarBoxList.push_back(&m_IfcPlanarBox_Map);
    m_refIfcPlanarExtentList.push_back(&m_IfcPlanarExtent_Map);
    m_refIfcPlaneList.push_back(&m_IfcPlane_Map);
    m_refIfcPlateList.push_back(&m_IfcPlate_Map);
    m_refIfcPlateTypeList.push_back(&m_IfcPlateType_Map);
    m_refIfcPointList.push_back(&m_IfcPoint_Map);
    m_refIfcPointOnCurveList.push_back(&m_IfcPointOnCurve_Map);
    m_refIfcPointOnSurfaceList.push_back(&m_IfcPointOnSurface_Map);
    m_refIfcPolygonalBoundedHalfSpaceList.push_back(&m_IfcPolygonalBoundedHalfSpace_Map);
    m_refIfcPolylineList.push_back(&m_IfcPolyline_Map);
    m_refIfcPolyLoopList.push_back(&m_IfcPolyLoop_Map);
    m_refIfcPortList.push_back(&m_IfcPort_Map);
    m_refIfcPostalAddressList.push_back(&m_IfcPostalAddress_Map);
    m_refIfcPreDefinedColourList.push_back(&m_IfcPreDefinedColour_Map);
    m_refIfcPreDefinedCurveFontList.push_back(&m_IfcPreDefinedCurveFont_Map);
    m_refIfcPreDefinedDimensionSymbolList.push_back(&m_IfcPreDefinedDimensionSymbol_Map);
    m_refIfcPreDefinedItemList.push_back(&m_IfcPreDefinedItem_Map);
    m_refIfcPreDefinedPointMarkerSymbolList.push_back(&m_IfcPreDefinedPointMarkerSymbol_Map);
    m_refIfcPreDefinedSymbolList.push_back(&m_IfcPreDefinedSymbol_Map);
    m_refIfcPreDefinedTerminatorSymbolList.push_back(&m_IfcPreDefinedTerminatorSymbol_Map);
    m_refIfcPreDefinedTextFontList.push_back(&m_IfcPreDefinedTextFont_Map);
    m_refIfcPresentationLayerAssignmentList.push_back(&m_IfcPresentationLayerAssignment_Map);
    m_refIfcPresentationLayerWithStyleList.push_back(&m_IfcPresentationLayerWithStyle_Map);
    m_refIfcPresentationStyleList.push_back(&m_IfcPresentationStyle_Map);
    m_refIfcPresentationStyleAssignmentList.push_back(&m_IfcPresentationStyleAssignment_Map);
    m_refIfcProcedureList.push_back(&m_IfcProcedure_Map);
    m_refIfcProcessList.push_back(&m_IfcProcess_Map);
    m_refIfcProductList.push_back(&m_IfcProduct_Map);
    m_refIfcProductDefinitionShapeList.push_back(&m_IfcProductDefinitionShape_Map);
    m_refIfcProductRepresentationList.push_back(&m_IfcProductRepresentation_Map);
    m_refIfcProductsOfCombustionPropertiesList.push_back(&m_IfcProductsOfCombustionProperties_Map);
    m_refIfcProfileDefList.push_back(&m_IfcProfileDef_Map);
    m_refIfcProfilePropertiesList.push_back(&m_IfcProfileProperties_Map);
    m_refIfcProjectList.push_back(&m_IfcProject_Map);
    m_refIfcProjectionCurveList.push_back(&m_IfcProjectionCurve_Map);
    m_refIfcProjectionElementList.push_back(&m_IfcProjectionElement_Map);
    m_refIfcProjectOrderList.push_back(&m_IfcProjectOrder_Map);
    m_refIfcProjectOrderRecordList.push_back(&m_IfcProjectOrderRecord_Map);
    m_refIfcPropertyList.push_back(&m_IfcProperty_Map);
    m_refIfcPropertyBoundedValueList.push_back(&m_IfcPropertyBoundedValue_Map);
    m_refIfcPropertyConstraintRelationshipList.push_back(&m_IfcPropertyConstraintRelationship_Map);
    m_refIfcPropertyDefinitionList.push_back(&m_IfcPropertyDefinition_Map);
    m_refIfcPropertyDependencyRelationshipList.push_back(&m_IfcPropertyDependencyRelationship_Map);
    m_refIfcPropertyEnumeratedValueList.push_back(&m_IfcPropertyEnumeratedValue_Map);
    m_refIfcPropertyEnumerationList.push_back(&m_IfcPropertyEnumeration_Map);
    m_refIfcPropertyListValueList.push_back(&m_IfcPropertyListValue_Map);
    m_refIfcPropertyReferenceValueList.push_back(&m_IfcPropertyReferenceValue_Map);
    m_refIfcPropertySetList.push_back(&m_IfcPropertySet_Map);
    m_refIfcPropertySetDefinitionList.push_back(&m_IfcPropertySetDefinition_Map);
    m_refIfcPropertySingleValueList.push_back(&m_IfcPropertySingleValue_Map);
    m_refIfcPropertyTableValueList.push_back(&m_IfcPropertyTableValue_Map);
    m_refIfcProtectiveDeviceTypeList.push_back(&m_IfcProtectiveDeviceType_Map);
    m_refIfcProxyList.push_back(&m_IfcProxy_Map);
    m_refIfcPumpTypeList.push_back(&m_IfcPumpType_Map);
    m_refIfcQuantityAreaList.push_back(&m_IfcQuantityArea_Map);
    m_refIfcQuantityCountList.push_back(&m_IfcQuantityCount_Map);
    m_refIfcQuantityLengthList.push_back(&m_IfcQuantityLength_Map);
    m_refIfcQuantityTimeList.push_back(&m_IfcQuantityTime_Map);
    m_refIfcQuantityVolumeList.push_back(&m_IfcQuantityVolume_Map);
    m_refIfcQuantityWeightList.push_back(&m_IfcQuantityWeight_Map);
    m_refIfcRadiusDimensionList.push_back(&m_IfcRadiusDimension_Map);
    m_refIfcRailingList.push_back(&m_IfcRailing_Map);
    m_refIfcRailingTypeList.push_back(&m_IfcRailingType_Map);
    m_refIfcRampList.push_back(&m_IfcRamp_Map);
    m_refIfcRampFlightList.push_back(&m_IfcRampFlight_Map);
    m_refIfcRampFlightTypeList.push_back(&m_IfcRampFlightType_Map);
    m_refIfcRationalBezierCurveList.push_back(&m_IfcRationalBezierCurve_Map);
    m_refIfcRectangleHollowProfileDefList.push_back(&m_IfcRectangleHollowProfileDef_Map);
    m_refIfcRectangleProfileDefList.push_back(&m_IfcRectangleProfileDef_Map);
    m_refIfcRectangularPyramidList.push_back(&m_IfcRectangularPyramid_Map);
    m_refIfcRectangularTrimmedSurfaceList.push_back(&m_IfcRectangularTrimmedSurface_Map);
    m_refIfcReferencesValueDocumentList.push_back(&m_IfcReferencesValueDocument_Map);
    m_refIfcRegularTimeSeriesList.push_back(&m_IfcRegularTimeSeries_Map);
    m_refIfcReinforcementBarPropertiesList.push_back(&m_IfcReinforcementBarProperties_Map);
    m_refIfcReinforcementDefinitionPropertiesList.push_back(&m_IfcReinforcementDefinitionProperties_Map);
    m_refIfcReinforcingBarList.push_back(&m_IfcReinforcingBar_Map);
    m_refIfcReinforcingElementList.push_back(&m_IfcReinforcingElement_Map);
    m_refIfcReinforcingMeshList.push_back(&m_IfcReinforcingMesh_Map);
    m_refIfcRelAggregatesList.push_back(&m_IfcRelAggregates_Map);
    m_refIfcRelAssignsList.push_back(&m_IfcRelAssigns_Map);
    m_refIfcRelAssignsTasksList.push_back(&m_IfcRelAssignsTasks_Map);
    m_refIfcRelAssignsToActorList.push_back(&m_IfcRelAssignsToActor_Map);
    m_refIfcRelAssignsToControlList.push_back(&m_IfcRelAssignsToControl_Map);
    m_refIfcRelAssignsToGroupList.push_back(&m_IfcRelAssignsToGroup_Map);
    m_refIfcRelAssignsToProcessList.push_back(&m_IfcRelAssignsToProcess_Map);
    m_refIfcRelAssignsToProductList.push_back(&m_IfcRelAssignsToProduct_Map);
    m_refIfcRelAssignsToProjectOrderList.push_back(&m_IfcRelAssignsToProjectOrder_Map);
    m_refIfcRelAssignsToResourceList.push_back(&m_IfcRelAssignsToResource_Map);
    m_refIfcRelAssociatesList.push_back(&m_IfcRelAssociates_Map);
    m_refIfcRelAssociatesAppliedValueList.push_back(&m_IfcRelAssociatesAppliedValue_Map);
    m_refIfcRelAssociatesApprovalList.push_back(&m_IfcRelAssociatesApproval_Map);
    m_refIfcRelAssociatesClassificationList.push_back(&m_IfcRelAssociatesClassification_Map);
    m_refIfcRelAssociatesConstraintList.push_back(&m_IfcRelAssociatesConstraint_Map);
    m_refIfcRelAssociatesDocumentList.push_back(&m_IfcRelAssociatesDocument_Map);
    m_refIfcRelAssociatesLibraryList.push_back(&m_IfcRelAssociatesLibrary_Map);
    m_refIfcRelAssociatesMaterialList.push_back(&m_IfcRelAssociatesMaterial_Map);
    m_refIfcRelAssociatesProfilePropertiesList.push_back(&m_IfcRelAssociatesProfileProperties_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelationship_Map);
    m_refIfcRelaxationList.push_back(&m_IfcRelaxation_Map);
    m_refIfcRelConnectsList.push_back(&m_IfcRelConnects_Map);
    m_refIfcRelConnectsElementsList.push_back(&m_IfcRelConnectsElements_Map);
    m_refIfcRelConnectsPathElementsList.push_back(&m_IfcRelConnectsPathElements_Map);
    m_refIfcRelConnectsPortsList.push_back(&m_IfcRelConnectsPorts_Map);
    m_refIfcRelConnectsPortToElementList.push_back(&m_IfcRelConnectsPortToElement_Map);
    m_refIfcRelConnectsStructuralActivityList.push_back(&m_IfcRelConnectsStructuralActivity_Map);
    m_refIfcRelConnectsStructuralElementList.push_back(&m_IfcRelConnectsStructuralElement_Map);
    m_refIfcRelConnectsStructuralMemberList.push_back(&m_IfcRelConnectsStructuralMember_Map);
    m_refIfcRelConnectsWithEccentricityList.push_back(&m_IfcRelConnectsWithEccentricity_Map);
    m_refIfcRelConnectsWithRealizingElementsList.push_back(&m_IfcRelConnectsWithRealizingElements_Map);
    m_refIfcRelContainedInSpatialStructureList.push_back(&m_IfcRelContainedInSpatialStructure_Map);
    m_refIfcRelCoversBldgElementsList.push_back(&m_IfcRelCoversBldgElements_Map);
    m_refIfcRelCoversSpacesList.push_back(&m_IfcRelCoversSpaces_Map);
    m_refIfcRelDecomposesList.push_back(&m_IfcRelDecomposes_Map);
    m_refIfcRelDefinesList.push_back(&m_IfcRelDefines_Map);
    m_refIfcRelDefinesByPropertiesList.push_back(&m_IfcRelDefinesByProperties_Map);
    m_refIfcRelDefinesByTypeList.push_back(&m_IfcRelDefinesByType_Map);
    m_refIfcRelFillsElementList.push_back(&m_IfcRelFillsElement_Map);
    m_refIfcRelFlowControlElementsList.push_back(&m_IfcRelFlowControlElements_Map);
    m_refIfcRelInteractionRequirementsList.push_back(&m_IfcRelInteractionRequirements_Map);
    m_refIfcRelNestsList.push_back(&m_IfcRelNests_Map);
    m_refIfcRelOccupiesSpacesList.push_back(&m_IfcRelOccupiesSpaces_Map);
    m_refIfcRelOverridesPropertiesList.push_back(&m_IfcRelOverridesProperties_Map);
    m_refIfcRelProjectsElementList.push_back(&m_IfcRelProjectsElement_Map);
    m_refIfcRelReferencedInSpatialStructureList.push_back(&m_IfcRelReferencedInSpatialStructure_Map);
    m_refIfcRelSchedulesCostItemsList.push_back(&m_IfcRelSchedulesCostItems_Map);
    m_refIfcRelSequenceList.push_back(&m_IfcRelSequence_Map);
    m_refIfcRelServicesBuildingsList.push_back(&m_IfcRelServicesBuildings_Map);
    m_refIfcRelSpaceBoundaryList.push_back(&m_IfcRelSpaceBoundary_Map);
    m_refIfcRelVoidsElementList.push_back(&m_IfcRelVoidsElement_Map);
    m_refIfcRepresentationList.push_back(&m_IfcRepresentation_Map);
    m_refIfcRepresentationContextList.push_back(&m_IfcRepresentationContext_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcRepresentationItem_Map);
    m_refIfcRepresentationMapList.push_back(&m_IfcRepresentationMap_Map);
    m_refIfcResourceList.push_back(&m_IfcResource_Map);
    m_refIfcRevolvedAreaSolidList.push_back(&m_IfcRevolvedAreaSolid_Map);
    m_refIfcRibPlateProfilePropertiesList.push_back(&m_IfcRibPlateProfileProperties_Map);
    m_refIfcRightCircularConeList.push_back(&m_IfcRightCircularCone_Map);
    m_refIfcRightCircularCylinderList.push_back(&m_IfcRightCircularCylinder_Map);
    m_refIfcRoofList.push_back(&m_IfcRoof_Map);
    m_refIfcRootList.push_back(&m_IfcRoot_Map);
    m_refIfcRoundedEdgeFeatureList.push_back(&m_IfcRoundedEdgeFeature_Map);
    m_refIfcRoundedRectangleProfileDefList.push_back(&m_IfcRoundedRectangleProfileDef_Map);
    m_refIfcSanitaryTerminalTypeList.push_back(&m_IfcSanitaryTerminalType_Map);
    m_refIfcScheduleTimeControlList.push_back(&m_IfcScheduleTimeControl_Map);
    m_refIfcSectionedSpineList.push_back(&m_IfcSectionedSpine_Map);
    m_refIfcSectionPropertiesList.push_back(&m_IfcSectionProperties_Map);
    m_refIfcSectionReinforcementPropertiesList.push_back(&m_IfcSectionReinforcementProperties_Map);
    m_refIfcSensorTypeList.push_back(&m_IfcSensorType_Map);
    m_refIfcServiceLifeList.push_back(&m_IfcServiceLife_Map);
    m_refIfcServiceLifeFactorList.push_back(&m_IfcServiceLifeFactor_Map);
    m_refIfcShapeAspectList.push_back(&m_IfcShapeAspect_Map);
    m_refIfcShapeModelList.push_back(&m_IfcShapeModel_Map);
    m_refIfcShapeRepresentationList.push_back(&m_IfcShapeRepresentation_Map);
    m_refIfcShellBasedSurfaceModelList.push_back(&m_IfcShellBasedSurfaceModel_Map);
    m_refIfcSimplePropertyList.push_back(&m_IfcSimpleProperty_Map);
    m_refIfcSiteList.push_back(&m_IfcSite_Map);
    m_refIfcSIUnitList.push_back(&m_IfcSIUnit_Map);
    m_refIfcSlabList.push_back(&m_IfcSlab_Map);
    m_refIfcSlabTypeList.push_back(&m_IfcSlabType_Map);
    m_refIfcSlippageConnectionConditionList.push_back(&m_IfcSlippageConnectionCondition_Map);
    m_refIfcSolidModelList.push_back(&m_IfcSolidModel_Map);
    m_refIfcSoundPropertiesList.push_back(&m_IfcSoundProperties_Map);
    m_refIfcSoundValueList.push_back(&m_IfcSoundValue_Map);
    m_refIfcSpaceList.push_back(&m_IfcSpace_Map);
    m_refIfcSpaceHeaterTypeList.push_back(&m_IfcSpaceHeaterType_Map);
    m_refIfcSpaceProgramList.push_back(&m_IfcSpaceProgram_Map);
    m_refIfcSpaceThermalLoadPropertiesList.push_back(&m_IfcSpaceThermalLoadProperties_Map);
    m_refIfcSpaceTypeList.push_back(&m_IfcSpaceType_Map);
    m_refIfcSpatialStructureElementList.push_back(&m_IfcSpatialStructureElement_Map);
    m_refIfcSpatialStructureElementTypeList.push_back(&m_IfcSpatialStructureElementType_Map);
    m_refIfcSphereList.push_back(&m_IfcSphere_Map);
    m_refIfcStackTerminalTypeList.push_back(&m_IfcStackTerminalType_Map);
    m_refIfcStairList.push_back(&m_IfcStair_Map);
    m_refIfcStairFlightList.push_back(&m_IfcStairFlight_Map);
    m_refIfcStairFlightTypeList.push_back(&m_IfcStairFlightType_Map);
    m_refIfcStructuralActionList.push_back(&m_IfcStructuralAction_Map);
    m_refIfcStructuralActivityList.push_back(&m_IfcStructuralActivity_Map);
    m_refIfcStructuralAnalysisModelList.push_back(&m_IfcStructuralAnalysisModel_Map);
    m_refIfcStructuralConnectionList.push_back(&m_IfcStructuralConnection_Map);
    m_refIfcStructuralConnectionConditionList.push_back(&m_IfcStructuralConnectionCondition_Map);
    m_refIfcStructuralCurveConnectionList.push_back(&m_IfcStructuralCurveConnection_Map);
    m_refIfcStructuralCurveMemberList.push_back(&m_IfcStructuralCurveMember_Map);
    m_refIfcStructuralCurveMemberVaryingList.push_back(&m_IfcStructuralCurveMemberVarying_Map);
    m_refIfcStructuralItemList.push_back(&m_IfcStructuralItem_Map);
    m_refIfcStructuralLinearActionList.push_back(&m_IfcStructuralLinearAction_Map);
    m_refIfcStructuralLinearActionVaryingList.push_back(&m_IfcStructuralLinearActionVarying_Map);
    m_refIfcStructuralLoadList.push_back(&m_IfcStructuralLoad_Map);
    m_refIfcStructuralLoadGroupList.push_back(&m_IfcStructuralLoadGroup_Map);
    m_refIfcStructuralLoadLinearForceList.push_back(&m_IfcStructuralLoadLinearForce_Map);
    m_refIfcStructuralLoadPlanarForceList.push_back(&m_IfcStructuralLoadPlanarForce_Map);
    m_refIfcStructuralLoadSingleDisplacementList.push_back(&m_IfcStructuralLoadSingleDisplacement_Map);
    m_refIfcStructuralLoadSingleDisplacementDistortionList.push_back(&m_IfcStructuralLoadSingleDisplacementDistortion_Map);
    m_refIfcStructuralLoadSingleForceList.push_back(&m_IfcStructuralLoadSingleForce_Map);
    m_refIfcStructuralLoadSingleForceWarpingList.push_back(&m_IfcStructuralLoadSingleForceWarping_Map);
    m_refIfcStructuralLoadStaticList.push_back(&m_IfcStructuralLoadStatic_Map);
    m_refIfcStructuralLoadTemperatureList.push_back(&m_IfcStructuralLoadTemperature_Map);
    m_refIfcStructuralMemberList.push_back(&m_IfcStructuralMember_Map);
    m_refIfcStructuralPlanarActionList.push_back(&m_IfcStructuralPlanarAction_Map);
    m_refIfcStructuralPlanarActionVaryingList.push_back(&m_IfcStructuralPlanarActionVarying_Map);
    m_refIfcStructuralPointActionList.push_back(&m_IfcStructuralPointAction_Map);
    m_refIfcStructuralPointConnectionList.push_back(&m_IfcStructuralPointConnection_Map);
    m_refIfcStructuralPointReactionList.push_back(&m_IfcStructuralPointReaction_Map);
    m_refIfcStructuralProfilePropertiesList.push_back(&m_IfcStructuralProfileProperties_Map);
    m_refIfcStructuralReactionList.push_back(&m_IfcStructuralReaction_Map);
    m_refIfcStructuralResultGroupList.push_back(&m_IfcStructuralResultGroup_Map);
    m_refIfcStructuralSteelProfilePropertiesList.push_back(&m_IfcStructuralSteelProfileProperties_Map);
    m_refIfcStructuralSurfaceConnectionList.push_back(&m_IfcStructuralSurfaceConnection_Map);
    m_refIfcStructuralSurfaceMemberList.push_back(&m_IfcStructuralSurfaceMember_Map);
    m_refIfcStructuralSurfaceMemberVaryingList.push_back(&m_IfcStructuralSurfaceMemberVarying_Map);
    m_refIfcStructuredDimensionCalloutList.push_back(&m_IfcStructuredDimensionCallout_Map);
    m_refIfcStyledItemList.push_back(&m_IfcStyledItem_Map);
    m_refIfcStyledRepresentationList.push_back(&m_IfcStyledRepresentation_Map);
    m_refIfcStyleModelList.push_back(&m_IfcStyleModel_Map);
    m_refIfcSubContractResourceList.push_back(&m_IfcSubContractResource_Map);
    m_refIfcSubedgeList.push_back(&m_IfcSubedge_Map);
    m_refIfcSurfaceList.push_back(&m_IfcSurface_Map);
    m_refIfcSurfaceCurveSweptAreaSolidList.push_back(&m_IfcSurfaceCurveSweptAreaSolid_Map);
    m_refIfcSurfaceOfLinearExtrusionList.push_back(&m_IfcSurfaceOfLinearExtrusion_Map);
    m_refIfcSurfaceOfRevolutionList.push_back(&m_IfcSurfaceOfRevolution_Map);
    m_refIfcSurfaceStyleList.push_back(&m_IfcSurfaceStyle_Map);
    m_refIfcSurfaceStyleLightingList.push_back(&m_IfcSurfaceStyleLighting_Map);
    m_refIfcSurfaceStyleRefractionList.push_back(&m_IfcSurfaceStyleRefraction_Map);
    m_refIfcSurfaceStyleRenderingList.push_back(&m_IfcSurfaceStyleRendering_Map);
    m_refIfcSurfaceStyleShadingList.push_back(&m_IfcSurfaceStyleShading_Map);
    m_refIfcSurfaceStyleWithTexturesList.push_back(&m_IfcSurfaceStyleWithTextures_Map);
    m_refIfcSurfaceTextureList.push_back(&m_IfcSurfaceTexture_Map);
    m_refIfcSweptAreaSolidList.push_back(&m_IfcSweptAreaSolid_Map);
    m_refIfcSweptDiskSolidList.push_back(&m_IfcSweptDiskSolid_Map);
    m_refIfcSweptSurfaceList.push_back(&m_IfcSweptSurface_Map);
    m_refIfcSwitchingDeviceTypeList.push_back(&m_IfcSwitchingDeviceType_Map);
    m_refIfcSymbolStyleList.push_back(&m_IfcSymbolStyle_Map);
    m_refIfcSystemList.push_back(&m_IfcSystem_Map);
    m_refIfcSystemFurnitureElementTypeList.push_back(&m_IfcSystemFurnitureElementType_Map);
    m_refIfcTableList.push_back(&m_IfcTable_Map);
    m_refIfcTableRowList.push_back(&m_IfcTableRow_Map);
    m_refIfcTankTypeList.push_back(&m_IfcTankType_Map);
    m_refIfcTaskList.push_back(&m_IfcTask_Map);
    m_refIfcTelecomAddressList.push_back(&m_IfcTelecomAddress_Map);
    m_refIfcTendonList.push_back(&m_IfcTendon_Map);
    m_refIfcTendonAnchorList.push_back(&m_IfcTendonAnchor_Map);
    m_refIfcTerminatorSymbolList.push_back(&m_IfcTerminatorSymbol_Map);
    m_refIfcTextLiteralList.push_back(&m_IfcTextLiteral_Map);
    m_refIfcTextLiteralWithExtentList.push_back(&m_IfcTextLiteralWithExtent_Map);
    m_refIfcTextStyleList.push_back(&m_IfcTextStyle_Map);
    m_refIfcTextStyleFontModelList.push_back(&m_IfcTextStyleFontModel_Map);
    m_refIfcTextStyleForDefinedFontList.push_back(&m_IfcTextStyleForDefinedFont_Map);
    m_refIfcTextStyleTextModelList.push_back(&m_IfcTextStyleTextModel_Map);
    m_refIfcTextStyleWithBoxCharacteristicsList.push_back(&m_IfcTextStyleWithBoxCharacteristics_Map);
    m_refIfcTextureCoordinateList.push_back(&m_IfcTextureCoordinate_Map);
    m_refIfcTextureCoordinateGeneratorList.push_back(&m_IfcTextureCoordinateGenerator_Map);
    m_refIfcTextureMapList.push_back(&m_IfcTextureMap_Map);
    m_refIfcTextureVertexList.push_back(&m_IfcTextureVertex_Map);
    m_refIfcThermalMaterialPropertiesList.push_back(&m_IfcThermalMaterialProperties_Map);
    m_refIfcTimeSeriesList.push_back(&m_IfcTimeSeries_Map);
    m_refIfcTimeSeriesReferenceRelationshipList.push_back(&m_IfcTimeSeriesReferenceRelationship_Map);
    m_refIfcTimeSeriesScheduleList.push_back(&m_IfcTimeSeriesSchedule_Map);
    m_refIfcTimeSeriesValueList.push_back(&m_IfcTimeSeriesValue_Map);
    m_refIfcTopologicalRepresentationItemList.push_back(&m_IfcTopologicalRepresentationItem_Map);
    m_refIfcTopologyRepresentationList.push_back(&m_IfcTopologyRepresentation_Map);
    m_refIfcTransformerTypeList.push_back(&m_IfcTransformerType_Map);
    m_refIfcTransportElementList.push_back(&m_IfcTransportElement_Map);
    m_refIfcTransportElementTypeList.push_back(&m_IfcTransportElementType_Map);
    m_refIfcTrapeziumProfileDefList.push_back(&m_IfcTrapeziumProfileDef_Map);
    m_refIfcTrimmedCurveList.push_back(&m_IfcTrimmedCurve_Map);
    m_refIfcTShapeProfileDefList.push_back(&m_IfcTShapeProfileDef_Map);
    m_refIfcTubeBundleTypeList.push_back(&m_IfcTubeBundleType_Map);
    m_refIfcTwoDirectionRepeatFactorList.push_back(&m_IfcTwoDirectionRepeatFactor_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcTypeObject_Map);
    m_refIfcTypeProductList.push_back(&m_IfcTypeProduct_Map);
    m_refIfcUnitaryEquipmentTypeList.push_back(&m_IfcUnitaryEquipmentType_Map);
    m_refIfcUnitAssignmentList.push_back(&m_IfcUnitAssignment_Map);
    m_refIfcUShapeProfileDefList.push_back(&m_IfcUShapeProfileDef_Map);
    m_refIfcValveTypeList.push_back(&m_IfcValveType_Map);
    m_refIfcVectorList.push_back(&m_IfcVector_Map);
    m_refIfcVertexList.push_back(&m_IfcVertex_Map);
    m_refIfcVertexBasedTextureMapList.push_back(&m_IfcVertexBasedTextureMap_Map);
    m_refIfcVertexLoopList.push_back(&m_IfcVertexLoop_Map);
    m_refIfcVertexPointList.push_back(&m_IfcVertexPoint_Map);
    m_refIfcVibrationIsolatorTypeList.push_back(&m_IfcVibrationIsolatorType_Map);
    m_refIfcVirtualElementList.push_back(&m_IfcVirtualElement_Map);
    m_refIfcVirtualGridIntersectionList.push_back(&m_IfcVirtualGridIntersection_Map);
    m_refIfcWallList.push_back(&m_IfcWall_Map);
    m_refIfcWallStandardCaseList.push_back(&m_IfcWallStandardCase_Map);
    m_refIfcWallTypeList.push_back(&m_IfcWallType_Map);
    m_refIfcWasteTerminalTypeList.push_back(&m_IfcWasteTerminalType_Map);
    m_refIfcWaterPropertiesList.push_back(&m_IfcWaterProperties_Map);
    m_refIfcWindowList.push_back(&m_IfcWindow_Map);
    m_refIfcWindowLiningPropertiesList.push_back(&m_IfcWindowLiningProperties_Map);
    m_refIfcWindowPanelPropertiesList.push_back(&m_IfcWindowPanelProperties_Map);
    m_refIfcWindowStyleList.push_back(&m_IfcWindowStyle_Map);
    m_refIfcWorkControlList.push_back(&m_IfcWorkControl_Map);
    m_refIfcWorkPlanList.push_back(&m_IfcWorkPlan_Map);
    m_refIfcWorkScheduleList.push_back(&m_IfcWorkSchedule_Map);
    m_refIfcZoneList.push_back(&m_IfcZone_Map);
    m_refIfcZShapeProfileDefList.push_back(&m_IfcZShapeProfileDef_Map);
}

ExpressDataSet::~ExpressDataSet()
{}


Ifc2DCompositeCurve *ExpressDataSet::getIfc2DCompositeCurve(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< Ifc2DCompositeCurve * > (current->second.get());
    }
    else
    {
        Ifc2DCompositeCurve *ret = static_cast< Ifc2DCompositeCurve * > (allocateIfc2DCompositeCurve(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfc2DCompositeCurve(Ifc2DCompositeCurve *arg)
{
    getAll().erase(arg->getKey());
    return m_Ifc2DCompositeCurve_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfc2DCompositeCurve(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    Ifc2DCompositeCurve *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new Ifc2DCompositeCurve(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_Ifc2DCompositeCurve_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< Ifc2DCompositeCurve > ExpressDataSet::createIfc2DCompositeCurve(bool isVolatile) {
    if (isVolatile)
    {
        return new Ifc2DCompositeCurve(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< Ifc2DCompositeCurve * > (allocateIfc2DCompositeCurve(this, Step::Id_UNSET));
    }
}

Ifc2DCompositeCurve *ExpressDataSet::cloneIfc2DCompositeCurve(ExpressDataSet *expressDataSet, const Ifc2DCompositeCurve &obj, const CopyOp &copyop)
{
    Ifc2DCompositeCurve *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new Ifc2DCompositeCurve(id, 0);
    ret->setKey(id);
    expressDataSet->m_Ifc2DCompositeCurve_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

Ifc2DCompositeCurve *ExpressDataSet::cloneIfc2DCompositeCurve(const Ifc2DCompositeCurve &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfc2DCompositeCurve(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfc2DCompositeCurve(this, obj, copyop);
    }
}


Step::RefLinkedList< Ifc2DCompositeCurve  > &ExpressDataSet::getAllIfc2DCompositeCurve ()
{
    return m_refIfc2DCompositeCurveList;
}



IfcActionRequest *ExpressDataSet::getIfcActionRequest(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcActionRequest * > (current->second.get());
    }
    else
    {
        IfcActionRequest *ret = static_cast< IfcActionRequest * > (allocateIfcActionRequest(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcActionRequest(IfcActionRequest *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcActionRequest_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcActionRequest(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcActionRequest *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcActionRequest(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcActionRequest_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcActionRequest > ExpressDataSet::createIfcActionRequest(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcActionRequest(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcActionRequest * > (allocateIfcActionRequest(this, Step::Id_UNSET));
    }
}

IfcActionRequest *ExpressDataSet::cloneIfcActionRequest(ExpressDataSet *expressDataSet, const IfcActionRequest &obj, const CopyOp &copyop)
{
    IfcActionRequest *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcActionRequest(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcActionRequest_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcActionRequest *ExpressDataSet::cloneIfcActionRequest(const IfcActionRequest &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcActionRequest(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcActionRequest(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcActionRequest  > &ExpressDataSet::getAllIfcActionRequest ()
{
    return m_refIfcActionRequestList;
}



IfcActor *ExpressDataSet::getIfcActor(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcActor * > (current->second.get());
    }
    else
    {
        IfcActor *ret = static_cast< IfcActor * > (allocateIfcActor(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcActor(IfcActor *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcActor_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcActor(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcActor *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcActor(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcActor_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcActor > ExpressDataSet::createIfcActor(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcActor(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcActor * > (allocateIfcActor(this, Step::Id_UNSET));
    }
}

IfcActor *ExpressDataSet::cloneIfcActor(ExpressDataSet *expressDataSet, const IfcActor &obj, const CopyOp &copyop)
{
    IfcActor *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcActor(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcActor_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcActor *ExpressDataSet::cloneIfcActor(const IfcActor &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcActor(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcActor(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcActor  > &ExpressDataSet::getAllIfcActor ()
{
    return m_refIfcActorList;
}



IfcActorRole *ExpressDataSet::getIfcActorRole(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcActorRole * > (current->second.get());
    }
    else
    {
        IfcActorRole *ret = static_cast< IfcActorRole * > (allocateIfcActorRole(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcActorRole(IfcActorRole *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcActorRole_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcActorRole(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcActorRole *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcActorRole(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcActorRole_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcActorRole > ExpressDataSet::createIfcActorRole(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcActorRole(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcActorRole * > (allocateIfcActorRole(this, Step::Id_UNSET));
    }
}

IfcActorRole *ExpressDataSet::cloneIfcActorRole(ExpressDataSet *expressDataSet, const IfcActorRole &obj, const CopyOp &copyop)
{
    IfcActorRole *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcActorRole(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcActorRole_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcActorRole *ExpressDataSet::cloneIfcActorRole(const IfcActorRole &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcActorRole(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcActorRole(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcActorRole  > &ExpressDataSet::getAllIfcActorRole ()
{
    return m_refIfcActorRoleList;
}



IfcActuatorType *ExpressDataSet::getIfcActuatorType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcActuatorType * > (current->second.get());
    }
    else
    {
        IfcActuatorType *ret = static_cast< IfcActuatorType * > (allocateIfcActuatorType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcActuatorType(IfcActuatorType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcActuatorType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcActuatorType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcActuatorType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcActuatorType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcActuatorType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcActuatorType > ExpressDataSet::createIfcActuatorType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcActuatorType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcActuatorType * > (allocateIfcActuatorType(this, Step::Id_UNSET));
    }
}

IfcActuatorType *ExpressDataSet::cloneIfcActuatorType(ExpressDataSet *expressDataSet, const IfcActuatorType &obj, const CopyOp &copyop)
{
    IfcActuatorType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcActuatorType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcActuatorType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcActuatorType *ExpressDataSet::cloneIfcActuatorType(const IfcActuatorType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcActuatorType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcActuatorType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcActuatorType  > &ExpressDataSet::getAllIfcActuatorType ()
{
    return m_refIfcActuatorTypeList;
}



IfcAddress *ExpressDataSet::getIfcAddress(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcAddress * > (current->second.get());
    }
    else
    {
        IfcAddress *ret = static_cast< IfcAddress * > (allocateIfcAddress(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcAddress(IfcAddress *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcAddress_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAddress(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcAddress *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAddress(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAddress_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAddress > ExpressDataSet::createIfcAddress(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcAddress(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcAddress * > (allocateIfcAddress(this, Step::Id_UNSET));
    }
}

IfcAddress *ExpressDataSet::cloneIfcAddress(ExpressDataSet *expressDataSet, const IfcAddress &obj, const CopyOp &copyop)
{
    IfcAddress *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAddress(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAddress_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAddress *ExpressDataSet::cloneIfcAddress(const IfcAddress &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcAddress(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcAddress(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcAddress  > &ExpressDataSet::getAllIfcAddress ()
{
    return m_refIfcAddressList;
}



IfcAirTerminalBoxType *ExpressDataSet::getIfcAirTerminalBoxType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcAirTerminalBoxType * > (current->second.get());
    }
    else
    {
        IfcAirTerminalBoxType *ret = static_cast< IfcAirTerminalBoxType * > (allocateIfcAirTerminalBoxType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcAirTerminalBoxType(IfcAirTerminalBoxType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcAirTerminalBoxType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAirTerminalBoxType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcAirTerminalBoxType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAirTerminalBoxType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAirTerminalBoxType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAirTerminalBoxType > ExpressDataSet::createIfcAirTerminalBoxType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcAirTerminalBoxType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcAirTerminalBoxType * > (allocateIfcAirTerminalBoxType(this, Step::Id_UNSET));
    }
}

IfcAirTerminalBoxType *ExpressDataSet::cloneIfcAirTerminalBoxType(ExpressDataSet *expressDataSet, const IfcAirTerminalBoxType &obj, const CopyOp &copyop)
{
    IfcAirTerminalBoxType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAirTerminalBoxType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAirTerminalBoxType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAirTerminalBoxType *ExpressDataSet::cloneIfcAirTerminalBoxType(const IfcAirTerminalBoxType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcAirTerminalBoxType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcAirTerminalBoxType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcAirTerminalBoxType  > &ExpressDataSet::getAllIfcAirTerminalBoxType ()
{
    return m_refIfcAirTerminalBoxTypeList;
}



IfcAirTerminalType *ExpressDataSet::getIfcAirTerminalType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcAirTerminalType * > (current->second.get());
    }
    else
    {
        IfcAirTerminalType *ret = static_cast< IfcAirTerminalType * > (allocateIfcAirTerminalType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcAirTerminalType(IfcAirTerminalType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcAirTerminalType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAirTerminalType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcAirTerminalType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAirTerminalType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAirTerminalType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAirTerminalType > ExpressDataSet::createIfcAirTerminalType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcAirTerminalType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcAirTerminalType * > (allocateIfcAirTerminalType(this, Step::Id_UNSET));
    }
}

IfcAirTerminalType *ExpressDataSet::cloneIfcAirTerminalType(ExpressDataSet *expressDataSet, const IfcAirTerminalType &obj, const CopyOp &copyop)
{
    IfcAirTerminalType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAirTerminalType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAirTerminalType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAirTerminalType *ExpressDataSet::cloneIfcAirTerminalType(const IfcAirTerminalType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcAirTerminalType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcAirTerminalType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcAirTerminalType  > &ExpressDataSet::getAllIfcAirTerminalType ()
{
    return m_refIfcAirTerminalTypeList;
}



IfcAirToAirHeatRecoveryType *ExpressDataSet::getIfcAirToAirHeatRecoveryType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcAirToAirHeatRecoveryType * > (current->second.get());
    }
    else
    {
        IfcAirToAirHeatRecoveryType *ret = static_cast< IfcAirToAirHeatRecoveryType * > (allocateIfcAirToAirHeatRecoveryType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcAirToAirHeatRecoveryType(IfcAirToAirHeatRecoveryType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcAirToAirHeatRecoveryType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAirToAirHeatRecoveryType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcAirToAirHeatRecoveryType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAirToAirHeatRecoveryType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAirToAirHeatRecoveryType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAirToAirHeatRecoveryType > ExpressDataSet::createIfcAirToAirHeatRecoveryType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcAirToAirHeatRecoveryType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcAirToAirHeatRecoveryType * > (allocateIfcAirToAirHeatRecoveryType(this, Step::Id_UNSET));
    }
}

IfcAirToAirHeatRecoveryType *ExpressDataSet::cloneIfcAirToAirHeatRecoveryType(ExpressDataSet *expressDataSet, const IfcAirToAirHeatRecoveryType &obj, const CopyOp &copyop)
{
    IfcAirToAirHeatRecoveryType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAirToAirHeatRecoveryType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAirToAirHeatRecoveryType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAirToAirHeatRecoveryType *ExpressDataSet::cloneIfcAirToAirHeatRecoveryType(const IfcAirToAirHeatRecoveryType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcAirToAirHeatRecoveryType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcAirToAirHeatRecoveryType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcAirToAirHeatRecoveryType  > &ExpressDataSet::getAllIfcAirToAirHeatRecoveryType ()
{
    return m_refIfcAirToAirHeatRecoveryTypeList;
}



IfcAlarmType *ExpressDataSet::getIfcAlarmType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcAlarmType * > (current->second.get());
    }
    else
    {
        IfcAlarmType *ret = static_cast< IfcAlarmType * > (allocateIfcAlarmType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcAlarmType(IfcAlarmType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcAlarmType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAlarmType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcAlarmType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAlarmType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAlarmType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAlarmType > ExpressDataSet::createIfcAlarmType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcAlarmType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcAlarmType * > (allocateIfcAlarmType(this, Step::Id_UNSET));
    }
}

IfcAlarmType *ExpressDataSet::cloneIfcAlarmType(ExpressDataSet *expressDataSet, const IfcAlarmType &obj, const CopyOp &copyop)
{
    IfcAlarmType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAlarmType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAlarmType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAlarmType *ExpressDataSet::cloneIfcAlarmType(const IfcAlarmType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcAlarmType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcAlarmType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcAlarmType  > &ExpressDataSet::getAllIfcAlarmType ()
{
    return m_refIfcAlarmTypeList;
}



IfcAngularDimension *ExpressDataSet::getIfcAngularDimension(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcAngularDimension * > (current->second.get());
    }
    else
    {
        IfcAngularDimension *ret = static_cast< IfcAngularDimension * > (allocateIfcAngularDimension(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcAngularDimension(IfcAngularDimension *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcAngularDimension_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAngularDimension(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcAngularDimension *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAngularDimension(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAngularDimension_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAngularDimension > ExpressDataSet::createIfcAngularDimension(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcAngularDimension(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcAngularDimension * > (allocateIfcAngularDimension(this, Step::Id_UNSET));
    }
}

IfcAngularDimension *ExpressDataSet::cloneIfcAngularDimension(ExpressDataSet *expressDataSet, const IfcAngularDimension &obj, const CopyOp &copyop)
{
    IfcAngularDimension *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAngularDimension(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAngularDimension_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAngularDimension *ExpressDataSet::cloneIfcAngularDimension(const IfcAngularDimension &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcAngularDimension(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcAngularDimension(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcAngularDimension  > &ExpressDataSet::getAllIfcAngularDimension ()
{
    return m_refIfcAngularDimensionList;
}



IfcAnnotation *ExpressDataSet::getIfcAnnotation(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcAnnotation * > (current->second.get());
    }
    else
    {
        IfcAnnotation *ret = static_cast< IfcAnnotation * > (allocateIfcAnnotation(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcAnnotation(IfcAnnotation *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcAnnotation_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAnnotation(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcAnnotation *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAnnotation(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAnnotation_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAnnotation > ExpressDataSet::createIfcAnnotation(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcAnnotation(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcAnnotation * > (allocateIfcAnnotation(this, Step::Id_UNSET));
    }
}

IfcAnnotation *ExpressDataSet::cloneIfcAnnotation(ExpressDataSet *expressDataSet, const IfcAnnotation &obj, const CopyOp &copyop)
{
    IfcAnnotation *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAnnotation(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAnnotation_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAnnotation *ExpressDataSet::cloneIfcAnnotation(const IfcAnnotation &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcAnnotation(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcAnnotation(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcAnnotation  > &ExpressDataSet::getAllIfcAnnotation ()
{
    return m_refIfcAnnotationList;
}



IfcAnnotationCurveOccurrence *ExpressDataSet::getIfcAnnotationCurveOccurrence(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcAnnotationCurveOccurrence * > (current->second.get());
    }
    else
    {
        IfcAnnotationCurveOccurrence *ret = static_cast< IfcAnnotationCurveOccurrence * > (allocateIfcAnnotationCurveOccurrence(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcAnnotationCurveOccurrence(IfcAnnotationCurveOccurrence *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcAnnotationCurveOccurrence_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAnnotationCurveOccurrence(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcAnnotationCurveOccurrence *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAnnotationCurveOccurrence(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAnnotationCurveOccurrence_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAnnotationCurveOccurrence > ExpressDataSet::createIfcAnnotationCurveOccurrence(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcAnnotationCurveOccurrence(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcAnnotationCurveOccurrence * > (allocateIfcAnnotationCurveOccurrence(this, Step::Id_UNSET));
    }
}

IfcAnnotationCurveOccurrence *ExpressDataSet::cloneIfcAnnotationCurveOccurrence(ExpressDataSet *expressDataSet, const IfcAnnotationCurveOccurrence &obj, const CopyOp &copyop)
{
    IfcAnnotationCurveOccurrence *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAnnotationCurveOccurrence(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAnnotationCurveOccurrence_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAnnotationCurveOccurrence *ExpressDataSet::cloneIfcAnnotationCurveOccurrence(const IfcAnnotationCurveOccurrence &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcAnnotationCurveOccurrence(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcAnnotationCurveOccurrence(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcAnnotationCurveOccurrence  > &ExpressDataSet::getAllIfcAnnotationCurveOccurrence ()
{
    return m_refIfcAnnotationCurveOccurrenceList;
}



IfcAnnotationFillArea *ExpressDataSet::getIfcAnnotationFillArea(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcAnnotationFillArea * > (current->second.get());
    }
    else
    {
        IfcAnnotationFillArea *ret = static_cast< IfcAnnotationFillArea * > (allocateIfcAnnotationFillArea(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcAnnotationFillArea(IfcAnnotationFillArea *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcAnnotationFillArea_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAnnotationFillArea(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcAnnotationFillArea *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAnnotationFillArea(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAnnotationFillArea_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAnnotationFillArea > ExpressDataSet::createIfcAnnotationFillArea(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcAnnotationFillArea(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcAnnotationFillArea * > (allocateIfcAnnotationFillArea(this, Step::Id_UNSET));
    }
}

IfcAnnotationFillArea *ExpressDataSet::cloneIfcAnnotationFillArea(ExpressDataSet *expressDataSet, const IfcAnnotationFillArea &obj, const CopyOp &copyop)
{
    IfcAnnotationFillArea *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAnnotationFillArea(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAnnotationFillArea_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAnnotationFillArea *ExpressDataSet::cloneIfcAnnotationFillArea(const IfcAnnotationFillArea &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcAnnotationFillArea(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcAnnotationFillArea(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcAnnotationFillArea  > &ExpressDataSet::getAllIfcAnnotationFillArea ()
{
    return m_refIfcAnnotationFillAreaList;
}



IfcAnnotationFillAreaOccurrence *ExpressDataSet::getIfcAnnotationFillAreaOccurrence(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcAnnotationFillAreaOccurrence * > (current->second.get());
    }
    else
    {
        IfcAnnotationFillAreaOccurrence *ret = static_cast< IfcAnnotationFillAreaOccurrence * > (allocateIfcAnnotationFillAreaOccurrence(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcAnnotationFillAreaOccurrence(IfcAnnotationFillAreaOccurrence *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcAnnotationFillAreaOccurrence_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAnnotationFillAreaOccurrence(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcAnnotationFillAreaOccurrence *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAnnotationFillAreaOccurrence(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAnnotationFillAreaOccurrence_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAnnotationFillAreaOccurrence > ExpressDataSet::createIfcAnnotationFillAreaOccurrence(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcAnnotationFillAreaOccurrence(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcAnnotationFillAreaOccurrence * > (allocateIfcAnnotationFillAreaOccurrence(this, Step::Id_UNSET));
    }
}

IfcAnnotationFillAreaOccurrence *ExpressDataSet::cloneIfcAnnotationFillAreaOccurrence(ExpressDataSet *expressDataSet, const IfcAnnotationFillAreaOccurrence &obj, const CopyOp &copyop)
{
    IfcAnnotationFillAreaOccurrence *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAnnotationFillAreaOccurrence(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAnnotationFillAreaOccurrence_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAnnotationFillAreaOccurrence *ExpressDataSet::cloneIfcAnnotationFillAreaOccurrence(const IfcAnnotationFillAreaOccurrence &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcAnnotationFillAreaOccurrence(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcAnnotationFillAreaOccurrence(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcAnnotationFillAreaOccurrence  > &ExpressDataSet::getAllIfcAnnotationFillAreaOccurrence ()
{
    return m_refIfcAnnotationFillAreaOccurrenceList;
}



IfcAnnotationOccurrence *ExpressDataSet::getIfcAnnotationOccurrence(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcAnnotationOccurrence * > (current->second.get());
    }
    else
    {
        IfcAnnotationOccurrence *ret = static_cast< IfcAnnotationOccurrence * > (allocateIfcAnnotationOccurrence(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcAnnotationOccurrence(IfcAnnotationOccurrence *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcAnnotationOccurrence_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAnnotationOccurrence(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcAnnotationOccurrence *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAnnotationOccurrence(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAnnotationOccurrence_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAnnotationOccurrence > ExpressDataSet::createIfcAnnotationOccurrence(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcAnnotationOccurrence(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcAnnotationOccurrence * > (allocateIfcAnnotationOccurrence(this, Step::Id_UNSET));
    }
}

IfcAnnotationOccurrence *ExpressDataSet::cloneIfcAnnotationOccurrence(ExpressDataSet *expressDataSet, const IfcAnnotationOccurrence &obj, const CopyOp &copyop)
{
    IfcAnnotationOccurrence *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAnnotationOccurrence(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAnnotationOccurrence_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAnnotationOccurrence *ExpressDataSet::cloneIfcAnnotationOccurrence(const IfcAnnotationOccurrence &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcAnnotationOccurrence(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcAnnotationOccurrence(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcAnnotationOccurrence  > &ExpressDataSet::getAllIfcAnnotationOccurrence ()
{
    return m_refIfcAnnotationOccurrenceList;
}



IfcAnnotationSurface *ExpressDataSet::getIfcAnnotationSurface(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcAnnotationSurface * > (current->second.get());
    }
    else
    {
        IfcAnnotationSurface *ret = static_cast< IfcAnnotationSurface * > (allocateIfcAnnotationSurface(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcAnnotationSurface(IfcAnnotationSurface *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcAnnotationSurface_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAnnotationSurface(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcAnnotationSurface *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAnnotationSurface(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAnnotationSurface_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAnnotationSurface > ExpressDataSet::createIfcAnnotationSurface(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcAnnotationSurface(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcAnnotationSurface * > (allocateIfcAnnotationSurface(this, Step::Id_UNSET));
    }
}

IfcAnnotationSurface *ExpressDataSet::cloneIfcAnnotationSurface(ExpressDataSet *expressDataSet, const IfcAnnotationSurface &obj, const CopyOp &copyop)
{
    IfcAnnotationSurface *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAnnotationSurface(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAnnotationSurface_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAnnotationSurface *ExpressDataSet::cloneIfcAnnotationSurface(const IfcAnnotationSurface &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcAnnotationSurface(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcAnnotationSurface(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcAnnotationSurface  > &ExpressDataSet::getAllIfcAnnotationSurface ()
{
    return m_refIfcAnnotationSurfaceList;
}



IfcAnnotationSurfaceOccurrence *ExpressDataSet::getIfcAnnotationSurfaceOccurrence(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcAnnotationSurfaceOccurrence * > (current->second.get());
    }
    else
    {
        IfcAnnotationSurfaceOccurrence *ret = static_cast< IfcAnnotationSurfaceOccurrence * > (allocateIfcAnnotationSurfaceOccurrence(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcAnnotationSurfaceOccurrence(IfcAnnotationSurfaceOccurrence *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcAnnotationSurfaceOccurrence_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAnnotationSurfaceOccurrence(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcAnnotationSurfaceOccurrence *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAnnotationSurfaceOccurrence(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAnnotationSurfaceOccurrence_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAnnotationSurfaceOccurrence > ExpressDataSet::createIfcAnnotationSurfaceOccurrence(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcAnnotationSurfaceOccurrence(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcAnnotationSurfaceOccurrence * > (allocateIfcAnnotationSurfaceOccurrence(this, Step::Id_UNSET));
    }
}

IfcAnnotationSurfaceOccurrence *ExpressDataSet::cloneIfcAnnotationSurfaceOccurrence(ExpressDataSet *expressDataSet, const IfcAnnotationSurfaceOccurrence &obj, const CopyOp &copyop)
{
    IfcAnnotationSurfaceOccurrence *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAnnotationSurfaceOccurrence(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAnnotationSurfaceOccurrence_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAnnotationSurfaceOccurrence *ExpressDataSet::cloneIfcAnnotationSurfaceOccurrence(const IfcAnnotationSurfaceOccurrence &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcAnnotationSurfaceOccurrence(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcAnnotationSurfaceOccurrence(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcAnnotationSurfaceOccurrence  > &ExpressDataSet::getAllIfcAnnotationSurfaceOccurrence ()
{
    return m_refIfcAnnotationSurfaceOccurrenceList;
}



IfcAnnotationSymbolOccurrence *ExpressDataSet::getIfcAnnotationSymbolOccurrence(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcAnnotationSymbolOccurrence * > (current->second.get());
    }
    else
    {
        IfcAnnotationSymbolOccurrence *ret = static_cast< IfcAnnotationSymbolOccurrence * > (allocateIfcAnnotationSymbolOccurrence(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcAnnotationSymbolOccurrence(IfcAnnotationSymbolOccurrence *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcAnnotationSymbolOccurrence_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAnnotationSymbolOccurrence(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcAnnotationSymbolOccurrence *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAnnotationSymbolOccurrence(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAnnotationSymbolOccurrence_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAnnotationSymbolOccurrence > ExpressDataSet::createIfcAnnotationSymbolOccurrence(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcAnnotationSymbolOccurrence(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcAnnotationSymbolOccurrence * > (allocateIfcAnnotationSymbolOccurrence(this, Step::Id_UNSET));
    }
}

IfcAnnotationSymbolOccurrence *ExpressDataSet::cloneIfcAnnotationSymbolOccurrence(ExpressDataSet *expressDataSet, const IfcAnnotationSymbolOccurrence &obj, const CopyOp &copyop)
{
    IfcAnnotationSymbolOccurrence *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAnnotationSymbolOccurrence(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAnnotationSymbolOccurrence_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAnnotationSymbolOccurrence *ExpressDataSet::cloneIfcAnnotationSymbolOccurrence(const IfcAnnotationSymbolOccurrence &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcAnnotationSymbolOccurrence(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcAnnotationSymbolOccurrence(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcAnnotationSymbolOccurrence  > &ExpressDataSet::getAllIfcAnnotationSymbolOccurrence ()
{
    return m_refIfcAnnotationSymbolOccurrenceList;
}



IfcAnnotationTextOccurrence *ExpressDataSet::getIfcAnnotationTextOccurrence(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcAnnotationTextOccurrence * > (current->second.get());
    }
    else
    {
        IfcAnnotationTextOccurrence *ret = static_cast< IfcAnnotationTextOccurrence * > (allocateIfcAnnotationTextOccurrence(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcAnnotationTextOccurrence(IfcAnnotationTextOccurrence *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcAnnotationTextOccurrence_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAnnotationTextOccurrence(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcAnnotationTextOccurrence *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAnnotationTextOccurrence(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAnnotationTextOccurrence_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAnnotationTextOccurrence > ExpressDataSet::createIfcAnnotationTextOccurrence(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcAnnotationTextOccurrence(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcAnnotationTextOccurrence * > (allocateIfcAnnotationTextOccurrence(this, Step::Id_UNSET));
    }
}

IfcAnnotationTextOccurrence *ExpressDataSet::cloneIfcAnnotationTextOccurrence(ExpressDataSet *expressDataSet, const IfcAnnotationTextOccurrence &obj, const CopyOp &copyop)
{
    IfcAnnotationTextOccurrence *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAnnotationTextOccurrence(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAnnotationTextOccurrence_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAnnotationTextOccurrence *ExpressDataSet::cloneIfcAnnotationTextOccurrence(const IfcAnnotationTextOccurrence &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcAnnotationTextOccurrence(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcAnnotationTextOccurrence(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcAnnotationTextOccurrence  > &ExpressDataSet::getAllIfcAnnotationTextOccurrence ()
{
    return m_refIfcAnnotationTextOccurrenceList;
}



IfcApplication *ExpressDataSet::getIfcApplication(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcApplication * > (current->second.get());
    }
    else
    {
        IfcApplication *ret = static_cast< IfcApplication * > (allocateIfcApplication(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcApplication(IfcApplication *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcApplication_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcApplication(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcApplication *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcApplication(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcApplication_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcApplication > ExpressDataSet::createIfcApplication(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcApplication(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcApplication * > (allocateIfcApplication(this, Step::Id_UNSET));
    }
}

IfcApplication *ExpressDataSet::cloneIfcApplication(ExpressDataSet *expressDataSet, const IfcApplication &obj, const CopyOp &copyop)
{
    IfcApplication *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcApplication(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcApplication_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcApplication *ExpressDataSet::cloneIfcApplication(const IfcApplication &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcApplication(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcApplication(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcApplication  > &ExpressDataSet::getAllIfcApplication ()
{
    return m_refIfcApplicationList;
}



IfcAppliedValue *ExpressDataSet::getIfcAppliedValue(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcAppliedValue * > (current->second.get());
    }
    else
    {
        IfcAppliedValue *ret = static_cast< IfcAppliedValue * > (allocateIfcAppliedValue(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcAppliedValue(IfcAppliedValue *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcAppliedValue_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAppliedValue(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcAppliedValue *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAppliedValue(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAppliedValue_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAppliedValue > ExpressDataSet::createIfcAppliedValue(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcAppliedValue(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcAppliedValue * > (allocateIfcAppliedValue(this, Step::Id_UNSET));
    }
}

IfcAppliedValue *ExpressDataSet::cloneIfcAppliedValue(ExpressDataSet *expressDataSet, const IfcAppliedValue &obj, const CopyOp &copyop)
{
    IfcAppliedValue *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAppliedValue(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAppliedValue_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAppliedValue *ExpressDataSet::cloneIfcAppliedValue(const IfcAppliedValue &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcAppliedValue(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcAppliedValue(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcAppliedValue  > &ExpressDataSet::getAllIfcAppliedValue ()
{
    return m_refIfcAppliedValueList;
}



IfcAppliedValueRelationship *ExpressDataSet::getIfcAppliedValueRelationship(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcAppliedValueRelationship * > (current->second.get());
    }
    else
    {
        IfcAppliedValueRelationship *ret = static_cast< IfcAppliedValueRelationship * > (allocateIfcAppliedValueRelationship(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcAppliedValueRelationship(IfcAppliedValueRelationship *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcAppliedValueRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAppliedValueRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcAppliedValueRelationship *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAppliedValueRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAppliedValueRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAppliedValueRelationship > ExpressDataSet::createIfcAppliedValueRelationship(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcAppliedValueRelationship(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcAppliedValueRelationship * > (allocateIfcAppliedValueRelationship(this, Step::Id_UNSET));
    }
}

IfcAppliedValueRelationship *ExpressDataSet::cloneIfcAppliedValueRelationship(ExpressDataSet *expressDataSet, const IfcAppliedValueRelationship &obj, const CopyOp &copyop)
{
    IfcAppliedValueRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAppliedValueRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAppliedValueRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAppliedValueRelationship *ExpressDataSet::cloneIfcAppliedValueRelationship(const IfcAppliedValueRelationship &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcAppliedValueRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcAppliedValueRelationship(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcAppliedValueRelationship  > &ExpressDataSet::getAllIfcAppliedValueRelationship ()
{
    return m_refIfcAppliedValueRelationshipList;
}



IfcApproval *ExpressDataSet::getIfcApproval(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcApproval * > (current->second.get());
    }
    else
    {
        IfcApproval *ret = static_cast< IfcApproval * > (allocateIfcApproval(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcApproval(IfcApproval *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcApproval_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcApproval(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcApproval *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcApproval(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcApproval_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcApproval > ExpressDataSet::createIfcApproval(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcApproval(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcApproval * > (allocateIfcApproval(this, Step::Id_UNSET));
    }
}

IfcApproval *ExpressDataSet::cloneIfcApproval(ExpressDataSet *expressDataSet, const IfcApproval &obj, const CopyOp &copyop)
{
    IfcApproval *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcApproval(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcApproval_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcApproval *ExpressDataSet::cloneIfcApproval(const IfcApproval &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcApproval(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcApproval(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcApproval  > &ExpressDataSet::getAllIfcApproval ()
{
    return m_refIfcApprovalList;
}



IfcApprovalActorRelationship *ExpressDataSet::getIfcApprovalActorRelationship(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcApprovalActorRelationship * > (current->second.get());
    }
    else
    {
        IfcApprovalActorRelationship *ret = static_cast< IfcApprovalActorRelationship * > (allocateIfcApprovalActorRelationship(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcApprovalActorRelationship(IfcApprovalActorRelationship *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcApprovalActorRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcApprovalActorRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcApprovalActorRelationship *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcApprovalActorRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcApprovalActorRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcApprovalActorRelationship > ExpressDataSet::createIfcApprovalActorRelationship(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcApprovalActorRelationship(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcApprovalActorRelationship * > (allocateIfcApprovalActorRelationship(this, Step::Id_UNSET));
    }
}

IfcApprovalActorRelationship *ExpressDataSet::cloneIfcApprovalActorRelationship(ExpressDataSet *expressDataSet, const IfcApprovalActorRelationship &obj, const CopyOp &copyop)
{
    IfcApprovalActorRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcApprovalActorRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcApprovalActorRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcApprovalActorRelationship *ExpressDataSet::cloneIfcApprovalActorRelationship(const IfcApprovalActorRelationship &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcApprovalActorRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcApprovalActorRelationship(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcApprovalActorRelationship  > &ExpressDataSet::getAllIfcApprovalActorRelationship ()
{
    return m_refIfcApprovalActorRelationshipList;
}



IfcApprovalPropertyRelationship *ExpressDataSet::getIfcApprovalPropertyRelationship(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcApprovalPropertyRelationship * > (current->second.get());
    }
    else
    {
        IfcApprovalPropertyRelationship *ret = static_cast< IfcApprovalPropertyRelationship * > (allocateIfcApprovalPropertyRelationship(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcApprovalPropertyRelationship(IfcApprovalPropertyRelationship *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcApprovalPropertyRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcApprovalPropertyRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcApprovalPropertyRelationship *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcApprovalPropertyRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcApprovalPropertyRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcApprovalPropertyRelationship > ExpressDataSet::createIfcApprovalPropertyRelationship(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcApprovalPropertyRelationship(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcApprovalPropertyRelationship * > (allocateIfcApprovalPropertyRelationship(this, Step::Id_UNSET));
    }
}

IfcApprovalPropertyRelationship *ExpressDataSet::cloneIfcApprovalPropertyRelationship(ExpressDataSet *expressDataSet, const IfcApprovalPropertyRelationship &obj, const CopyOp &copyop)
{
    IfcApprovalPropertyRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcApprovalPropertyRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcApprovalPropertyRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcApprovalPropertyRelationship *ExpressDataSet::cloneIfcApprovalPropertyRelationship(const IfcApprovalPropertyRelationship &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcApprovalPropertyRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcApprovalPropertyRelationship(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcApprovalPropertyRelationship  > &ExpressDataSet::getAllIfcApprovalPropertyRelationship ()
{
    return m_refIfcApprovalPropertyRelationshipList;
}



IfcApprovalRelationship *ExpressDataSet::getIfcApprovalRelationship(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcApprovalRelationship * > (current->second.get());
    }
    else
    {
        IfcApprovalRelationship *ret = static_cast< IfcApprovalRelationship * > (allocateIfcApprovalRelationship(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcApprovalRelationship(IfcApprovalRelationship *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcApprovalRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcApprovalRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcApprovalRelationship *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcApprovalRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcApprovalRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcApprovalRelationship > ExpressDataSet::createIfcApprovalRelationship(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcApprovalRelationship(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcApprovalRelationship * > (allocateIfcApprovalRelationship(this, Step::Id_UNSET));
    }
}

IfcApprovalRelationship *ExpressDataSet::cloneIfcApprovalRelationship(ExpressDataSet *expressDataSet, const IfcApprovalRelationship &obj, const CopyOp &copyop)
{
    IfcApprovalRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcApprovalRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcApprovalRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcApprovalRelationship *ExpressDataSet::cloneIfcApprovalRelationship(const IfcApprovalRelationship &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcApprovalRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcApprovalRelationship(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcApprovalRelationship  > &ExpressDataSet::getAllIfcApprovalRelationship ()
{
    return m_refIfcApprovalRelationshipList;
}



IfcArbitraryClosedProfileDef *ExpressDataSet::getIfcArbitraryClosedProfileDef(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcArbitraryClosedProfileDef * > (current->second.get());
    }
    else
    {
        IfcArbitraryClosedProfileDef *ret = static_cast< IfcArbitraryClosedProfileDef * > (allocateIfcArbitraryClosedProfileDef(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcArbitraryClosedProfileDef(IfcArbitraryClosedProfileDef *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcArbitraryClosedProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcArbitraryClosedProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcArbitraryClosedProfileDef *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcArbitraryClosedProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcArbitraryClosedProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcArbitraryClosedProfileDef > ExpressDataSet::createIfcArbitraryClosedProfileDef(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcArbitraryClosedProfileDef(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcArbitraryClosedProfileDef * > (allocateIfcArbitraryClosedProfileDef(this, Step::Id_UNSET));
    }
}

IfcArbitraryClosedProfileDef *ExpressDataSet::cloneIfcArbitraryClosedProfileDef(ExpressDataSet *expressDataSet, const IfcArbitraryClosedProfileDef &obj, const CopyOp &copyop)
{
    IfcArbitraryClosedProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcArbitraryClosedProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcArbitraryClosedProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcArbitraryClosedProfileDef *ExpressDataSet::cloneIfcArbitraryClosedProfileDef(const IfcArbitraryClosedProfileDef &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcArbitraryClosedProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcArbitraryClosedProfileDef(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcArbitraryClosedProfileDef  > &ExpressDataSet::getAllIfcArbitraryClosedProfileDef ()
{
    return m_refIfcArbitraryClosedProfileDefList;
}



IfcArbitraryOpenProfileDef *ExpressDataSet::getIfcArbitraryOpenProfileDef(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcArbitraryOpenProfileDef * > (current->second.get());
    }
    else
    {
        IfcArbitraryOpenProfileDef *ret = static_cast< IfcArbitraryOpenProfileDef * > (allocateIfcArbitraryOpenProfileDef(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcArbitraryOpenProfileDef(IfcArbitraryOpenProfileDef *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcArbitraryOpenProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcArbitraryOpenProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcArbitraryOpenProfileDef *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcArbitraryOpenProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcArbitraryOpenProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcArbitraryOpenProfileDef > ExpressDataSet::createIfcArbitraryOpenProfileDef(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcArbitraryOpenProfileDef(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcArbitraryOpenProfileDef * > (allocateIfcArbitraryOpenProfileDef(this, Step::Id_UNSET));
    }
}

IfcArbitraryOpenProfileDef *ExpressDataSet::cloneIfcArbitraryOpenProfileDef(ExpressDataSet *expressDataSet, const IfcArbitraryOpenProfileDef &obj, const CopyOp &copyop)
{
    IfcArbitraryOpenProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcArbitraryOpenProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcArbitraryOpenProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcArbitraryOpenProfileDef *ExpressDataSet::cloneIfcArbitraryOpenProfileDef(const IfcArbitraryOpenProfileDef &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcArbitraryOpenProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcArbitraryOpenProfileDef(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcArbitraryOpenProfileDef  > &ExpressDataSet::getAllIfcArbitraryOpenProfileDef ()
{
    return m_refIfcArbitraryOpenProfileDefList;
}



IfcArbitraryProfileDefWithVoids *ExpressDataSet::getIfcArbitraryProfileDefWithVoids(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcArbitraryProfileDefWithVoids * > (current->second.get());
    }
    else
    {
        IfcArbitraryProfileDefWithVoids *ret = static_cast< IfcArbitraryProfileDefWithVoids * > (allocateIfcArbitraryProfileDefWithVoids(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcArbitraryProfileDefWithVoids(IfcArbitraryProfileDefWithVoids *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcArbitraryProfileDefWithVoids_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcArbitraryProfileDefWithVoids(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcArbitraryProfileDefWithVoids *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcArbitraryProfileDefWithVoids(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcArbitraryProfileDefWithVoids_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcArbitraryProfileDefWithVoids > ExpressDataSet::createIfcArbitraryProfileDefWithVoids(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcArbitraryProfileDefWithVoids(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcArbitraryProfileDefWithVoids * > (allocateIfcArbitraryProfileDefWithVoids(this, Step::Id_UNSET));
    }
}

IfcArbitraryProfileDefWithVoids *ExpressDataSet::cloneIfcArbitraryProfileDefWithVoids(ExpressDataSet *expressDataSet, const IfcArbitraryProfileDefWithVoids &obj, const CopyOp &copyop)
{
    IfcArbitraryProfileDefWithVoids *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcArbitraryProfileDefWithVoids(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcArbitraryProfileDefWithVoids_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcArbitraryProfileDefWithVoids *ExpressDataSet::cloneIfcArbitraryProfileDefWithVoids(const IfcArbitraryProfileDefWithVoids &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcArbitraryProfileDefWithVoids(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcArbitraryProfileDefWithVoids(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcArbitraryProfileDefWithVoids  > &ExpressDataSet::getAllIfcArbitraryProfileDefWithVoids ()
{
    return m_refIfcArbitraryProfileDefWithVoidsList;
}



IfcAsset *ExpressDataSet::getIfcAsset(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcAsset * > (current->second.get());
    }
    else
    {
        IfcAsset *ret = static_cast< IfcAsset * > (allocateIfcAsset(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcAsset(IfcAsset *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcAsset_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAsset(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcAsset *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAsset(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAsset_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAsset > ExpressDataSet::createIfcAsset(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcAsset(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcAsset * > (allocateIfcAsset(this, Step::Id_UNSET));
    }
}

IfcAsset *ExpressDataSet::cloneIfcAsset(ExpressDataSet *expressDataSet, const IfcAsset &obj, const CopyOp &copyop)
{
    IfcAsset *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAsset(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAsset_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAsset *ExpressDataSet::cloneIfcAsset(const IfcAsset &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcAsset(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcAsset(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcAsset  > &ExpressDataSet::getAllIfcAsset ()
{
    return m_refIfcAssetList;
}



IfcAsymmetricIShapeProfileDef *ExpressDataSet::getIfcAsymmetricIShapeProfileDef(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcAsymmetricIShapeProfileDef * > (current->second.get());
    }
    else
    {
        IfcAsymmetricIShapeProfileDef *ret = static_cast< IfcAsymmetricIShapeProfileDef * > (allocateIfcAsymmetricIShapeProfileDef(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcAsymmetricIShapeProfileDef(IfcAsymmetricIShapeProfileDef *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcAsymmetricIShapeProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAsymmetricIShapeProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcAsymmetricIShapeProfileDef *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAsymmetricIShapeProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAsymmetricIShapeProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAsymmetricIShapeProfileDef > ExpressDataSet::createIfcAsymmetricIShapeProfileDef(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcAsymmetricIShapeProfileDef(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcAsymmetricIShapeProfileDef * > (allocateIfcAsymmetricIShapeProfileDef(this, Step::Id_UNSET));
    }
}

IfcAsymmetricIShapeProfileDef *ExpressDataSet::cloneIfcAsymmetricIShapeProfileDef(ExpressDataSet *expressDataSet, const IfcAsymmetricIShapeProfileDef &obj, const CopyOp &copyop)
{
    IfcAsymmetricIShapeProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAsymmetricIShapeProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAsymmetricIShapeProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAsymmetricIShapeProfileDef *ExpressDataSet::cloneIfcAsymmetricIShapeProfileDef(const IfcAsymmetricIShapeProfileDef &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcAsymmetricIShapeProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcAsymmetricIShapeProfileDef(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcAsymmetricIShapeProfileDef  > &ExpressDataSet::getAllIfcAsymmetricIShapeProfileDef ()
{
    return m_refIfcAsymmetricIShapeProfileDefList;
}



IfcAxis1Placement *ExpressDataSet::getIfcAxis1Placement(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcAxis1Placement * > (current->second.get());
    }
    else
    {
        IfcAxis1Placement *ret = static_cast< IfcAxis1Placement * > (allocateIfcAxis1Placement(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcAxis1Placement(IfcAxis1Placement *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcAxis1Placement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAxis1Placement(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcAxis1Placement *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAxis1Placement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAxis1Placement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAxis1Placement > ExpressDataSet::createIfcAxis1Placement(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcAxis1Placement(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcAxis1Placement * > (allocateIfcAxis1Placement(this, Step::Id_UNSET));
    }
}

IfcAxis1Placement *ExpressDataSet::cloneIfcAxis1Placement(ExpressDataSet *expressDataSet, const IfcAxis1Placement &obj, const CopyOp &copyop)
{
    IfcAxis1Placement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAxis1Placement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAxis1Placement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAxis1Placement *ExpressDataSet::cloneIfcAxis1Placement(const IfcAxis1Placement &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcAxis1Placement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcAxis1Placement(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcAxis1Placement  > &ExpressDataSet::getAllIfcAxis1Placement ()
{
    return m_refIfcAxis1PlacementList;
}



IfcAxis2Placement2D *ExpressDataSet::getIfcAxis2Placement2D(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcAxis2Placement2D * > (current->second.get());
    }
    else
    {
        IfcAxis2Placement2D *ret = static_cast< IfcAxis2Placement2D * > (allocateIfcAxis2Placement2D(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcAxis2Placement2D(IfcAxis2Placement2D *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcAxis2Placement2D_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAxis2Placement2D(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcAxis2Placement2D *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAxis2Placement2D(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAxis2Placement2D_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAxis2Placement2D > ExpressDataSet::createIfcAxis2Placement2D(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcAxis2Placement2D(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcAxis2Placement2D * > (allocateIfcAxis2Placement2D(this, Step::Id_UNSET));
    }
}

IfcAxis2Placement2D *ExpressDataSet::cloneIfcAxis2Placement2D(ExpressDataSet *expressDataSet, const IfcAxis2Placement2D &obj, const CopyOp &copyop)
{
    IfcAxis2Placement2D *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAxis2Placement2D(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAxis2Placement2D_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAxis2Placement2D *ExpressDataSet::cloneIfcAxis2Placement2D(const IfcAxis2Placement2D &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcAxis2Placement2D(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcAxis2Placement2D(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcAxis2Placement2D  > &ExpressDataSet::getAllIfcAxis2Placement2D ()
{
    return m_refIfcAxis2Placement2DList;
}



IfcAxis2Placement3D *ExpressDataSet::getIfcAxis2Placement3D(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcAxis2Placement3D * > (current->second.get());
    }
    else
    {
        IfcAxis2Placement3D *ret = static_cast< IfcAxis2Placement3D * > (allocateIfcAxis2Placement3D(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcAxis2Placement3D(IfcAxis2Placement3D *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcAxis2Placement3D_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAxis2Placement3D(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcAxis2Placement3D *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAxis2Placement3D(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAxis2Placement3D_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAxis2Placement3D > ExpressDataSet::createIfcAxis2Placement3D(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcAxis2Placement3D(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcAxis2Placement3D * > (allocateIfcAxis2Placement3D(this, Step::Id_UNSET));
    }
}

IfcAxis2Placement3D *ExpressDataSet::cloneIfcAxis2Placement3D(ExpressDataSet *expressDataSet, const IfcAxis2Placement3D &obj, const CopyOp &copyop)
{
    IfcAxis2Placement3D *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAxis2Placement3D(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAxis2Placement3D_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAxis2Placement3D *ExpressDataSet::cloneIfcAxis2Placement3D(const IfcAxis2Placement3D &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcAxis2Placement3D(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcAxis2Placement3D(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcAxis2Placement3D  > &ExpressDataSet::getAllIfcAxis2Placement3D ()
{
    return m_refIfcAxis2Placement3DList;
}



IfcBeam *ExpressDataSet::getIfcBeam(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcBeam * > (current->second.get());
    }
    else
    {
        IfcBeam *ret = static_cast< IfcBeam * > (allocateIfcBeam(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcBeam(IfcBeam *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcBeam_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBeam(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcBeam *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBeam(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBeam_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBeam > ExpressDataSet::createIfcBeam(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcBeam(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcBeam * > (allocateIfcBeam(this, Step::Id_UNSET));
    }
}

IfcBeam *ExpressDataSet::cloneIfcBeam(ExpressDataSet *expressDataSet, const IfcBeam &obj, const CopyOp &copyop)
{
    IfcBeam *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBeam(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBeam_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBeam *ExpressDataSet::cloneIfcBeam(const IfcBeam &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcBeam(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcBeam(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcBeam  > &ExpressDataSet::getAllIfcBeam ()
{
    return m_refIfcBeamList;
}



IfcBeamType *ExpressDataSet::getIfcBeamType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcBeamType * > (current->second.get());
    }
    else
    {
        IfcBeamType *ret = static_cast< IfcBeamType * > (allocateIfcBeamType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcBeamType(IfcBeamType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcBeamType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBeamType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcBeamType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBeamType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBeamType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBeamType > ExpressDataSet::createIfcBeamType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcBeamType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcBeamType * > (allocateIfcBeamType(this, Step::Id_UNSET));
    }
}

IfcBeamType *ExpressDataSet::cloneIfcBeamType(ExpressDataSet *expressDataSet, const IfcBeamType &obj, const CopyOp &copyop)
{
    IfcBeamType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBeamType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBeamType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBeamType *ExpressDataSet::cloneIfcBeamType(const IfcBeamType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcBeamType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcBeamType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcBeamType  > &ExpressDataSet::getAllIfcBeamType ()
{
    return m_refIfcBeamTypeList;
}



IfcBezierCurve *ExpressDataSet::getIfcBezierCurve(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcBezierCurve * > (current->second.get());
    }
    else
    {
        IfcBezierCurve *ret = static_cast< IfcBezierCurve * > (allocateIfcBezierCurve(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcBezierCurve(IfcBezierCurve *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcBezierCurve_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBezierCurve(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcBezierCurve *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBezierCurve(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBezierCurve_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBezierCurve > ExpressDataSet::createIfcBezierCurve(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcBezierCurve(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcBezierCurve * > (allocateIfcBezierCurve(this, Step::Id_UNSET));
    }
}

IfcBezierCurve *ExpressDataSet::cloneIfcBezierCurve(ExpressDataSet *expressDataSet, const IfcBezierCurve &obj, const CopyOp &copyop)
{
    IfcBezierCurve *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBezierCurve(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBezierCurve_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBezierCurve *ExpressDataSet::cloneIfcBezierCurve(const IfcBezierCurve &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcBezierCurve(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcBezierCurve(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcBezierCurve  > &ExpressDataSet::getAllIfcBezierCurve ()
{
    return m_refIfcBezierCurveList;
}



IfcBlobTexture *ExpressDataSet::getIfcBlobTexture(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcBlobTexture * > (current->second.get());
    }
    else
    {
        IfcBlobTexture *ret = static_cast< IfcBlobTexture * > (allocateIfcBlobTexture(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcBlobTexture(IfcBlobTexture *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcBlobTexture_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBlobTexture(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcBlobTexture *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBlobTexture(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBlobTexture_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBlobTexture > ExpressDataSet::createIfcBlobTexture(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcBlobTexture(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcBlobTexture * > (allocateIfcBlobTexture(this, Step::Id_UNSET));
    }
}

IfcBlobTexture *ExpressDataSet::cloneIfcBlobTexture(ExpressDataSet *expressDataSet, const IfcBlobTexture &obj, const CopyOp &copyop)
{
    IfcBlobTexture *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBlobTexture(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBlobTexture_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBlobTexture *ExpressDataSet::cloneIfcBlobTexture(const IfcBlobTexture &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcBlobTexture(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcBlobTexture(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcBlobTexture  > &ExpressDataSet::getAllIfcBlobTexture ()
{
    return m_refIfcBlobTextureList;
}



IfcBlock *ExpressDataSet::getIfcBlock(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcBlock * > (current->second.get());
    }
    else
    {
        IfcBlock *ret = static_cast< IfcBlock * > (allocateIfcBlock(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcBlock(IfcBlock *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcBlock_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBlock(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcBlock *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBlock(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBlock_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBlock > ExpressDataSet::createIfcBlock(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcBlock(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcBlock * > (allocateIfcBlock(this, Step::Id_UNSET));
    }
}

IfcBlock *ExpressDataSet::cloneIfcBlock(ExpressDataSet *expressDataSet, const IfcBlock &obj, const CopyOp &copyop)
{
    IfcBlock *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBlock(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBlock_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBlock *ExpressDataSet::cloneIfcBlock(const IfcBlock &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcBlock(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcBlock(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcBlock  > &ExpressDataSet::getAllIfcBlock ()
{
    return m_refIfcBlockList;
}



IfcBoilerType *ExpressDataSet::getIfcBoilerType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcBoilerType * > (current->second.get());
    }
    else
    {
        IfcBoilerType *ret = static_cast< IfcBoilerType * > (allocateIfcBoilerType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcBoilerType(IfcBoilerType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcBoilerType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBoilerType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcBoilerType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBoilerType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBoilerType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBoilerType > ExpressDataSet::createIfcBoilerType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcBoilerType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcBoilerType * > (allocateIfcBoilerType(this, Step::Id_UNSET));
    }
}

IfcBoilerType *ExpressDataSet::cloneIfcBoilerType(ExpressDataSet *expressDataSet, const IfcBoilerType &obj, const CopyOp &copyop)
{
    IfcBoilerType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBoilerType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBoilerType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBoilerType *ExpressDataSet::cloneIfcBoilerType(const IfcBoilerType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcBoilerType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcBoilerType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcBoilerType  > &ExpressDataSet::getAllIfcBoilerType ()
{
    return m_refIfcBoilerTypeList;
}



IfcBooleanClippingResult *ExpressDataSet::getIfcBooleanClippingResult(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcBooleanClippingResult * > (current->second.get());
    }
    else
    {
        IfcBooleanClippingResult *ret = static_cast< IfcBooleanClippingResult * > (allocateIfcBooleanClippingResult(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcBooleanClippingResult(IfcBooleanClippingResult *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcBooleanClippingResult_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBooleanClippingResult(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcBooleanClippingResult *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBooleanClippingResult(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBooleanClippingResult_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBooleanClippingResult > ExpressDataSet::createIfcBooleanClippingResult(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcBooleanClippingResult(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcBooleanClippingResult * > (allocateIfcBooleanClippingResult(this, Step::Id_UNSET));
    }
}

IfcBooleanClippingResult *ExpressDataSet::cloneIfcBooleanClippingResult(ExpressDataSet *expressDataSet, const IfcBooleanClippingResult &obj, const CopyOp &copyop)
{
    IfcBooleanClippingResult *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBooleanClippingResult(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBooleanClippingResult_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBooleanClippingResult *ExpressDataSet::cloneIfcBooleanClippingResult(const IfcBooleanClippingResult &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcBooleanClippingResult(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcBooleanClippingResult(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcBooleanClippingResult  > &ExpressDataSet::getAllIfcBooleanClippingResult ()
{
    return m_refIfcBooleanClippingResultList;
}



IfcBooleanResult *ExpressDataSet::getIfcBooleanResult(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcBooleanResult * > (current->second.get());
    }
    else
    {
        IfcBooleanResult *ret = static_cast< IfcBooleanResult * > (allocateIfcBooleanResult(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcBooleanResult(IfcBooleanResult *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcBooleanResult_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBooleanResult(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcBooleanResult *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBooleanResult(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBooleanResult_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBooleanResult > ExpressDataSet::createIfcBooleanResult(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcBooleanResult(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcBooleanResult * > (allocateIfcBooleanResult(this, Step::Id_UNSET));
    }
}

IfcBooleanResult *ExpressDataSet::cloneIfcBooleanResult(ExpressDataSet *expressDataSet, const IfcBooleanResult &obj, const CopyOp &copyop)
{
    IfcBooleanResult *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBooleanResult(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBooleanResult_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBooleanResult *ExpressDataSet::cloneIfcBooleanResult(const IfcBooleanResult &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcBooleanResult(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcBooleanResult(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcBooleanResult  > &ExpressDataSet::getAllIfcBooleanResult ()
{
    return m_refIfcBooleanResultList;
}



IfcBoundaryCondition *ExpressDataSet::getIfcBoundaryCondition(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcBoundaryCondition * > (current->second.get());
    }
    else
    {
        IfcBoundaryCondition *ret = static_cast< IfcBoundaryCondition * > (allocateIfcBoundaryCondition(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcBoundaryCondition(IfcBoundaryCondition *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcBoundaryCondition_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBoundaryCondition(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcBoundaryCondition *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBoundaryCondition(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBoundaryCondition_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBoundaryCondition > ExpressDataSet::createIfcBoundaryCondition(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcBoundaryCondition(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcBoundaryCondition * > (allocateIfcBoundaryCondition(this, Step::Id_UNSET));
    }
}

IfcBoundaryCondition *ExpressDataSet::cloneIfcBoundaryCondition(ExpressDataSet *expressDataSet, const IfcBoundaryCondition &obj, const CopyOp &copyop)
{
    IfcBoundaryCondition *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBoundaryCondition(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBoundaryCondition_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBoundaryCondition *ExpressDataSet::cloneIfcBoundaryCondition(const IfcBoundaryCondition &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcBoundaryCondition(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcBoundaryCondition(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcBoundaryCondition  > &ExpressDataSet::getAllIfcBoundaryCondition ()
{
    return m_refIfcBoundaryConditionList;
}



IfcBoundaryEdgeCondition *ExpressDataSet::getIfcBoundaryEdgeCondition(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcBoundaryEdgeCondition * > (current->second.get());
    }
    else
    {
        IfcBoundaryEdgeCondition *ret = static_cast< IfcBoundaryEdgeCondition * > (allocateIfcBoundaryEdgeCondition(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcBoundaryEdgeCondition(IfcBoundaryEdgeCondition *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcBoundaryEdgeCondition_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBoundaryEdgeCondition(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcBoundaryEdgeCondition *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBoundaryEdgeCondition(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBoundaryEdgeCondition_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBoundaryEdgeCondition > ExpressDataSet::createIfcBoundaryEdgeCondition(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcBoundaryEdgeCondition(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcBoundaryEdgeCondition * > (allocateIfcBoundaryEdgeCondition(this, Step::Id_UNSET));
    }
}

IfcBoundaryEdgeCondition *ExpressDataSet::cloneIfcBoundaryEdgeCondition(ExpressDataSet *expressDataSet, const IfcBoundaryEdgeCondition &obj, const CopyOp &copyop)
{
    IfcBoundaryEdgeCondition *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBoundaryEdgeCondition(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBoundaryEdgeCondition_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBoundaryEdgeCondition *ExpressDataSet::cloneIfcBoundaryEdgeCondition(const IfcBoundaryEdgeCondition &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcBoundaryEdgeCondition(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcBoundaryEdgeCondition(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcBoundaryEdgeCondition  > &ExpressDataSet::getAllIfcBoundaryEdgeCondition ()
{
    return m_refIfcBoundaryEdgeConditionList;
}



IfcBoundaryFaceCondition *ExpressDataSet::getIfcBoundaryFaceCondition(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcBoundaryFaceCondition * > (current->second.get());
    }
    else
    {
        IfcBoundaryFaceCondition *ret = static_cast< IfcBoundaryFaceCondition * > (allocateIfcBoundaryFaceCondition(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcBoundaryFaceCondition(IfcBoundaryFaceCondition *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcBoundaryFaceCondition_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBoundaryFaceCondition(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcBoundaryFaceCondition *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBoundaryFaceCondition(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBoundaryFaceCondition_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBoundaryFaceCondition > ExpressDataSet::createIfcBoundaryFaceCondition(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcBoundaryFaceCondition(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcBoundaryFaceCondition * > (allocateIfcBoundaryFaceCondition(this, Step::Id_UNSET));
    }
}

IfcBoundaryFaceCondition *ExpressDataSet::cloneIfcBoundaryFaceCondition(ExpressDataSet *expressDataSet, const IfcBoundaryFaceCondition &obj, const CopyOp &copyop)
{
    IfcBoundaryFaceCondition *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBoundaryFaceCondition(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBoundaryFaceCondition_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBoundaryFaceCondition *ExpressDataSet::cloneIfcBoundaryFaceCondition(const IfcBoundaryFaceCondition &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcBoundaryFaceCondition(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcBoundaryFaceCondition(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcBoundaryFaceCondition  > &ExpressDataSet::getAllIfcBoundaryFaceCondition ()
{
    return m_refIfcBoundaryFaceConditionList;
}



IfcBoundaryNodeCondition *ExpressDataSet::getIfcBoundaryNodeCondition(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcBoundaryNodeCondition * > (current->second.get());
    }
    else
    {
        IfcBoundaryNodeCondition *ret = static_cast< IfcBoundaryNodeCondition * > (allocateIfcBoundaryNodeCondition(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcBoundaryNodeCondition(IfcBoundaryNodeCondition *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcBoundaryNodeCondition_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBoundaryNodeCondition(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcBoundaryNodeCondition *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBoundaryNodeCondition(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBoundaryNodeCondition_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBoundaryNodeCondition > ExpressDataSet::createIfcBoundaryNodeCondition(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcBoundaryNodeCondition(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcBoundaryNodeCondition * > (allocateIfcBoundaryNodeCondition(this, Step::Id_UNSET));
    }
}

IfcBoundaryNodeCondition *ExpressDataSet::cloneIfcBoundaryNodeCondition(ExpressDataSet *expressDataSet, const IfcBoundaryNodeCondition &obj, const CopyOp &copyop)
{
    IfcBoundaryNodeCondition *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBoundaryNodeCondition(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBoundaryNodeCondition_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBoundaryNodeCondition *ExpressDataSet::cloneIfcBoundaryNodeCondition(const IfcBoundaryNodeCondition &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcBoundaryNodeCondition(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcBoundaryNodeCondition(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcBoundaryNodeCondition  > &ExpressDataSet::getAllIfcBoundaryNodeCondition ()
{
    return m_refIfcBoundaryNodeConditionList;
}



IfcBoundaryNodeConditionWarping *ExpressDataSet::getIfcBoundaryNodeConditionWarping(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcBoundaryNodeConditionWarping * > (current->second.get());
    }
    else
    {
        IfcBoundaryNodeConditionWarping *ret = static_cast< IfcBoundaryNodeConditionWarping * > (allocateIfcBoundaryNodeConditionWarping(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcBoundaryNodeConditionWarping(IfcBoundaryNodeConditionWarping *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcBoundaryNodeConditionWarping_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBoundaryNodeConditionWarping(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcBoundaryNodeConditionWarping *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBoundaryNodeConditionWarping(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBoundaryNodeConditionWarping_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBoundaryNodeConditionWarping > ExpressDataSet::createIfcBoundaryNodeConditionWarping(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcBoundaryNodeConditionWarping(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcBoundaryNodeConditionWarping * > (allocateIfcBoundaryNodeConditionWarping(this, Step::Id_UNSET));
    }
}

IfcBoundaryNodeConditionWarping *ExpressDataSet::cloneIfcBoundaryNodeConditionWarping(ExpressDataSet *expressDataSet, const IfcBoundaryNodeConditionWarping &obj, const CopyOp &copyop)
{
    IfcBoundaryNodeConditionWarping *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBoundaryNodeConditionWarping(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBoundaryNodeConditionWarping_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBoundaryNodeConditionWarping *ExpressDataSet::cloneIfcBoundaryNodeConditionWarping(const IfcBoundaryNodeConditionWarping &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcBoundaryNodeConditionWarping(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcBoundaryNodeConditionWarping(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcBoundaryNodeConditionWarping  > &ExpressDataSet::getAllIfcBoundaryNodeConditionWarping ()
{
    return m_refIfcBoundaryNodeConditionWarpingList;
}



IfcBoundedCurve *ExpressDataSet::getIfcBoundedCurve(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcBoundedCurve * > (current->second.get());
    }
    else
    {
        IfcBoundedCurve *ret = static_cast< IfcBoundedCurve * > (allocateIfcBoundedCurve(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcBoundedCurve(IfcBoundedCurve *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcBoundedCurve_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBoundedCurve(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcBoundedCurve *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBoundedCurve(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBoundedCurve_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBoundedCurve > ExpressDataSet::createIfcBoundedCurve(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcBoundedCurve(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcBoundedCurve * > (allocateIfcBoundedCurve(this, Step::Id_UNSET));
    }
}

IfcBoundedCurve *ExpressDataSet::cloneIfcBoundedCurve(ExpressDataSet *expressDataSet, const IfcBoundedCurve &obj, const CopyOp &copyop)
{
    IfcBoundedCurve *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBoundedCurve(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBoundedCurve_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBoundedCurve *ExpressDataSet::cloneIfcBoundedCurve(const IfcBoundedCurve &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcBoundedCurve(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcBoundedCurve(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcBoundedCurve  > &ExpressDataSet::getAllIfcBoundedCurve ()
{
    return m_refIfcBoundedCurveList;
}



IfcBoundedSurface *ExpressDataSet::getIfcBoundedSurface(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcBoundedSurface * > (current->second.get());
    }
    else
    {
        IfcBoundedSurface *ret = static_cast< IfcBoundedSurface * > (allocateIfcBoundedSurface(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcBoundedSurface(IfcBoundedSurface *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcBoundedSurface_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBoundedSurface(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcBoundedSurface *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBoundedSurface(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBoundedSurface_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBoundedSurface > ExpressDataSet::createIfcBoundedSurface(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcBoundedSurface(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcBoundedSurface * > (allocateIfcBoundedSurface(this, Step::Id_UNSET));
    }
}

IfcBoundedSurface *ExpressDataSet::cloneIfcBoundedSurface(ExpressDataSet *expressDataSet, const IfcBoundedSurface &obj, const CopyOp &copyop)
{
    IfcBoundedSurface *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBoundedSurface(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBoundedSurface_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBoundedSurface *ExpressDataSet::cloneIfcBoundedSurface(const IfcBoundedSurface &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcBoundedSurface(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcBoundedSurface(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcBoundedSurface  > &ExpressDataSet::getAllIfcBoundedSurface ()
{
    return m_refIfcBoundedSurfaceList;
}



IfcBoundingBox *ExpressDataSet::getIfcBoundingBox(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcBoundingBox * > (current->second.get());
    }
    else
    {
        IfcBoundingBox *ret = static_cast< IfcBoundingBox * > (allocateIfcBoundingBox(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcBoundingBox(IfcBoundingBox *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcBoundingBox_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBoundingBox(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcBoundingBox *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBoundingBox(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBoundingBox_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBoundingBox > ExpressDataSet::createIfcBoundingBox(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcBoundingBox(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcBoundingBox * > (allocateIfcBoundingBox(this, Step::Id_UNSET));
    }
}

IfcBoundingBox *ExpressDataSet::cloneIfcBoundingBox(ExpressDataSet *expressDataSet, const IfcBoundingBox &obj, const CopyOp &copyop)
{
    IfcBoundingBox *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBoundingBox(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBoundingBox_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBoundingBox *ExpressDataSet::cloneIfcBoundingBox(const IfcBoundingBox &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcBoundingBox(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcBoundingBox(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcBoundingBox  > &ExpressDataSet::getAllIfcBoundingBox ()
{
    return m_refIfcBoundingBoxList;
}



IfcBoxedHalfSpace *ExpressDataSet::getIfcBoxedHalfSpace(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcBoxedHalfSpace * > (current->second.get());
    }
    else
    {
        IfcBoxedHalfSpace *ret = static_cast< IfcBoxedHalfSpace * > (allocateIfcBoxedHalfSpace(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcBoxedHalfSpace(IfcBoxedHalfSpace *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcBoxedHalfSpace_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBoxedHalfSpace(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcBoxedHalfSpace *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBoxedHalfSpace(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBoxedHalfSpace_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBoxedHalfSpace > ExpressDataSet::createIfcBoxedHalfSpace(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcBoxedHalfSpace(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcBoxedHalfSpace * > (allocateIfcBoxedHalfSpace(this, Step::Id_UNSET));
    }
}

IfcBoxedHalfSpace *ExpressDataSet::cloneIfcBoxedHalfSpace(ExpressDataSet *expressDataSet, const IfcBoxedHalfSpace &obj, const CopyOp &copyop)
{
    IfcBoxedHalfSpace *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBoxedHalfSpace(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBoxedHalfSpace_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBoxedHalfSpace *ExpressDataSet::cloneIfcBoxedHalfSpace(const IfcBoxedHalfSpace &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcBoxedHalfSpace(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcBoxedHalfSpace(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcBoxedHalfSpace  > &ExpressDataSet::getAllIfcBoxedHalfSpace ()
{
    return m_refIfcBoxedHalfSpaceList;
}



IfcBSplineCurve *ExpressDataSet::getIfcBSplineCurve(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcBSplineCurve * > (current->second.get());
    }
    else
    {
        IfcBSplineCurve *ret = static_cast< IfcBSplineCurve * > (allocateIfcBSplineCurve(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcBSplineCurve(IfcBSplineCurve *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcBSplineCurve_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBSplineCurve(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcBSplineCurve *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBSplineCurve(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBSplineCurve_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBSplineCurve > ExpressDataSet::createIfcBSplineCurve(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcBSplineCurve(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcBSplineCurve * > (allocateIfcBSplineCurve(this, Step::Id_UNSET));
    }
}

IfcBSplineCurve *ExpressDataSet::cloneIfcBSplineCurve(ExpressDataSet *expressDataSet, const IfcBSplineCurve &obj, const CopyOp &copyop)
{
    IfcBSplineCurve *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBSplineCurve(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBSplineCurve_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBSplineCurve *ExpressDataSet::cloneIfcBSplineCurve(const IfcBSplineCurve &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcBSplineCurve(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcBSplineCurve(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcBSplineCurve  > &ExpressDataSet::getAllIfcBSplineCurve ()
{
    return m_refIfcBSplineCurveList;
}



IfcBuilding *ExpressDataSet::getIfcBuilding(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcBuilding * > (current->second.get());
    }
    else
    {
        IfcBuilding *ret = static_cast< IfcBuilding * > (allocateIfcBuilding(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcBuilding(IfcBuilding *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcBuilding_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBuilding(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcBuilding *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBuilding(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBuilding_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBuilding > ExpressDataSet::createIfcBuilding(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcBuilding(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcBuilding * > (allocateIfcBuilding(this, Step::Id_UNSET));
    }
}

IfcBuilding *ExpressDataSet::cloneIfcBuilding(ExpressDataSet *expressDataSet, const IfcBuilding &obj, const CopyOp &copyop)
{
    IfcBuilding *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBuilding(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBuilding_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBuilding *ExpressDataSet::cloneIfcBuilding(const IfcBuilding &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcBuilding(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcBuilding(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcBuilding  > &ExpressDataSet::getAllIfcBuilding ()
{
    return m_refIfcBuildingList;
}



IfcBuildingElement *ExpressDataSet::getIfcBuildingElement(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcBuildingElement * > (current->second.get());
    }
    else
    {
        IfcBuildingElement *ret = static_cast< IfcBuildingElement * > (allocateIfcBuildingElement(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcBuildingElement(IfcBuildingElement *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcBuildingElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBuildingElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcBuildingElement *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBuildingElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBuildingElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBuildingElement > ExpressDataSet::createIfcBuildingElement(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcBuildingElement(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcBuildingElement * > (allocateIfcBuildingElement(this, Step::Id_UNSET));
    }
}

IfcBuildingElement *ExpressDataSet::cloneIfcBuildingElement(ExpressDataSet *expressDataSet, const IfcBuildingElement &obj, const CopyOp &copyop)
{
    IfcBuildingElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBuildingElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBuildingElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBuildingElement *ExpressDataSet::cloneIfcBuildingElement(const IfcBuildingElement &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcBuildingElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcBuildingElement(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcBuildingElement  > &ExpressDataSet::getAllIfcBuildingElement ()
{
    return m_refIfcBuildingElementList;
}



IfcBuildingElementComponent *ExpressDataSet::getIfcBuildingElementComponent(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcBuildingElementComponent * > (current->second.get());
    }
    else
    {
        IfcBuildingElementComponent *ret = static_cast< IfcBuildingElementComponent * > (allocateIfcBuildingElementComponent(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcBuildingElementComponent(IfcBuildingElementComponent *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcBuildingElementComponent_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBuildingElementComponent(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcBuildingElementComponent *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBuildingElementComponent(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBuildingElementComponent_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBuildingElementComponent > ExpressDataSet::createIfcBuildingElementComponent(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcBuildingElementComponent(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcBuildingElementComponent * > (allocateIfcBuildingElementComponent(this, Step::Id_UNSET));
    }
}

IfcBuildingElementComponent *ExpressDataSet::cloneIfcBuildingElementComponent(ExpressDataSet *expressDataSet, const IfcBuildingElementComponent &obj, const CopyOp &copyop)
{
    IfcBuildingElementComponent *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBuildingElementComponent(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBuildingElementComponent_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBuildingElementComponent *ExpressDataSet::cloneIfcBuildingElementComponent(const IfcBuildingElementComponent &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcBuildingElementComponent(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcBuildingElementComponent(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcBuildingElementComponent  > &ExpressDataSet::getAllIfcBuildingElementComponent ()
{
    return m_refIfcBuildingElementComponentList;
}



IfcBuildingElementPart *ExpressDataSet::getIfcBuildingElementPart(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcBuildingElementPart * > (current->second.get());
    }
    else
    {
        IfcBuildingElementPart *ret = static_cast< IfcBuildingElementPart * > (allocateIfcBuildingElementPart(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcBuildingElementPart(IfcBuildingElementPart *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcBuildingElementPart_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBuildingElementPart(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcBuildingElementPart *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBuildingElementPart(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBuildingElementPart_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBuildingElementPart > ExpressDataSet::createIfcBuildingElementPart(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcBuildingElementPart(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcBuildingElementPart * > (allocateIfcBuildingElementPart(this, Step::Id_UNSET));
    }
}

IfcBuildingElementPart *ExpressDataSet::cloneIfcBuildingElementPart(ExpressDataSet *expressDataSet, const IfcBuildingElementPart &obj, const CopyOp &copyop)
{
    IfcBuildingElementPart *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBuildingElementPart(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBuildingElementPart_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBuildingElementPart *ExpressDataSet::cloneIfcBuildingElementPart(const IfcBuildingElementPart &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcBuildingElementPart(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcBuildingElementPart(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcBuildingElementPart  > &ExpressDataSet::getAllIfcBuildingElementPart ()
{
    return m_refIfcBuildingElementPartList;
}



IfcBuildingElementProxy *ExpressDataSet::getIfcBuildingElementProxy(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcBuildingElementProxy * > (current->second.get());
    }
    else
    {
        IfcBuildingElementProxy *ret = static_cast< IfcBuildingElementProxy * > (allocateIfcBuildingElementProxy(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcBuildingElementProxy(IfcBuildingElementProxy *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcBuildingElementProxy_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBuildingElementProxy(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcBuildingElementProxy *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBuildingElementProxy(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBuildingElementProxy_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBuildingElementProxy > ExpressDataSet::createIfcBuildingElementProxy(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcBuildingElementProxy(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcBuildingElementProxy * > (allocateIfcBuildingElementProxy(this, Step::Id_UNSET));
    }
}

IfcBuildingElementProxy *ExpressDataSet::cloneIfcBuildingElementProxy(ExpressDataSet *expressDataSet, const IfcBuildingElementProxy &obj, const CopyOp &copyop)
{
    IfcBuildingElementProxy *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBuildingElementProxy(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBuildingElementProxy_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBuildingElementProxy *ExpressDataSet::cloneIfcBuildingElementProxy(const IfcBuildingElementProxy &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcBuildingElementProxy(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcBuildingElementProxy(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcBuildingElementProxy  > &ExpressDataSet::getAllIfcBuildingElementProxy ()
{
    return m_refIfcBuildingElementProxyList;
}



IfcBuildingElementProxyType *ExpressDataSet::getIfcBuildingElementProxyType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcBuildingElementProxyType * > (current->second.get());
    }
    else
    {
        IfcBuildingElementProxyType *ret = static_cast< IfcBuildingElementProxyType * > (allocateIfcBuildingElementProxyType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcBuildingElementProxyType(IfcBuildingElementProxyType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcBuildingElementProxyType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBuildingElementProxyType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcBuildingElementProxyType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBuildingElementProxyType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBuildingElementProxyType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBuildingElementProxyType > ExpressDataSet::createIfcBuildingElementProxyType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcBuildingElementProxyType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcBuildingElementProxyType * > (allocateIfcBuildingElementProxyType(this, Step::Id_UNSET));
    }
}

IfcBuildingElementProxyType *ExpressDataSet::cloneIfcBuildingElementProxyType(ExpressDataSet *expressDataSet, const IfcBuildingElementProxyType &obj, const CopyOp &copyop)
{
    IfcBuildingElementProxyType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBuildingElementProxyType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBuildingElementProxyType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBuildingElementProxyType *ExpressDataSet::cloneIfcBuildingElementProxyType(const IfcBuildingElementProxyType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcBuildingElementProxyType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcBuildingElementProxyType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcBuildingElementProxyType  > &ExpressDataSet::getAllIfcBuildingElementProxyType ()
{
    return m_refIfcBuildingElementProxyTypeList;
}



IfcBuildingElementType *ExpressDataSet::getIfcBuildingElementType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcBuildingElementType * > (current->second.get());
    }
    else
    {
        IfcBuildingElementType *ret = static_cast< IfcBuildingElementType * > (allocateIfcBuildingElementType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcBuildingElementType(IfcBuildingElementType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcBuildingElementType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBuildingElementType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcBuildingElementType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBuildingElementType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBuildingElementType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBuildingElementType > ExpressDataSet::createIfcBuildingElementType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcBuildingElementType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcBuildingElementType * > (allocateIfcBuildingElementType(this, Step::Id_UNSET));
    }
}

IfcBuildingElementType *ExpressDataSet::cloneIfcBuildingElementType(ExpressDataSet *expressDataSet, const IfcBuildingElementType &obj, const CopyOp &copyop)
{
    IfcBuildingElementType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBuildingElementType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBuildingElementType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBuildingElementType *ExpressDataSet::cloneIfcBuildingElementType(const IfcBuildingElementType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcBuildingElementType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcBuildingElementType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcBuildingElementType  > &ExpressDataSet::getAllIfcBuildingElementType ()
{
    return m_refIfcBuildingElementTypeList;
}



IfcBuildingStorey *ExpressDataSet::getIfcBuildingStorey(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcBuildingStorey * > (current->second.get());
    }
    else
    {
        IfcBuildingStorey *ret = static_cast< IfcBuildingStorey * > (allocateIfcBuildingStorey(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcBuildingStorey(IfcBuildingStorey *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcBuildingStorey_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBuildingStorey(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcBuildingStorey *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBuildingStorey(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBuildingStorey_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBuildingStorey > ExpressDataSet::createIfcBuildingStorey(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcBuildingStorey(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcBuildingStorey * > (allocateIfcBuildingStorey(this, Step::Id_UNSET));
    }
}

IfcBuildingStorey *ExpressDataSet::cloneIfcBuildingStorey(ExpressDataSet *expressDataSet, const IfcBuildingStorey &obj, const CopyOp &copyop)
{
    IfcBuildingStorey *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBuildingStorey(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBuildingStorey_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBuildingStorey *ExpressDataSet::cloneIfcBuildingStorey(const IfcBuildingStorey &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcBuildingStorey(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcBuildingStorey(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcBuildingStorey  > &ExpressDataSet::getAllIfcBuildingStorey ()
{
    return m_refIfcBuildingStoreyList;
}



IfcCableCarrierFittingType *ExpressDataSet::getIfcCableCarrierFittingType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCableCarrierFittingType * > (current->second.get());
    }
    else
    {
        IfcCableCarrierFittingType *ret = static_cast< IfcCableCarrierFittingType * > (allocateIfcCableCarrierFittingType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCableCarrierFittingType(IfcCableCarrierFittingType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCableCarrierFittingType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCableCarrierFittingType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCableCarrierFittingType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCableCarrierFittingType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCableCarrierFittingType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCableCarrierFittingType > ExpressDataSet::createIfcCableCarrierFittingType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCableCarrierFittingType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCableCarrierFittingType * > (allocateIfcCableCarrierFittingType(this, Step::Id_UNSET));
    }
}

IfcCableCarrierFittingType *ExpressDataSet::cloneIfcCableCarrierFittingType(ExpressDataSet *expressDataSet, const IfcCableCarrierFittingType &obj, const CopyOp &copyop)
{
    IfcCableCarrierFittingType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCableCarrierFittingType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCableCarrierFittingType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCableCarrierFittingType *ExpressDataSet::cloneIfcCableCarrierFittingType(const IfcCableCarrierFittingType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCableCarrierFittingType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCableCarrierFittingType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCableCarrierFittingType  > &ExpressDataSet::getAllIfcCableCarrierFittingType ()
{
    return m_refIfcCableCarrierFittingTypeList;
}



IfcCableCarrierSegmentType *ExpressDataSet::getIfcCableCarrierSegmentType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCableCarrierSegmentType * > (current->second.get());
    }
    else
    {
        IfcCableCarrierSegmentType *ret = static_cast< IfcCableCarrierSegmentType * > (allocateIfcCableCarrierSegmentType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCableCarrierSegmentType(IfcCableCarrierSegmentType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCableCarrierSegmentType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCableCarrierSegmentType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCableCarrierSegmentType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCableCarrierSegmentType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCableCarrierSegmentType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCableCarrierSegmentType > ExpressDataSet::createIfcCableCarrierSegmentType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCableCarrierSegmentType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCableCarrierSegmentType * > (allocateIfcCableCarrierSegmentType(this, Step::Id_UNSET));
    }
}

IfcCableCarrierSegmentType *ExpressDataSet::cloneIfcCableCarrierSegmentType(ExpressDataSet *expressDataSet, const IfcCableCarrierSegmentType &obj, const CopyOp &copyop)
{
    IfcCableCarrierSegmentType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCableCarrierSegmentType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCableCarrierSegmentType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCableCarrierSegmentType *ExpressDataSet::cloneIfcCableCarrierSegmentType(const IfcCableCarrierSegmentType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCableCarrierSegmentType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCableCarrierSegmentType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCableCarrierSegmentType  > &ExpressDataSet::getAllIfcCableCarrierSegmentType ()
{
    return m_refIfcCableCarrierSegmentTypeList;
}



IfcCableSegmentType *ExpressDataSet::getIfcCableSegmentType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCableSegmentType * > (current->second.get());
    }
    else
    {
        IfcCableSegmentType *ret = static_cast< IfcCableSegmentType * > (allocateIfcCableSegmentType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCableSegmentType(IfcCableSegmentType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCableSegmentType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCableSegmentType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCableSegmentType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCableSegmentType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCableSegmentType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCableSegmentType > ExpressDataSet::createIfcCableSegmentType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCableSegmentType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCableSegmentType * > (allocateIfcCableSegmentType(this, Step::Id_UNSET));
    }
}

IfcCableSegmentType *ExpressDataSet::cloneIfcCableSegmentType(ExpressDataSet *expressDataSet, const IfcCableSegmentType &obj, const CopyOp &copyop)
{
    IfcCableSegmentType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCableSegmentType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCableSegmentType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCableSegmentType *ExpressDataSet::cloneIfcCableSegmentType(const IfcCableSegmentType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCableSegmentType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCableSegmentType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCableSegmentType  > &ExpressDataSet::getAllIfcCableSegmentType ()
{
    return m_refIfcCableSegmentTypeList;
}



IfcCalendarDate *ExpressDataSet::getIfcCalendarDate(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCalendarDate * > (current->second.get());
    }
    else
    {
        IfcCalendarDate *ret = static_cast< IfcCalendarDate * > (allocateIfcCalendarDate(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCalendarDate(IfcCalendarDate *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCalendarDate_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCalendarDate(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCalendarDate *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCalendarDate(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCalendarDate_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCalendarDate > ExpressDataSet::createIfcCalendarDate(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCalendarDate(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCalendarDate * > (allocateIfcCalendarDate(this, Step::Id_UNSET));
    }
}

IfcCalendarDate *ExpressDataSet::cloneIfcCalendarDate(ExpressDataSet *expressDataSet, const IfcCalendarDate &obj, const CopyOp &copyop)
{
    IfcCalendarDate *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCalendarDate(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCalendarDate_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCalendarDate *ExpressDataSet::cloneIfcCalendarDate(const IfcCalendarDate &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCalendarDate(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCalendarDate(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCalendarDate  > &ExpressDataSet::getAllIfcCalendarDate ()
{
    return m_refIfcCalendarDateList;
}



IfcCartesianPoint *ExpressDataSet::getIfcCartesianPoint(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCartesianPoint * > (current->second.get());
    }
    else
    {
        IfcCartesianPoint *ret = static_cast< IfcCartesianPoint * > (allocateIfcCartesianPoint(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCartesianPoint(IfcCartesianPoint *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCartesianPoint_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCartesianPoint(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCartesianPoint *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCartesianPoint(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCartesianPoint_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCartesianPoint > ExpressDataSet::createIfcCartesianPoint(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCartesianPoint(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCartesianPoint * > (allocateIfcCartesianPoint(this, Step::Id_UNSET));
    }
}

IfcCartesianPoint *ExpressDataSet::cloneIfcCartesianPoint(ExpressDataSet *expressDataSet, const IfcCartesianPoint &obj, const CopyOp &copyop)
{
    IfcCartesianPoint *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCartesianPoint(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCartesianPoint_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCartesianPoint *ExpressDataSet::cloneIfcCartesianPoint(const IfcCartesianPoint &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCartesianPoint(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCartesianPoint(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCartesianPoint  > &ExpressDataSet::getAllIfcCartesianPoint ()
{
    return m_refIfcCartesianPointList;
}



IfcCartesianTransformationOperator *ExpressDataSet::getIfcCartesianTransformationOperator(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCartesianTransformationOperator * > (current->second.get());
    }
    else
    {
        IfcCartesianTransformationOperator *ret = static_cast< IfcCartesianTransformationOperator * > (allocateIfcCartesianTransformationOperator(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCartesianTransformationOperator(IfcCartesianTransformationOperator *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCartesianTransformationOperator_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCartesianTransformationOperator(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCartesianTransformationOperator *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCartesianTransformationOperator(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCartesianTransformationOperator_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCartesianTransformationOperator > ExpressDataSet::createIfcCartesianTransformationOperator(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCartesianTransformationOperator(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCartesianTransformationOperator * > (allocateIfcCartesianTransformationOperator(this, Step::Id_UNSET));
    }
}

IfcCartesianTransformationOperator *ExpressDataSet::cloneIfcCartesianTransformationOperator(ExpressDataSet *expressDataSet, const IfcCartesianTransformationOperator &obj, const CopyOp &copyop)
{
    IfcCartesianTransformationOperator *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCartesianTransformationOperator(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCartesianTransformationOperator_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCartesianTransformationOperator *ExpressDataSet::cloneIfcCartesianTransformationOperator(const IfcCartesianTransformationOperator &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCartesianTransformationOperator(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCartesianTransformationOperator(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCartesianTransformationOperator  > &ExpressDataSet::getAllIfcCartesianTransformationOperator ()
{
    return m_refIfcCartesianTransformationOperatorList;
}



IfcCartesianTransformationOperator2D *ExpressDataSet::getIfcCartesianTransformationOperator2D(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCartesianTransformationOperator2D * > (current->second.get());
    }
    else
    {
        IfcCartesianTransformationOperator2D *ret = static_cast< IfcCartesianTransformationOperator2D * > (allocateIfcCartesianTransformationOperator2D(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCartesianTransformationOperator2D(IfcCartesianTransformationOperator2D *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCartesianTransformationOperator2D_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCartesianTransformationOperator2D(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCartesianTransformationOperator2D *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCartesianTransformationOperator2D(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCartesianTransformationOperator2D_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCartesianTransformationOperator2D > ExpressDataSet::createIfcCartesianTransformationOperator2D(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCartesianTransformationOperator2D(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCartesianTransformationOperator2D * > (allocateIfcCartesianTransformationOperator2D(this, Step::Id_UNSET));
    }
}

IfcCartesianTransformationOperator2D *ExpressDataSet::cloneIfcCartesianTransformationOperator2D(ExpressDataSet *expressDataSet, const IfcCartesianTransformationOperator2D &obj, const CopyOp &copyop)
{
    IfcCartesianTransformationOperator2D *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCartesianTransformationOperator2D(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCartesianTransformationOperator2D_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCartesianTransformationOperator2D *ExpressDataSet::cloneIfcCartesianTransformationOperator2D(const IfcCartesianTransformationOperator2D &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCartesianTransformationOperator2D(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCartesianTransformationOperator2D(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCartesianTransformationOperator2D  > &ExpressDataSet::getAllIfcCartesianTransformationOperator2D ()
{
    return m_refIfcCartesianTransformationOperator2DList;
}



IfcCartesianTransformationOperator2DnonUniform *ExpressDataSet::getIfcCartesianTransformationOperator2DnonUniform(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCartesianTransformationOperator2DnonUniform * > (current->second.get());
    }
    else
    {
        IfcCartesianTransformationOperator2DnonUniform *ret = static_cast< IfcCartesianTransformationOperator2DnonUniform * > (allocateIfcCartesianTransformationOperator2DnonUniform(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCartesianTransformationOperator2DnonUniform(IfcCartesianTransformationOperator2DnonUniform *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCartesianTransformationOperator2DnonUniform_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCartesianTransformationOperator2DnonUniform(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCartesianTransformationOperator2DnonUniform *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCartesianTransformationOperator2DnonUniform(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCartesianTransformationOperator2DnonUniform_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCartesianTransformationOperator2DnonUniform > ExpressDataSet::createIfcCartesianTransformationOperator2DnonUniform(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCartesianTransformationOperator2DnonUniform(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCartesianTransformationOperator2DnonUniform * > (allocateIfcCartesianTransformationOperator2DnonUniform(this, Step::Id_UNSET));
    }
}

IfcCartesianTransformationOperator2DnonUniform *ExpressDataSet::cloneIfcCartesianTransformationOperator2DnonUniform(ExpressDataSet *expressDataSet, const IfcCartesianTransformationOperator2DnonUniform &obj, const CopyOp &copyop)
{
    IfcCartesianTransformationOperator2DnonUniform *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCartesianTransformationOperator2DnonUniform(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCartesianTransformationOperator2DnonUniform_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCartesianTransformationOperator2DnonUniform *ExpressDataSet::cloneIfcCartesianTransformationOperator2DnonUniform(const IfcCartesianTransformationOperator2DnonUniform &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCartesianTransformationOperator2DnonUniform(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCartesianTransformationOperator2DnonUniform(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCartesianTransformationOperator2DnonUniform  > &ExpressDataSet::getAllIfcCartesianTransformationOperator2DnonUniform ()
{
    return m_refIfcCartesianTransformationOperator2DnonUniformList;
}



IfcCartesianTransformationOperator3D *ExpressDataSet::getIfcCartesianTransformationOperator3D(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCartesianTransformationOperator3D * > (current->second.get());
    }
    else
    {
        IfcCartesianTransformationOperator3D *ret = static_cast< IfcCartesianTransformationOperator3D * > (allocateIfcCartesianTransformationOperator3D(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCartesianTransformationOperator3D(IfcCartesianTransformationOperator3D *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCartesianTransformationOperator3D_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCartesianTransformationOperator3D(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCartesianTransformationOperator3D *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCartesianTransformationOperator3D(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCartesianTransformationOperator3D_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCartesianTransformationOperator3D > ExpressDataSet::createIfcCartesianTransformationOperator3D(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCartesianTransformationOperator3D(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCartesianTransformationOperator3D * > (allocateIfcCartesianTransformationOperator3D(this, Step::Id_UNSET));
    }
}

IfcCartesianTransformationOperator3D *ExpressDataSet::cloneIfcCartesianTransformationOperator3D(ExpressDataSet *expressDataSet, const IfcCartesianTransformationOperator3D &obj, const CopyOp &copyop)
{
    IfcCartesianTransformationOperator3D *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCartesianTransformationOperator3D(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCartesianTransformationOperator3D_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCartesianTransformationOperator3D *ExpressDataSet::cloneIfcCartesianTransformationOperator3D(const IfcCartesianTransformationOperator3D &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCartesianTransformationOperator3D(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCartesianTransformationOperator3D(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCartesianTransformationOperator3D  > &ExpressDataSet::getAllIfcCartesianTransformationOperator3D ()
{
    return m_refIfcCartesianTransformationOperator3DList;
}



IfcCartesianTransformationOperator3DnonUniform *ExpressDataSet::getIfcCartesianTransformationOperator3DnonUniform(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCartesianTransformationOperator3DnonUniform * > (current->second.get());
    }
    else
    {
        IfcCartesianTransformationOperator3DnonUniform *ret = static_cast< IfcCartesianTransformationOperator3DnonUniform * > (allocateIfcCartesianTransformationOperator3DnonUniform(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCartesianTransformationOperator3DnonUniform(IfcCartesianTransformationOperator3DnonUniform *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCartesianTransformationOperator3DnonUniform_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCartesianTransformationOperator3DnonUniform(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCartesianTransformationOperator3DnonUniform *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCartesianTransformationOperator3DnonUniform(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCartesianTransformationOperator3DnonUniform_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCartesianTransformationOperator3DnonUniform > ExpressDataSet::createIfcCartesianTransformationOperator3DnonUniform(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCartesianTransformationOperator3DnonUniform(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCartesianTransformationOperator3DnonUniform * > (allocateIfcCartesianTransformationOperator3DnonUniform(this, Step::Id_UNSET));
    }
}

IfcCartesianTransformationOperator3DnonUniform *ExpressDataSet::cloneIfcCartesianTransformationOperator3DnonUniform(ExpressDataSet *expressDataSet, const IfcCartesianTransformationOperator3DnonUniform &obj, const CopyOp &copyop)
{
    IfcCartesianTransformationOperator3DnonUniform *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCartesianTransformationOperator3DnonUniform(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCartesianTransformationOperator3DnonUniform_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCartesianTransformationOperator3DnonUniform *ExpressDataSet::cloneIfcCartesianTransformationOperator3DnonUniform(const IfcCartesianTransformationOperator3DnonUniform &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCartesianTransformationOperator3DnonUniform(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCartesianTransformationOperator3DnonUniform(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCartesianTransformationOperator3DnonUniform  > &ExpressDataSet::getAllIfcCartesianTransformationOperator3DnonUniform ()
{
    return m_refIfcCartesianTransformationOperator3DnonUniformList;
}



IfcCenterLineProfileDef *ExpressDataSet::getIfcCenterLineProfileDef(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCenterLineProfileDef * > (current->second.get());
    }
    else
    {
        IfcCenterLineProfileDef *ret = static_cast< IfcCenterLineProfileDef * > (allocateIfcCenterLineProfileDef(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCenterLineProfileDef(IfcCenterLineProfileDef *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCenterLineProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCenterLineProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCenterLineProfileDef *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCenterLineProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCenterLineProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCenterLineProfileDef > ExpressDataSet::createIfcCenterLineProfileDef(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCenterLineProfileDef(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCenterLineProfileDef * > (allocateIfcCenterLineProfileDef(this, Step::Id_UNSET));
    }
}

IfcCenterLineProfileDef *ExpressDataSet::cloneIfcCenterLineProfileDef(ExpressDataSet *expressDataSet, const IfcCenterLineProfileDef &obj, const CopyOp &copyop)
{
    IfcCenterLineProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCenterLineProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCenterLineProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCenterLineProfileDef *ExpressDataSet::cloneIfcCenterLineProfileDef(const IfcCenterLineProfileDef &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCenterLineProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCenterLineProfileDef(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCenterLineProfileDef  > &ExpressDataSet::getAllIfcCenterLineProfileDef ()
{
    return m_refIfcCenterLineProfileDefList;
}



IfcChamferEdgeFeature *ExpressDataSet::getIfcChamferEdgeFeature(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcChamferEdgeFeature * > (current->second.get());
    }
    else
    {
        IfcChamferEdgeFeature *ret = static_cast< IfcChamferEdgeFeature * > (allocateIfcChamferEdgeFeature(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcChamferEdgeFeature(IfcChamferEdgeFeature *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcChamferEdgeFeature_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcChamferEdgeFeature(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcChamferEdgeFeature *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcChamferEdgeFeature(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcChamferEdgeFeature_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcChamferEdgeFeature > ExpressDataSet::createIfcChamferEdgeFeature(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcChamferEdgeFeature(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcChamferEdgeFeature * > (allocateIfcChamferEdgeFeature(this, Step::Id_UNSET));
    }
}

IfcChamferEdgeFeature *ExpressDataSet::cloneIfcChamferEdgeFeature(ExpressDataSet *expressDataSet, const IfcChamferEdgeFeature &obj, const CopyOp &copyop)
{
    IfcChamferEdgeFeature *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcChamferEdgeFeature(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcChamferEdgeFeature_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcChamferEdgeFeature *ExpressDataSet::cloneIfcChamferEdgeFeature(const IfcChamferEdgeFeature &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcChamferEdgeFeature(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcChamferEdgeFeature(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcChamferEdgeFeature  > &ExpressDataSet::getAllIfcChamferEdgeFeature ()
{
    return m_refIfcChamferEdgeFeatureList;
}



IfcChillerType *ExpressDataSet::getIfcChillerType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcChillerType * > (current->second.get());
    }
    else
    {
        IfcChillerType *ret = static_cast< IfcChillerType * > (allocateIfcChillerType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcChillerType(IfcChillerType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcChillerType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcChillerType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcChillerType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcChillerType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcChillerType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcChillerType > ExpressDataSet::createIfcChillerType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcChillerType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcChillerType * > (allocateIfcChillerType(this, Step::Id_UNSET));
    }
}

IfcChillerType *ExpressDataSet::cloneIfcChillerType(ExpressDataSet *expressDataSet, const IfcChillerType &obj, const CopyOp &copyop)
{
    IfcChillerType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcChillerType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcChillerType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcChillerType *ExpressDataSet::cloneIfcChillerType(const IfcChillerType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcChillerType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcChillerType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcChillerType  > &ExpressDataSet::getAllIfcChillerType ()
{
    return m_refIfcChillerTypeList;
}



IfcCircle *ExpressDataSet::getIfcCircle(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCircle * > (current->second.get());
    }
    else
    {
        IfcCircle *ret = static_cast< IfcCircle * > (allocateIfcCircle(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCircle(IfcCircle *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCircle_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCircle(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCircle *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCircle(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCircle_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCircle > ExpressDataSet::createIfcCircle(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCircle(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCircle * > (allocateIfcCircle(this, Step::Id_UNSET));
    }
}

IfcCircle *ExpressDataSet::cloneIfcCircle(ExpressDataSet *expressDataSet, const IfcCircle &obj, const CopyOp &copyop)
{
    IfcCircle *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCircle(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCircle_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCircle *ExpressDataSet::cloneIfcCircle(const IfcCircle &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCircle(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCircle(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCircle  > &ExpressDataSet::getAllIfcCircle ()
{
    return m_refIfcCircleList;
}



IfcCircleHollowProfileDef *ExpressDataSet::getIfcCircleHollowProfileDef(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCircleHollowProfileDef * > (current->second.get());
    }
    else
    {
        IfcCircleHollowProfileDef *ret = static_cast< IfcCircleHollowProfileDef * > (allocateIfcCircleHollowProfileDef(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCircleHollowProfileDef(IfcCircleHollowProfileDef *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCircleHollowProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCircleHollowProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCircleHollowProfileDef *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCircleHollowProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCircleHollowProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCircleHollowProfileDef > ExpressDataSet::createIfcCircleHollowProfileDef(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCircleHollowProfileDef(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCircleHollowProfileDef * > (allocateIfcCircleHollowProfileDef(this, Step::Id_UNSET));
    }
}

IfcCircleHollowProfileDef *ExpressDataSet::cloneIfcCircleHollowProfileDef(ExpressDataSet *expressDataSet, const IfcCircleHollowProfileDef &obj, const CopyOp &copyop)
{
    IfcCircleHollowProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCircleHollowProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCircleHollowProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCircleHollowProfileDef *ExpressDataSet::cloneIfcCircleHollowProfileDef(const IfcCircleHollowProfileDef &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCircleHollowProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCircleHollowProfileDef(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCircleHollowProfileDef  > &ExpressDataSet::getAllIfcCircleHollowProfileDef ()
{
    return m_refIfcCircleHollowProfileDefList;
}



IfcCircleProfileDef *ExpressDataSet::getIfcCircleProfileDef(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCircleProfileDef * > (current->second.get());
    }
    else
    {
        IfcCircleProfileDef *ret = static_cast< IfcCircleProfileDef * > (allocateIfcCircleProfileDef(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCircleProfileDef(IfcCircleProfileDef *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCircleProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCircleProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCircleProfileDef *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCircleProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCircleProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCircleProfileDef > ExpressDataSet::createIfcCircleProfileDef(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCircleProfileDef(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCircleProfileDef * > (allocateIfcCircleProfileDef(this, Step::Id_UNSET));
    }
}

IfcCircleProfileDef *ExpressDataSet::cloneIfcCircleProfileDef(ExpressDataSet *expressDataSet, const IfcCircleProfileDef &obj, const CopyOp &copyop)
{
    IfcCircleProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCircleProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCircleProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCircleProfileDef *ExpressDataSet::cloneIfcCircleProfileDef(const IfcCircleProfileDef &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCircleProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCircleProfileDef(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCircleProfileDef  > &ExpressDataSet::getAllIfcCircleProfileDef ()
{
    return m_refIfcCircleProfileDefList;
}



IfcClassification *ExpressDataSet::getIfcClassification(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcClassification * > (current->second.get());
    }
    else
    {
        IfcClassification *ret = static_cast< IfcClassification * > (allocateIfcClassification(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcClassification(IfcClassification *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcClassification_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcClassification(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcClassification *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcClassification(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcClassification_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcClassification > ExpressDataSet::createIfcClassification(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcClassification(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcClassification * > (allocateIfcClassification(this, Step::Id_UNSET));
    }
}

IfcClassification *ExpressDataSet::cloneIfcClassification(ExpressDataSet *expressDataSet, const IfcClassification &obj, const CopyOp &copyop)
{
    IfcClassification *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcClassification(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcClassification_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcClassification *ExpressDataSet::cloneIfcClassification(const IfcClassification &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcClassification(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcClassification(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcClassification  > &ExpressDataSet::getAllIfcClassification ()
{
    return m_refIfcClassificationList;
}



IfcClassificationItem *ExpressDataSet::getIfcClassificationItem(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcClassificationItem * > (current->second.get());
    }
    else
    {
        IfcClassificationItem *ret = static_cast< IfcClassificationItem * > (allocateIfcClassificationItem(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcClassificationItem(IfcClassificationItem *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcClassificationItem_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcClassificationItem(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcClassificationItem *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcClassificationItem(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcClassificationItem_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcClassificationItem > ExpressDataSet::createIfcClassificationItem(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcClassificationItem(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcClassificationItem * > (allocateIfcClassificationItem(this, Step::Id_UNSET));
    }
}

IfcClassificationItem *ExpressDataSet::cloneIfcClassificationItem(ExpressDataSet *expressDataSet, const IfcClassificationItem &obj, const CopyOp &copyop)
{
    IfcClassificationItem *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcClassificationItem(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcClassificationItem_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcClassificationItem *ExpressDataSet::cloneIfcClassificationItem(const IfcClassificationItem &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcClassificationItem(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcClassificationItem(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcClassificationItem  > &ExpressDataSet::getAllIfcClassificationItem ()
{
    return m_refIfcClassificationItemList;
}



IfcClassificationItemRelationship *ExpressDataSet::getIfcClassificationItemRelationship(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcClassificationItemRelationship * > (current->second.get());
    }
    else
    {
        IfcClassificationItemRelationship *ret = static_cast< IfcClassificationItemRelationship * > (allocateIfcClassificationItemRelationship(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcClassificationItemRelationship(IfcClassificationItemRelationship *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcClassificationItemRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcClassificationItemRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcClassificationItemRelationship *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcClassificationItemRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcClassificationItemRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcClassificationItemRelationship > ExpressDataSet::createIfcClassificationItemRelationship(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcClassificationItemRelationship(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcClassificationItemRelationship * > (allocateIfcClassificationItemRelationship(this, Step::Id_UNSET));
    }
}

IfcClassificationItemRelationship *ExpressDataSet::cloneIfcClassificationItemRelationship(ExpressDataSet *expressDataSet, const IfcClassificationItemRelationship &obj, const CopyOp &copyop)
{
    IfcClassificationItemRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcClassificationItemRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcClassificationItemRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcClassificationItemRelationship *ExpressDataSet::cloneIfcClassificationItemRelationship(const IfcClassificationItemRelationship &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcClassificationItemRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcClassificationItemRelationship(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcClassificationItemRelationship  > &ExpressDataSet::getAllIfcClassificationItemRelationship ()
{
    return m_refIfcClassificationItemRelationshipList;
}



IfcClassificationNotation *ExpressDataSet::getIfcClassificationNotation(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcClassificationNotation * > (current->second.get());
    }
    else
    {
        IfcClassificationNotation *ret = static_cast< IfcClassificationNotation * > (allocateIfcClassificationNotation(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcClassificationNotation(IfcClassificationNotation *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcClassificationNotation_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcClassificationNotation(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcClassificationNotation *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcClassificationNotation(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcClassificationNotation_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcClassificationNotation > ExpressDataSet::createIfcClassificationNotation(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcClassificationNotation(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcClassificationNotation * > (allocateIfcClassificationNotation(this, Step::Id_UNSET));
    }
}

IfcClassificationNotation *ExpressDataSet::cloneIfcClassificationNotation(ExpressDataSet *expressDataSet, const IfcClassificationNotation &obj, const CopyOp &copyop)
{
    IfcClassificationNotation *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcClassificationNotation(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcClassificationNotation_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcClassificationNotation *ExpressDataSet::cloneIfcClassificationNotation(const IfcClassificationNotation &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcClassificationNotation(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcClassificationNotation(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcClassificationNotation  > &ExpressDataSet::getAllIfcClassificationNotation ()
{
    return m_refIfcClassificationNotationList;
}



IfcClassificationNotationFacet *ExpressDataSet::getIfcClassificationNotationFacet(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcClassificationNotationFacet * > (current->second.get());
    }
    else
    {
        IfcClassificationNotationFacet *ret = static_cast< IfcClassificationNotationFacet * > (allocateIfcClassificationNotationFacet(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcClassificationNotationFacet(IfcClassificationNotationFacet *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcClassificationNotationFacet_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcClassificationNotationFacet(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcClassificationNotationFacet *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcClassificationNotationFacet(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcClassificationNotationFacet_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcClassificationNotationFacet > ExpressDataSet::createIfcClassificationNotationFacet(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcClassificationNotationFacet(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcClassificationNotationFacet * > (allocateIfcClassificationNotationFacet(this, Step::Id_UNSET));
    }
}

IfcClassificationNotationFacet *ExpressDataSet::cloneIfcClassificationNotationFacet(ExpressDataSet *expressDataSet, const IfcClassificationNotationFacet &obj, const CopyOp &copyop)
{
    IfcClassificationNotationFacet *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcClassificationNotationFacet(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcClassificationNotationFacet_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcClassificationNotationFacet *ExpressDataSet::cloneIfcClassificationNotationFacet(const IfcClassificationNotationFacet &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcClassificationNotationFacet(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcClassificationNotationFacet(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcClassificationNotationFacet  > &ExpressDataSet::getAllIfcClassificationNotationFacet ()
{
    return m_refIfcClassificationNotationFacetList;
}



IfcClassificationReference *ExpressDataSet::getIfcClassificationReference(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcClassificationReference * > (current->second.get());
    }
    else
    {
        IfcClassificationReference *ret = static_cast< IfcClassificationReference * > (allocateIfcClassificationReference(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcClassificationReference(IfcClassificationReference *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcClassificationReference_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcClassificationReference(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcClassificationReference *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcClassificationReference(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcClassificationReference_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcClassificationReference > ExpressDataSet::createIfcClassificationReference(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcClassificationReference(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcClassificationReference * > (allocateIfcClassificationReference(this, Step::Id_UNSET));
    }
}

IfcClassificationReference *ExpressDataSet::cloneIfcClassificationReference(ExpressDataSet *expressDataSet, const IfcClassificationReference &obj, const CopyOp &copyop)
{
    IfcClassificationReference *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcClassificationReference(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcClassificationReference_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcClassificationReference *ExpressDataSet::cloneIfcClassificationReference(const IfcClassificationReference &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcClassificationReference(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcClassificationReference(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcClassificationReference  > &ExpressDataSet::getAllIfcClassificationReference ()
{
    return m_refIfcClassificationReferenceList;
}



IfcClosedShell *ExpressDataSet::getIfcClosedShell(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcClosedShell * > (current->second.get());
    }
    else
    {
        IfcClosedShell *ret = static_cast< IfcClosedShell * > (allocateIfcClosedShell(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcClosedShell(IfcClosedShell *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcClosedShell_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcClosedShell(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcClosedShell *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcClosedShell(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcClosedShell_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcClosedShell > ExpressDataSet::createIfcClosedShell(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcClosedShell(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcClosedShell * > (allocateIfcClosedShell(this, Step::Id_UNSET));
    }
}

IfcClosedShell *ExpressDataSet::cloneIfcClosedShell(ExpressDataSet *expressDataSet, const IfcClosedShell &obj, const CopyOp &copyop)
{
    IfcClosedShell *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcClosedShell(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcClosedShell_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcClosedShell *ExpressDataSet::cloneIfcClosedShell(const IfcClosedShell &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcClosedShell(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcClosedShell(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcClosedShell  > &ExpressDataSet::getAllIfcClosedShell ()
{
    return m_refIfcClosedShellList;
}



IfcCoilType *ExpressDataSet::getIfcCoilType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCoilType * > (current->second.get());
    }
    else
    {
        IfcCoilType *ret = static_cast< IfcCoilType * > (allocateIfcCoilType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCoilType(IfcCoilType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCoilType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCoilType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCoilType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCoilType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCoilType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCoilType > ExpressDataSet::createIfcCoilType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCoilType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCoilType * > (allocateIfcCoilType(this, Step::Id_UNSET));
    }
}

IfcCoilType *ExpressDataSet::cloneIfcCoilType(ExpressDataSet *expressDataSet, const IfcCoilType &obj, const CopyOp &copyop)
{
    IfcCoilType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCoilType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCoilType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCoilType *ExpressDataSet::cloneIfcCoilType(const IfcCoilType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCoilType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCoilType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCoilType  > &ExpressDataSet::getAllIfcCoilType ()
{
    return m_refIfcCoilTypeList;
}



IfcColourRgb *ExpressDataSet::getIfcColourRgb(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcColourRgb * > (current->second.get());
    }
    else
    {
        IfcColourRgb *ret = static_cast< IfcColourRgb * > (allocateIfcColourRgb(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcColourRgb(IfcColourRgb *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcColourRgb_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcColourRgb(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcColourRgb *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcColourRgb(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcColourRgb_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcColourRgb > ExpressDataSet::createIfcColourRgb(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcColourRgb(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcColourRgb * > (allocateIfcColourRgb(this, Step::Id_UNSET));
    }
}

IfcColourRgb *ExpressDataSet::cloneIfcColourRgb(ExpressDataSet *expressDataSet, const IfcColourRgb &obj, const CopyOp &copyop)
{
    IfcColourRgb *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcColourRgb(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcColourRgb_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcColourRgb *ExpressDataSet::cloneIfcColourRgb(const IfcColourRgb &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcColourRgb(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcColourRgb(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcColourRgb  > &ExpressDataSet::getAllIfcColourRgb ()
{
    return m_refIfcColourRgbList;
}



IfcColourSpecification *ExpressDataSet::getIfcColourSpecification(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcColourSpecification * > (current->second.get());
    }
    else
    {
        IfcColourSpecification *ret = static_cast< IfcColourSpecification * > (allocateIfcColourSpecification(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcColourSpecification(IfcColourSpecification *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcColourSpecification_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcColourSpecification(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcColourSpecification *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcColourSpecification(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcColourSpecification_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcColourSpecification > ExpressDataSet::createIfcColourSpecification(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcColourSpecification(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcColourSpecification * > (allocateIfcColourSpecification(this, Step::Id_UNSET));
    }
}

IfcColourSpecification *ExpressDataSet::cloneIfcColourSpecification(ExpressDataSet *expressDataSet, const IfcColourSpecification &obj, const CopyOp &copyop)
{
    IfcColourSpecification *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcColourSpecification(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcColourSpecification_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcColourSpecification *ExpressDataSet::cloneIfcColourSpecification(const IfcColourSpecification &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcColourSpecification(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcColourSpecification(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcColourSpecification  > &ExpressDataSet::getAllIfcColourSpecification ()
{
    return m_refIfcColourSpecificationList;
}



IfcColumn *ExpressDataSet::getIfcColumn(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcColumn * > (current->second.get());
    }
    else
    {
        IfcColumn *ret = static_cast< IfcColumn * > (allocateIfcColumn(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcColumn(IfcColumn *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcColumn_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcColumn(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcColumn *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcColumn(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcColumn_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcColumn > ExpressDataSet::createIfcColumn(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcColumn(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcColumn * > (allocateIfcColumn(this, Step::Id_UNSET));
    }
}

IfcColumn *ExpressDataSet::cloneIfcColumn(ExpressDataSet *expressDataSet, const IfcColumn &obj, const CopyOp &copyop)
{
    IfcColumn *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcColumn(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcColumn_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcColumn *ExpressDataSet::cloneIfcColumn(const IfcColumn &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcColumn(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcColumn(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcColumn  > &ExpressDataSet::getAllIfcColumn ()
{
    return m_refIfcColumnList;
}



IfcColumnType *ExpressDataSet::getIfcColumnType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcColumnType * > (current->second.get());
    }
    else
    {
        IfcColumnType *ret = static_cast< IfcColumnType * > (allocateIfcColumnType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcColumnType(IfcColumnType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcColumnType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcColumnType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcColumnType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcColumnType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcColumnType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcColumnType > ExpressDataSet::createIfcColumnType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcColumnType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcColumnType * > (allocateIfcColumnType(this, Step::Id_UNSET));
    }
}

IfcColumnType *ExpressDataSet::cloneIfcColumnType(ExpressDataSet *expressDataSet, const IfcColumnType &obj, const CopyOp &copyop)
{
    IfcColumnType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcColumnType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcColumnType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcColumnType *ExpressDataSet::cloneIfcColumnType(const IfcColumnType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcColumnType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcColumnType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcColumnType  > &ExpressDataSet::getAllIfcColumnType ()
{
    return m_refIfcColumnTypeList;
}



IfcComplexProperty *ExpressDataSet::getIfcComplexProperty(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcComplexProperty * > (current->second.get());
    }
    else
    {
        IfcComplexProperty *ret = static_cast< IfcComplexProperty * > (allocateIfcComplexProperty(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcComplexProperty(IfcComplexProperty *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcComplexProperty_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcComplexProperty(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcComplexProperty *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcComplexProperty(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcComplexProperty_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcComplexProperty > ExpressDataSet::createIfcComplexProperty(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcComplexProperty(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcComplexProperty * > (allocateIfcComplexProperty(this, Step::Id_UNSET));
    }
}

IfcComplexProperty *ExpressDataSet::cloneIfcComplexProperty(ExpressDataSet *expressDataSet, const IfcComplexProperty &obj, const CopyOp &copyop)
{
    IfcComplexProperty *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcComplexProperty(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcComplexProperty_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcComplexProperty *ExpressDataSet::cloneIfcComplexProperty(const IfcComplexProperty &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcComplexProperty(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcComplexProperty(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcComplexProperty  > &ExpressDataSet::getAllIfcComplexProperty ()
{
    return m_refIfcComplexPropertyList;
}



IfcCompositeCurve *ExpressDataSet::getIfcCompositeCurve(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCompositeCurve * > (current->second.get());
    }
    else
    {
        IfcCompositeCurve *ret = static_cast< IfcCompositeCurve * > (allocateIfcCompositeCurve(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCompositeCurve(IfcCompositeCurve *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCompositeCurve_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCompositeCurve(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCompositeCurve *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCompositeCurve(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCompositeCurve_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCompositeCurve > ExpressDataSet::createIfcCompositeCurve(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCompositeCurve(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCompositeCurve * > (allocateIfcCompositeCurve(this, Step::Id_UNSET));
    }
}

IfcCompositeCurve *ExpressDataSet::cloneIfcCompositeCurve(ExpressDataSet *expressDataSet, const IfcCompositeCurve &obj, const CopyOp &copyop)
{
    IfcCompositeCurve *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCompositeCurve(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCompositeCurve_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCompositeCurve *ExpressDataSet::cloneIfcCompositeCurve(const IfcCompositeCurve &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCompositeCurve(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCompositeCurve(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCompositeCurve  > &ExpressDataSet::getAllIfcCompositeCurve ()
{
    return m_refIfcCompositeCurveList;
}



IfcCompositeCurveSegment *ExpressDataSet::getIfcCompositeCurveSegment(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCompositeCurveSegment * > (current->second.get());
    }
    else
    {
        IfcCompositeCurveSegment *ret = static_cast< IfcCompositeCurveSegment * > (allocateIfcCompositeCurveSegment(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCompositeCurveSegment(IfcCompositeCurveSegment *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCompositeCurveSegment_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCompositeCurveSegment(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCompositeCurveSegment *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCompositeCurveSegment(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCompositeCurveSegment_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCompositeCurveSegment > ExpressDataSet::createIfcCompositeCurveSegment(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCompositeCurveSegment(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCompositeCurveSegment * > (allocateIfcCompositeCurveSegment(this, Step::Id_UNSET));
    }
}

IfcCompositeCurveSegment *ExpressDataSet::cloneIfcCompositeCurveSegment(ExpressDataSet *expressDataSet, const IfcCompositeCurveSegment &obj, const CopyOp &copyop)
{
    IfcCompositeCurveSegment *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCompositeCurveSegment(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCompositeCurveSegment_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCompositeCurveSegment *ExpressDataSet::cloneIfcCompositeCurveSegment(const IfcCompositeCurveSegment &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCompositeCurveSegment(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCompositeCurveSegment(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCompositeCurveSegment  > &ExpressDataSet::getAllIfcCompositeCurveSegment ()
{
    return m_refIfcCompositeCurveSegmentList;
}



IfcCompositeProfileDef *ExpressDataSet::getIfcCompositeProfileDef(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCompositeProfileDef * > (current->second.get());
    }
    else
    {
        IfcCompositeProfileDef *ret = static_cast< IfcCompositeProfileDef * > (allocateIfcCompositeProfileDef(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCompositeProfileDef(IfcCompositeProfileDef *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCompositeProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCompositeProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCompositeProfileDef *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCompositeProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCompositeProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCompositeProfileDef > ExpressDataSet::createIfcCompositeProfileDef(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCompositeProfileDef(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCompositeProfileDef * > (allocateIfcCompositeProfileDef(this, Step::Id_UNSET));
    }
}

IfcCompositeProfileDef *ExpressDataSet::cloneIfcCompositeProfileDef(ExpressDataSet *expressDataSet, const IfcCompositeProfileDef &obj, const CopyOp &copyop)
{
    IfcCompositeProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCompositeProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCompositeProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCompositeProfileDef *ExpressDataSet::cloneIfcCompositeProfileDef(const IfcCompositeProfileDef &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCompositeProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCompositeProfileDef(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCompositeProfileDef  > &ExpressDataSet::getAllIfcCompositeProfileDef ()
{
    return m_refIfcCompositeProfileDefList;
}



IfcCompressorType *ExpressDataSet::getIfcCompressorType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCompressorType * > (current->second.get());
    }
    else
    {
        IfcCompressorType *ret = static_cast< IfcCompressorType * > (allocateIfcCompressorType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCompressorType(IfcCompressorType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCompressorType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCompressorType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCompressorType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCompressorType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCompressorType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCompressorType > ExpressDataSet::createIfcCompressorType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCompressorType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCompressorType * > (allocateIfcCompressorType(this, Step::Id_UNSET));
    }
}

IfcCompressorType *ExpressDataSet::cloneIfcCompressorType(ExpressDataSet *expressDataSet, const IfcCompressorType &obj, const CopyOp &copyop)
{
    IfcCompressorType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCompressorType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCompressorType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCompressorType *ExpressDataSet::cloneIfcCompressorType(const IfcCompressorType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCompressorType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCompressorType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCompressorType  > &ExpressDataSet::getAllIfcCompressorType ()
{
    return m_refIfcCompressorTypeList;
}



IfcCondenserType *ExpressDataSet::getIfcCondenserType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCondenserType * > (current->second.get());
    }
    else
    {
        IfcCondenserType *ret = static_cast< IfcCondenserType * > (allocateIfcCondenserType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCondenserType(IfcCondenserType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCondenserType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCondenserType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCondenserType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCondenserType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCondenserType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCondenserType > ExpressDataSet::createIfcCondenserType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCondenserType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCondenserType * > (allocateIfcCondenserType(this, Step::Id_UNSET));
    }
}

IfcCondenserType *ExpressDataSet::cloneIfcCondenserType(ExpressDataSet *expressDataSet, const IfcCondenserType &obj, const CopyOp &copyop)
{
    IfcCondenserType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCondenserType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCondenserType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCondenserType *ExpressDataSet::cloneIfcCondenserType(const IfcCondenserType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCondenserType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCondenserType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCondenserType  > &ExpressDataSet::getAllIfcCondenserType ()
{
    return m_refIfcCondenserTypeList;
}



IfcCondition *ExpressDataSet::getIfcCondition(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCondition * > (current->second.get());
    }
    else
    {
        IfcCondition *ret = static_cast< IfcCondition * > (allocateIfcCondition(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCondition(IfcCondition *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCondition_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCondition(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCondition *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCondition(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCondition_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCondition > ExpressDataSet::createIfcCondition(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCondition(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCondition * > (allocateIfcCondition(this, Step::Id_UNSET));
    }
}

IfcCondition *ExpressDataSet::cloneIfcCondition(ExpressDataSet *expressDataSet, const IfcCondition &obj, const CopyOp &copyop)
{
    IfcCondition *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCondition(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCondition_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCondition *ExpressDataSet::cloneIfcCondition(const IfcCondition &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCondition(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCondition(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCondition  > &ExpressDataSet::getAllIfcCondition ()
{
    return m_refIfcConditionList;
}



IfcConditionCriterion *ExpressDataSet::getIfcConditionCriterion(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcConditionCriterion * > (current->second.get());
    }
    else
    {
        IfcConditionCriterion *ret = static_cast< IfcConditionCriterion * > (allocateIfcConditionCriterion(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcConditionCriterion(IfcConditionCriterion *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcConditionCriterion_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConditionCriterion(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcConditionCriterion *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConditionCriterion(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConditionCriterion_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConditionCriterion > ExpressDataSet::createIfcConditionCriterion(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcConditionCriterion(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcConditionCriterion * > (allocateIfcConditionCriterion(this, Step::Id_UNSET));
    }
}

IfcConditionCriterion *ExpressDataSet::cloneIfcConditionCriterion(ExpressDataSet *expressDataSet, const IfcConditionCriterion &obj, const CopyOp &copyop)
{
    IfcConditionCriterion *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConditionCriterion(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConditionCriterion_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConditionCriterion *ExpressDataSet::cloneIfcConditionCriterion(const IfcConditionCriterion &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcConditionCriterion(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcConditionCriterion(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcConditionCriterion  > &ExpressDataSet::getAllIfcConditionCriterion ()
{
    return m_refIfcConditionCriterionList;
}



IfcConic *ExpressDataSet::getIfcConic(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcConic * > (current->second.get());
    }
    else
    {
        IfcConic *ret = static_cast< IfcConic * > (allocateIfcConic(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcConic(IfcConic *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcConic_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConic(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcConic *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConic(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConic_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConic > ExpressDataSet::createIfcConic(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcConic(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcConic * > (allocateIfcConic(this, Step::Id_UNSET));
    }
}

IfcConic *ExpressDataSet::cloneIfcConic(ExpressDataSet *expressDataSet, const IfcConic &obj, const CopyOp &copyop)
{
    IfcConic *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConic(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConic_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConic *ExpressDataSet::cloneIfcConic(const IfcConic &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcConic(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcConic(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcConic  > &ExpressDataSet::getAllIfcConic ()
{
    return m_refIfcConicList;
}



IfcConnectedFaceSet *ExpressDataSet::getIfcConnectedFaceSet(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcConnectedFaceSet * > (current->second.get());
    }
    else
    {
        IfcConnectedFaceSet *ret = static_cast< IfcConnectedFaceSet * > (allocateIfcConnectedFaceSet(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcConnectedFaceSet(IfcConnectedFaceSet *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcConnectedFaceSet_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConnectedFaceSet(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcConnectedFaceSet *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConnectedFaceSet(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConnectedFaceSet_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConnectedFaceSet > ExpressDataSet::createIfcConnectedFaceSet(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcConnectedFaceSet(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcConnectedFaceSet * > (allocateIfcConnectedFaceSet(this, Step::Id_UNSET));
    }
}

IfcConnectedFaceSet *ExpressDataSet::cloneIfcConnectedFaceSet(ExpressDataSet *expressDataSet, const IfcConnectedFaceSet &obj, const CopyOp &copyop)
{
    IfcConnectedFaceSet *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConnectedFaceSet(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConnectedFaceSet_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConnectedFaceSet *ExpressDataSet::cloneIfcConnectedFaceSet(const IfcConnectedFaceSet &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcConnectedFaceSet(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcConnectedFaceSet(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcConnectedFaceSet  > &ExpressDataSet::getAllIfcConnectedFaceSet ()
{
    return m_refIfcConnectedFaceSetList;
}



IfcConnectionCurveGeometry *ExpressDataSet::getIfcConnectionCurveGeometry(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcConnectionCurveGeometry * > (current->second.get());
    }
    else
    {
        IfcConnectionCurveGeometry *ret = static_cast< IfcConnectionCurveGeometry * > (allocateIfcConnectionCurveGeometry(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcConnectionCurveGeometry(IfcConnectionCurveGeometry *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcConnectionCurveGeometry_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConnectionCurveGeometry(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcConnectionCurveGeometry *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConnectionCurveGeometry(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConnectionCurveGeometry_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConnectionCurveGeometry > ExpressDataSet::createIfcConnectionCurveGeometry(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcConnectionCurveGeometry(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcConnectionCurveGeometry * > (allocateIfcConnectionCurveGeometry(this, Step::Id_UNSET));
    }
}

IfcConnectionCurveGeometry *ExpressDataSet::cloneIfcConnectionCurveGeometry(ExpressDataSet *expressDataSet, const IfcConnectionCurveGeometry &obj, const CopyOp &copyop)
{
    IfcConnectionCurveGeometry *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConnectionCurveGeometry(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConnectionCurveGeometry_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConnectionCurveGeometry *ExpressDataSet::cloneIfcConnectionCurveGeometry(const IfcConnectionCurveGeometry &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcConnectionCurveGeometry(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcConnectionCurveGeometry(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcConnectionCurveGeometry  > &ExpressDataSet::getAllIfcConnectionCurveGeometry ()
{
    return m_refIfcConnectionCurveGeometryList;
}



IfcConnectionGeometry *ExpressDataSet::getIfcConnectionGeometry(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcConnectionGeometry * > (current->second.get());
    }
    else
    {
        IfcConnectionGeometry *ret = static_cast< IfcConnectionGeometry * > (allocateIfcConnectionGeometry(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcConnectionGeometry(IfcConnectionGeometry *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcConnectionGeometry_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConnectionGeometry(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcConnectionGeometry *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConnectionGeometry(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConnectionGeometry_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConnectionGeometry > ExpressDataSet::createIfcConnectionGeometry(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcConnectionGeometry(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcConnectionGeometry * > (allocateIfcConnectionGeometry(this, Step::Id_UNSET));
    }
}

IfcConnectionGeometry *ExpressDataSet::cloneIfcConnectionGeometry(ExpressDataSet *expressDataSet, const IfcConnectionGeometry &obj, const CopyOp &copyop)
{
    IfcConnectionGeometry *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConnectionGeometry(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConnectionGeometry_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConnectionGeometry *ExpressDataSet::cloneIfcConnectionGeometry(const IfcConnectionGeometry &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcConnectionGeometry(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcConnectionGeometry(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcConnectionGeometry  > &ExpressDataSet::getAllIfcConnectionGeometry ()
{
    return m_refIfcConnectionGeometryList;
}



IfcConnectionPointEccentricity *ExpressDataSet::getIfcConnectionPointEccentricity(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcConnectionPointEccentricity * > (current->second.get());
    }
    else
    {
        IfcConnectionPointEccentricity *ret = static_cast< IfcConnectionPointEccentricity * > (allocateIfcConnectionPointEccentricity(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcConnectionPointEccentricity(IfcConnectionPointEccentricity *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcConnectionPointEccentricity_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConnectionPointEccentricity(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcConnectionPointEccentricity *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConnectionPointEccentricity(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConnectionPointEccentricity_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConnectionPointEccentricity > ExpressDataSet::createIfcConnectionPointEccentricity(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcConnectionPointEccentricity(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcConnectionPointEccentricity * > (allocateIfcConnectionPointEccentricity(this, Step::Id_UNSET));
    }
}

IfcConnectionPointEccentricity *ExpressDataSet::cloneIfcConnectionPointEccentricity(ExpressDataSet *expressDataSet, const IfcConnectionPointEccentricity &obj, const CopyOp &copyop)
{
    IfcConnectionPointEccentricity *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConnectionPointEccentricity(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConnectionPointEccentricity_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConnectionPointEccentricity *ExpressDataSet::cloneIfcConnectionPointEccentricity(const IfcConnectionPointEccentricity &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcConnectionPointEccentricity(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcConnectionPointEccentricity(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcConnectionPointEccentricity  > &ExpressDataSet::getAllIfcConnectionPointEccentricity ()
{
    return m_refIfcConnectionPointEccentricityList;
}



IfcConnectionPointGeometry *ExpressDataSet::getIfcConnectionPointGeometry(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcConnectionPointGeometry * > (current->second.get());
    }
    else
    {
        IfcConnectionPointGeometry *ret = static_cast< IfcConnectionPointGeometry * > (allocateIfcConnectionPointGeometry(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcConnectionPointGeometry(IfcConnectionPointGeometry *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcConnectionPointGeometry_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConnectionPointGeometry(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcConnectionPointGeometry *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConnectionPointGeometry(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConnectionPointGeometry_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConnectionPointGeometry > ExpressDataSet::createIfcConnectionPointGeometry(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcConnectionPointGeometry(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcConnectionPointGeometry * > (allocateIfcConnectionPointGeometry(this, Step::Id_UNSET));
    }
}

IfcConnectionPointGeometry *ExpressDataSet::cloneIfcConnectionPointGeometry(ExpressDataSet *expressDataSet, const IfcConnectionPointGeometry &obj, const CopyOp &copyop)
{
    IfcConnectionPointGeometry *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConnectionPointGeometry(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConnectionPointGeometry_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConnectionPointGeometry *ExpressDataSet::cloneIfcConnectionPointGeometry(const IfcConnectionPointGeometry &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcConnectionPointGeometry(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcConnectionPointGeometry(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcConnectionPointGeometry  > &ExpressDataSet::getAllIfcConnectionPointGeometry ()
{
    return m_refIfcConnectionPointGeometryList;
}



IfcConnectionPortGeometry *ExpressDataSet::getIfcConnectionPortGeometry(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcConnectionPortGeometry * > (current->second.get());
    }
    else
    {
        IfcConnectionPortGeometry *ret = static_cast< IfcConnectionPortGeometry * > (allocateIfcConnectionPortGeometry(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcConnectionPortGeometry(IfcConnectionPortGeometry *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcConnectionPortGeometry_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConnectionPortGeometry(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcConnectionPortGeometry *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConnectionPortGeometry(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConnectionPortGeometry_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConnectionPortGeometry > ExpressDataSet::createIfcConnectionPortGeometry(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcConnectionPortGeometry(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcConnectionPortGeometry * > (allocateIfcConnectionPortGeometry(this, Step::Id_UNSET));
    }
}

IfcConnectionPortGeometry *ExpressDataSet::cloneIfcConnectionPortGeometry(ExpressDataSet *expressDataSet, const IfcConnectionPortGeometry &obj, const CopyOp &copyop)
{
    IfcConnectionPortGeometry *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConnectionPortGeometry(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConnectionPortGeometry_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConnectionPortGeometry *ExpressDataSet::cloneIfcConnectionPortGeometry(const IfcConnectionPortGeometry &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcConnectionPortGeometry(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcConnectionPortGeometry(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcConnectionPortGeometry  > &ExpressDataSet::getAllIfcConnectionPortGeometry ()
{
    return m_refIfcConnectionPortGeometryList;
}



IfcConnectionSurfaceGeometry *ExpressDataSet::getIfcConnectionSurfaceGeometry(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcConnectionSurfaceGeometry * > (current->second.get());
    }
    else
    {
        IfcConnectionSurfaceGeometry *ret = static_cast< IfcConnectionSurfaceGeometry * > (allocateIfcConnectionSurfaceGeometry(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcConnectionSurfaceGeometry(IfcConnectionSurfaceGeometry *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcConnectionSurfaceGeometry_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConnectionSurfaceGeometry(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcConnectionSurfaceGeometry *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConnectionSurfaceGeometry(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConnectionSurfaceGeometry_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConnectionSurfaceGeometry > ExpressDataSet::createIfcConnectionSurfaceGeometry(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcConnectionSurfaceGeometry(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcConnectionSurfaceGeometry * > (allocateIfcConnectionSurfaceGeometry(this, Step::Id_UNSET));
    }
}

IfcConnectionSurfaceGeometry *ExpressDataSet::cloneIfcConnectionSurfaceGeometry(ExpressDataSet *expressDataSet, const IfcConnectionSurfaceGeometry &obj, const CopyOp &copyop)
{
    IfcConnectionSurfaceGeometry *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConnectionSurfaceGeometry(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConnectionSurfaceGeometry_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConnectionSurfaceGeometry *ExpressDataSet::cloneIfcConnectionSurfaceGeometry(const IfcConnectionSurfaceGeometry &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcConnectionSurfaceGeometry(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcConnectionSurfaceGeometry(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcConnectionSurfaceGeometry  > &ExpressDataSet::getAllIfcConnectionSurfaceGeometry ()
{
    return m_refIfcConnectionSurfaceGeometryList;
}



IfcConstraint *ExpressDataSet::getIfcConstraint(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcConstraint * > (current->second.get());
    }
    else
    {
        IfcConstraint *ret = static_cast< IfcConstraint * > (allocateIfcConstraint(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcConstraint(IfcConstraint *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcConstraint_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConstraint(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcConstraint *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConstraint(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConstraint_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConstraint > ExpressDataSet::createIfcConstraint(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcConstraint(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcConstraint * > (allocateIfcConstraint(this, Step::Id_UNSET));
    }
}

IfcConstraint *ExpressDataSet::cloneIfcConstraint(ExpressDataSet *expressDataSet, const IfcConstraint &obj, const CopyOp &copyop)
{
    IfcConstraint *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConstraint(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConstraint_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConstraint *ExpressDataSet::cloneIfcConstraint(const IfcConstraint &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcConstraint(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcConstraint(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcConstraint  > &ExpressDataSet::getAllIfcConstraint ()
{
    return m_refIfcConstraintList;
}



IfcConstraintAggregationRelationship *ExpressDataSet::getIfcConstraintAggregationRelationship(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcConstraintAggregationRelationship * > (current->second.get());
    }
    else
    {
        IfcConstraintAggregationRelationship *ret = static_cast< IfcConstraintAggregationRelationship * > (allocateIfcConstraintAggregationRelationship(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcConstraintAggregationRelationship(IfcConstraintAggregationRelationship *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcConstraintAggregationRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConstraintAggregationRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcConstraintAggregationRelationship *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConstraintAggregationRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConstraintAggregationRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConstraintAggregationRelationship > ExpressDataSet::createIfcConstraintAggregationRelationship(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcConstraintAggregationRelationship(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcConstraintAggregationRelationship * > (allocateIfcConstraintAggregationRelationship(this, Step::Id_UNSET));
    }
}

IfcConstraintAggregationRelationship *ExpressDataSet::cloneIfcConstraintAggregationRelationship(ExpressDataSet *expressDataSet, const IfcConstraintAggregationRelationship &obj, const CopyOp &copyop)
{
    IfcConstraintAggregationRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConstraintAggregationRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConstraintAggregationRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConstraintAggregationRelationship *ExpressDataSet::cloneIfcConstraintAggregationRelationship(const IfcConstraintAggregationRelationship &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcConstraintAggregationRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcConstraintAggregationRelationship(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcConstraintAggregationRelationship  > &ExpressDataSet::getAllIfcConstraintAggregationRelationship ()
{
    return m_refIfcConstraintAggregationRelationshipList;
}



IfcConstraintClassificationRelationship *ExpressDataSet::getIfcConstraintClassificationRelationship(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcConstraintClassificationRelationship * > (current->second.get());
    }
    else
    {
        IfcConstraintClassificationRelationship *ret = static_cast< IfcConstraintClassificationRelationship * > (allocateIfcConstraintClassificationRelationship(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcConstraintClassificationRelationship(IfcConstraintClassificationRelationship *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcConstraintClassificationRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConstraintClassificationRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcConstraintClassificationRelationship *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConstraintClassificationRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConstraintClassificationRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConstraintClassificationRelationship > ExpressDataSet::createIfcConstraintClassificationRelationship(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcConstraintClassificationRelationship(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcConstraintClassificationRelationship * > (allocateIfcConstraintClassificationRelationship(this, Step::Id_UNSET));
    }
}

IfcConstraintClassificationRelationship *ExpressDataSet::cloneIfcConstraintClassificationRelationship(ExpressDataSet *expressDataSet, const IfcConstraintClassificationRelationship &obj, const CopyOp &copyop)
{
    IfcConstraintClassificationRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConstraintClassificationRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConstraintClassificationRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConstraintClassificationRelationship *ExpressDataSet::cloneIfcConstraintClassificationRelationship(const IfcConstraintClassificationRelationship &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcConstraintClassificationRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcConstraintClassificationRelationship(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcConstraintClassificationRelationship  > &ExpressDataSet::getAllIfcConstraintClassificationRelationship ()
{
    return m_refIfcConstraintClassificationRelationshipList;
}



IfcConstraintRelationship *ExpressDataSet::getIfcConstraintRelationship(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcConstraintRelationship * > (current->second.get());
    }
    else
    {
        IfcConstraintRelationship *ret = static_cast< IfcConstraintRelationship * > (allocateIfcConstraintRelationship(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcConstraintRelationship(IfcConstraintRelationship *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcConstraintRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConstraintRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcConstraintRelationship *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConstraintRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConstraintRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConstraintRelationship > ExpressDataSet::createIfcConstraintRelationship(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcConstraintRelationship(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcConstraintRelationship * > (allocateIfcConstraintRelationship(this, Step::Id_UNSET));
    }
}

IfcConstraintRelationship *ExpressDataSet::cloneIfcConstraintRelationship(ExpressDataSet *expressDataSet, const IfcConstraintRelationship &obj, const CopyOp &copyop)
{
    IfcConstraintRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConstraintRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConstraintRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConstraintRelationship *ExpressDataSet::cloneIfcConstraintRelationship(const IfcConstraintRelationship &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcConstraintRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcConstraintRelationship(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcConstraintRelationship  > &ExpressDataSet::getAllIfcConstraintRelationship ()
{
    return m_refIfcConstraintRelationshipList;
}



IfcConstructionEquipmentResource *ExpressDataSet::getIfcConstructionEquipmentResource(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcConstructionEquipmentResource * > (current->second.get());
    }
    else
    {
        IfcConstructionEquipmentResource *ret = static_cast< IfcConstructionEquipmentResource * > (allocateIfcConstructionEquipmentResource(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcConstructionEquipmentResource(IfcConstructionEquipmentResource *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcConstructionEquipmentResource_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConstructionEquipmentResource(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcConstructionEquipmentResource *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConstructionEquipmentResource(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConstructionEquipmentResource_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConstructionEquipmentResource > ExpressDataSet::createIfcConstructionEquipmentResource(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcConstructionEquipmentResource(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcConstructionEquipmentResource * > (allocateIfcConstructionEquipmentResource(this, Step::Id_UNSET));
    }
}

IfcConstructionEquipmentResource *ExpressDataSet::cloneIfcConstructionEquipmentResource(ExpressDataSet *expressDataSet, const IfcConstructionEquipmentResource &obj, const CopyOp &copyop)
{
    IfcConstructionEquipmentResource *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConstructionEquipmentResource(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConstructionEquipmentResource_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConstructionEquipmentResource *ExpressDataSet::cloneIfcConstructionEquipmentResource(const IfcConstructionEquipmentResource &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcConstructionEquipmentResource(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcConstructionEquipmentResource(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcConstructionEquipmentResource  > &ExpressDataSet::getAllIfcConstructionEquipmentResource ()
{
    return m_refIfcConstructionEquipmentResourceList;
}



IfcConstructionMaterialResource *ExpressDataSet::getIfcConstructionMaterialResource(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcConstructionMaterialResource * > (current->second.get());
    }
    else
    {
        IfcConstructionMaterialResource *ret = static_cast< IfcConstructionMaterialResource * > (allocateIfcConstructionMaterialResource(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcConstructionMaterialResource(IfcConstructionMaterialResource *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcConstructionMaterialResource_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConstructionMaterialResource(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcConstructionMaterialResource *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConstructionMaterialResource(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConstructionMaterialResource_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConstructionMaterialResource > ExpressDataSet::createIfcConstructionMaterialResource(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcConstructionMaterialResource(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcConstructionMaterialResource * > (allocateIfcConstructionMaterialResource(this, Step::Id_UNSET));
    }
}

IfcConstructionMaterialResource *ExpressDataSet::cloneIfcConstructionMaterialResource(ExpressDataSet *expressDataSet, const IfcConstructionMaterialResource &obj, const CopyOp &copyop)
{
    IfcConstructionMaterialResource *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConstructionMaterialResource(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConstructionMaterialResource_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConstructionMaterialResource *ExpressDataSet::cloneIfcConstructionMaterialResource(const IfcConstructionMaterialResource &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcConstructionMaterialResource(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcConstructionMaterialResource(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcConstructionMaterialResource  > &ExpressDataSet::getAllIfcConstructionMaterialResource ()
{
    return m_refIfcConstructionMaterialResourceList;
}



IfcConstructionProductResource *ExpressDataSet::getIfcConstructionProductResource(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcConstructionProductResource * > (current->second.get());
    }
    else
    {
        IfcConstructionProductResource *ret = static_cast< IfcConstructionProductResource * > (allocateIfcConstructionProductResource(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcConstructionProductResource(IfcConstructionProductResource *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcConstructionProductResource_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConstructionProductResource(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcConstructionProductResource *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConstructionProductResource(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConstructionProductResource_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConstructionProductResource > ExpressDataSet::createIfcConstructionProductResource(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcConstructionProductResource(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcConstructionProductResource * > (allocateIfcConstructionProductResource(this, Step::Id_UNSET));
    }
}

IfcConstructionProductResource *ExpressDataSet::cloneIfcConstructionProductResource(ExpressDataSet *expressDataSet, const IfcConstructionProductResource &obj, const CopyOp &copyop)
{
    IfcConstructionProductResource *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConstructionProductResource(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConstructionProductResource_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConstructionProductResource *ExpressDataSet::cloneIfcConstructionProductResource(const IfcConstructionProductResource &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcConstructionProductResource(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcConstructionProductResource(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcConstructionProductResource  > &ExpressDataSet::getAllIfcConstructionProductResource ()
{
    return m_refIfcConstructionProductResourceList;
}



IfcConstructionResource *ExpressDataSet::getIfcConstructionResource(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcConstructionResource * > (current->second.get());
    }
    else
    {
        IfcConstructionResource *ret = static_cast< IfcConstructionResource * > (allocateIfcConstructionResource(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcConstructionResource(IfcConstructionResource *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcConstructionResource_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConstructionResource(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcConstructionResource *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConstructionResource(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConstructionResource_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConstructionResource > ExpressDataSet::createIfcConstructionResource(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcConstructionResource(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcConstructionResource * > (allocateIfcConstructionResource(this, Step::Id_UNSET));
    }
}

IfcConstructionResource *ExpressDataSet::cloneIfcConstructionResource(ExpressDataSet *expressDataSet, const IfcConstructionResource &obj, const CopyOp &copyop)
{
    IfcConstructionResource *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConstructionResource(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConstructionResource_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConstructionResource *ExpressDataSet::cloneIfcConstructionResource(const IfcConstructionResource &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcConstructionResource(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcConstructionResource(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcConstructionResource  > &ExpressDataSet::getAllIfcConstructionResource ()
{
    return m_refIfcConstructionResourceList;
}



IfcContextDependentUnit *ExpressDataSet::getIfcContextDependentUnit(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcContextDependentUnit * > (current->second.get());
    }
    else
    {
        IfcContextDependentUnit *ret = static_cast< IfcContextDependentUnit * > (allocateIfcContextDependentUnit(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcContextDependentUnit(IfcContextDependentUnit *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcContextDependentUnit_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcContextDependentUnit(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcContextDependentUnit *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcContextDependentUnit(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcContextDependentUnit_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcContextDependentUnit > ExpressDataSet::createIfcContextDependentUnit(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcContextDependentUnit(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcContextDependentUnit * > (allocateIfcContextDependentUnit(this, Step::Id_UNSET));
    }
}

IfcContextDependentUnit *ExpressDataSet::cloneIfcContextDependentUnit(ExpressDataSet *expressDataSet, const IfcContextDependentUnit &obj, const CopyOp &copyop)
{
    IfcContextDependentUnit *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcContextDependentUnit(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcContextDependentUnit_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcContextDependentUnit *ExpressDataSet::cloneIfcContextDependentUnit(const IfcContextDependentUnit &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcContextDependentUnit(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcContextDependentUnit(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcContextDependentUnit  > &ExpressDataSet::getAllIfcContextDependentUnit ()
{
    return m_refIfcContextDependentUnitList;
}



IfcControl *ExpressDataSet::getIfcControl(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcControl * > (current->second.get());
    }
    else
    {
        IfcControl *ret = static_cast< IfcControl * > (allocateIfcControl(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcControl(IfcControl *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcControl_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcControl(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcControl *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcControl(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcControl_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcControl > ExpressDataSet::createIfcControl(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcControl(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcControl * > (allocateIfcControl(this, Step::Id_UNSET));
    }
}

IfcControl *ExpressDataSet::cloneIfcControl(ExpressDataSet *expressDataSet, const IfcControl &obj, const CopyOp &copyop)
{
    IfcControl *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcControl(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcControl_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcControl *ExpressDataSet::cloneIfcControl(const IfcControl &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcControl(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcControl(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcControl  > &ExpressDataSet::getAllIfcControl ()
{
    return m_refIfcControlList;
}



IfcControllerType *ExpressDataSet::getIfcControllerType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcControllerType * > (current->second.get());
    }
    else
    {
        IfcControllerType *ret = static_cast< IfcControllerType * > (allocateIfcControllerType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcControllerType(IfcControllerType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcControllerType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcControllerType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcControllerType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcControllerType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcControllerType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcControllerType > ExpressDataSet::createIfcControllerType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcControllerType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcControllerType * > (allocateIfcControllerType(this, Step::Id_UNSET));
    }
}

IfcControllerType *ExpressDataSet::cloneIfcControllerType(ExpressDataSet *expressDataSet, const IfcControllerType &obj, const CopyOp &copyop)
{
    IfcControllerType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcControllerType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcControllerType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcControllerType *ExpressDataSet::cloneIfcControllerType(const IfcControllerType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcControllerType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcControllerType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcControllerType  > &ExpressDataSet::getAllIfcControllerType ()
{
    return m_refIfcControllerTypeList;
}



IfcConversionBasedUnit *ExpressDataSet::getIfcConversionBasedUnit(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcConversionBasedUnit * > (current->second.get());
    }
    else
    {
        IfcConversionBasedUnit *ret = static_cast< IfcConversionBasedUnit * > (allocateIfcConversionBasedUnit(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcConversionBasedUnit(IfcConversionBasedUnit *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcConversionBasedUnit_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConversionBasedUnit(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcConversionBasedUnit *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConversionBasedUnit(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConversionBasedUnit_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConversionBasedUnit > ExpressDataSet::createIfcConversionBasedUnit(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcConversionBasedUnit(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcConversionBasedUnit * > (allocateIfcConversionBasedUnit(this, Step::Id_UNSET));
    }
}

IfcConversionBasedUnit *ExpressDataSet::cloneIfcConversionBasedUnit(ExpressDataSet *expressDataSet, const IfcConversionBasedUnit &obj, const CopyOp &copyop)
{
    IfcConversionBasedUnit *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConversionBasedUnit(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConversionBasedUnit_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConversionBasedUnit *ExpressDataSet::cloneIfcConversionBasedUnit(const IfcConversionBasedUnit &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcConversionBasedUnit(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcConversionBasedUnit(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcConversionBasedUnit  > &ExpressDataSet::getAllIfcConversionBasedUnit ()
{
    return m_refIfcConversionBasedUnitList;
}



IfcCooledBeamType *ExpressDataSet::getIfcCooledBeamType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCooledBeamType * > (current->second.get());
    }
    else
    {
        IfcCooledBeamType *ret = static_cast< IfcCooledBeamType * > (allocateIfcCooledBeamType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCooledBeamType(IfcCooledBeamType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCooledBeamType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCooledBeamType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCooledBeamType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCooledBeamType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCooledBeamType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCooledBeamType > ExpressDataSet::createIfcCooledBeamType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCooledBeamType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCooledBeamType * > (allocateIfcCooledBeamType(this, Step::Id_UNSET));
    }
}

IfcCooledBeamType *ExpressDataSet::cloneIfcCooledBeamType(ExpressDataSet *expressDataSet, const IfcCooledBeamType &obj, const CopyOp &copyop)
{
    IfcCooledBeamType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCooledBeamType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCooledBeamType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCooledBeamType *ExpressDataSet::cloneIfcCooledBeamType(const IfcCooledBeamType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCooledBeamType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCooledBeamType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCooledBeamType  > &ExpressDataSet::getAllIfcCooledBeamType ()
{
    return m_refIfcCooledBeamTypeList;
}



IfcCoolingTowerType *ExpressDataSet::getIfcCoolingTowerType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCoolingTowerType * > (current->second.get());
    }
    else
    {
        IfcCoolingTowerType *ret = static_cast< IfcCoolingTowerType * > (allocateIfcCoolingTowerType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCoolingTowerType(IfcCoolingTowerType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCoolingTowerType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCoolingTowerType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCoolingTowerType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCoolingTowerType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCoolingTowerType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCoolingTowerType > ExpressDataSet::createIfcCoolingTowerType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCoolingTowerType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCoolingTowerType * > (allocateIfcCoolingTowerType(this, Step::Id_UNSET));
    }
}

IfcCoolingTowerType *ExpressDataSet::cloneIfcCoolingTowerType(ExpressDataSet *expressDataSet, const IfcCoolingTowerType &obj, const CopyOp &copyop)
{
    IfcCoolingTowerType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCoolingTowerType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCoolingTowerType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCoolingTowerType *ExpressDataSet::cloneIfcCoolingTowerType(const IfcCoolingTowerType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCoolingTowerType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCoolingTowerType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCoolingTowerType  > &ExpressDataSet::getAllIfcCoolingTowerType ()
{
    return m_refIfcCoolingTowerTypeList;
}



IfcCoordinatedUniversalTimeOffset *ExpressDataSet::getIfcCoordinatedUniversalTimeOffset(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCoordinatedUniversalTimeOffset * > (current->second.get());
    }
    else
    {
        IfcCoordinatedUniversalTimeOffset *ret = static_cast< IfcCoordinatedUniversalTimeOffset * > (allocateIfcCoordinatedUniversalTimeOffset(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCoordinatedUniversalTimeOffset(IfcCoordinatedUniversalTimeOffset *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCoordinatedUniversalTimeOffset_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCoordinatedUniversalTimeOffset(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCoordinatedUniversalTimeOffset *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCoordinatedUniversalTimeOffset(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCoordinatedUniversalTimeOffset_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCoordinatedUniversalTimeOffset > ExpressDataSet::createIfcCoordinatedUniversalTimeOffset(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCoordinatedUniversalTimeOffset(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCoordinatedUniversalTimeOffset * > (allocateIfcCoordinatedUniversalTimeOffset(this, Step::Id_UNSET));
    }
}

IfcCoordinatedUniversalTimeOffset *ExpressDataSet::cloneIfcCoordinatedUniversalTimeOffset(ExpressDataSet *expressDataSet, const IfcCoordinatedUniversalTimeOffset &obj, const CopyOp &copyop)
{
    IfcCoordinatedUniversalTimeOffset *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCoordinatedUniversalTimeOffset(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCoordinatedUniversalTimeOffset_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCoordinatedUniversalTimeOffset *ExpressDataSet::cloneIfcCoordinatedUniversalTimeOffset(const IfcCoordinatedUniversalTimeOffset &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCoordinatedUniversalTimeOffset(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCoordinatedUniversalTimeOffset(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCoordinatedUniversalTimeOffset  > &ExpressDataSet::getAllIfcCoordinatedUniversalTimeOffset ()
{
    return m_refIfcCoordinatedUniversalTimeOffsetList;
}



IfcCostItem *ExpressDataSet::getIfcCostItem(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCostItem * > (current->second.get());
    }
    else
    {
        IfcCostItem *ret = static_cast< IfcCostItem * > (allocateIfcCostItem(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCostItem(IfcCostItem *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCostItem_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCostItem(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCostItem *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCostItem(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCostItem_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCostItem > ExpressDataSet::createIfcCostItem(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCostItem(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCostItem * > (allocateIfcCostItem(this, Step::Id_UNSET));
    }
}

IfcCostItem *ExpressDataSet::cloneIfcCostItem(ExpressDataSet *expressDataSet, const IfcCostItem &obj, const CopyOp &copyop)
{
    IfcCostItem *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCostItem(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCostItem_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCostItem *ExpressDataSet::cloneIfcCostItem(const IfcCostItem &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCostItem(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCostItem(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCostItem  > &ExpressDataSet::getAllIfcCostItem ()
{
    return m_refIfcCostItemList;
}



IfcCostSchedule *ExpressDataSet::getIfcCostSchedule(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCostSchedule * > (current->second.get());
    }
    else
    {
        IfcCostSchedule *ret = static_cast< IfcCostSchedule * > (allocateIfcCostSchedule(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCostSchedule(IfcCostSchedule *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCostSchedule_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCostSchedule(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCostSchedule *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCostSchedule(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCostSchedule_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCostSchedule > ExpressDataSet::createIfcCostSchedule(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCostSchedule(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCostSchedule * > (allocateIfcCostSchedule(this, Step::Id_UNSET));
    }
}

IfcCostSchedule *ExpressDataSet::cloneIfcCostSchedule(ExpressDataSet *expressDataSet, const IfcCostSchedule &obj, const CopyOp &copyop)
{
    IfcCostSchedule *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCostSchedule(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCostSchedule_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCostSchedule *ExpressDataSet::cloneIfcCostSchedule(const IfcCostSchedule &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCostSchedule(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCostSchedule(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCostSchedule  > &ExpressDataSet::getAllIfcCostSchedule ()
{
    return m_refIfcCostScheduleList;
}



IfcCostValue *ExpressDataSet::getIfcCostValue(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCostValue * > (current->second.get());
    }
    else
    {
        IfcCostValue *ret = static_cast< IfcCostValue * > (allocateIfcCostValue(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCostValue(IfcCostValue *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCostValue_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCostValue(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCostValue *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCostValue(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCostValue_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCostValue > ExpressDataSet::createIfcCostValue(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCostValue(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCostValue * > (allocateIfcCostValue(this, Step::Id_UNSET));
    }
}

IfcCostValue *ExpressDataSet::cloneIfcCostValue(ExpressDataSet *expressDataSet, const IfcCostValue &obj, const CopyOp &copyop)
{
    IfcCostValue *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCostValue(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCostValue_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCostValue *ExpressDataSet::cloneIfcCostValue(const IfcCostValue &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCostValue(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCostValue(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCostValue  > &ExpressDataSet::getAllIfcCostValue ()
{
    return m_refIfcCostValueList;
}



IfcCovering *ExpressDataSet::getIfcCovering(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCovering * > (current->second.get());
    }
    else
    {
        IfcCovering *ret = static_cast< IfcCovering * > (allocateIfcCovering(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCovering(IfcCovering *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCovering_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCovering(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCovering *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCovering(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCovering_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCovering > ExpressDataSet::createIfcCovering(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCovering(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCovering * > (allocateIfcCovering(this, Step::Id_UNSET));
    }
}

IfcCovering *ExpressDataSet::cloneIfcCovering(ExpressDataSet *expressDataSet, const IfcCovering &obj, const CopyOp &copyop)
{
    IfcCovering *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCovering(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCovering_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCovering *ExpressDataSet::cloneIfcCovering(const IfcCovering &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCovering(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCovering(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCovering  > &ExpressDataSet::getAllIfcCovering ()
{
    return m_refIfcCoveringList;
}



IfcCoveringType *ExpressDataSet::getIfcCoveringType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCoveringType * > (current->second.get());
    }
    else
    {
        IfcCoveringType *ret = static_cast< IfcCoveringType * > (allocateIfcCoveringType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCoveringType(IfcCoveringType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCoveringType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCoveringType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCoveringType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCoveringType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCoveringType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCoveringType > ExpressDataSet::createIfcCoveringType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCoveringType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCoveringType * > (allocateIfcCoveringType(this, Step::Id_UNSET));
    }
}

IfcCoveringType *ExpressDataSet::cloneIfcCoveringType(ExpressDataSet *expressDataSet, const IfcCoveringType &obj, const CopyOp &copyop)
{
    IfcCoveringType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCoveringType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCoveringType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCoveringType *ExpressDataSet::cloneIfcCoveringType(const IfcCoveringType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCoveringType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCoveringType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCoveringType  > &ExpressDataSet::getAllIfcCoveringType ()
{
    return m_refIfcCoveringTypeList;
}



IfcCraneRailAShapeProfileDef *ExpressDataSet::getIfcCraneRailAShapeProfileDef(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCraneRailAShapeProfileDef * > (current->second.get());
    }
    else
    {
        IfcCraneRailAShapeProfileDef *ret = static_cast< IfcCraneRailAShapeProfileDef * > (allocateIfcCraneRailAShapeProfileDef(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCraneRailAShapeProfileDef(IfcCraneRailAShapeProfileDef *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCraneRailAShapeProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCraneRailAShapeProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCraneRailAShapeProfileDef *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCraneRailAShapeProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCraneRailAShapeProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCraneRailAShapeProfileDef > ExpressDataSet::createIfcCraneRailAShapeProfileDef(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCraneRailAShapeProfileDef(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCraneRailAShapeProfileDef * > (allocateIfcCraneRailAShapeProfileDef(this, Step::Id_UNSET));
    }
}

IfcCraneRailAShapeProfileDef *ExpressDataSet::cloneIfcCraneRailAShapeProfileDef(ExpressDataSet *expressDataSet, const IfcCraneRailAShapeProfileDef &obj, const CopyOp &copyop)
{
    IfcCraneRailAShapeProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCraneRailAShapeProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCraneRailAShapeProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCraneRailAShapeProfileDef *ExpressDataSet::cloneIfcCraneRailAShapeProfileDef(const IfcCraneRailAShapeProfileDef &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCraneRailAShapeProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCraneRailAShapeProfileDef(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCraneRailAShapeProfileDef  > &ExpressDataSet::getAllIfcCraneRailAShapeProfileDef ()
{
    return m_refIfcCraneRailAShapeProfileDefList;
}



IfcCraneRailFShapeProfileDef *ExpressDataSet::getIfcCraneRailFShapeProfileDef(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCraneRailFShapeProfileDef * > (current->second.get());
    }
    else
    {
        IfcCraneRailFShapeProfileDef *ret = static_cast< IfcCraneRailFShapeProfileDef * > (allocateIfcCraneRailFShapeProfileDef(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCraneRailFShapeProfileDef(IfcCraneRailFShapeProfileDef *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCraneRailFShapeProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCraneRailFShapeProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCraneRailFShapeProfileDef *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCraneRailFShapeProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCraneRailFShapeProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCraneRailFShapeProfileDef > ExpressDataSet::createIfcCraneRailFShapeProfileDef(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCraneRailFShapeProfileDef(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCraneRailFShapeProfileDef * > (allocateIfcCraneRailFShapeProfileDef(this, Step::Id_UNSET));
    }
}

IfcCraneRailFShapeProfileDef *ExpressDataSet::cloneIfcCraneRailFShapeProfileDef(ExpressDataSet *expressDataSet, const IfcCraneRailFShapeProfileDef &obj, const CopyOp &copyop)
{
    IfcCraneRailFShapeProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCraneRailFShapeProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCraneRailFShapeProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCraneRailFShapeProfileDef *ExpressDataSet::cloneIfcCraneRailFShapeProfileDef(const IfcCraneRailFShapeProfileDef &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCraneRailFShapeProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCraneRailFShapeProfileDef(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCraneRailFShapeProfileDef  > &ExpressDataSet::getAllIfcCraneRailFShapeProfileDef ()
{
    return m_refIfcCraneRailFShapeProfileDefList;
}



IfcCrewResource *ExpressDataSet::getIfcCrewResource(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCrewResource * > (current->second.get());
    }
    else
    {
        IfcCrewResource *ret = static_cast< IfcCrewResource * > (allocateIfcCrewResource(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCrewResource(IfcCrewResource *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCrewResource_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCrewResource(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCrewResource *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCrewResource(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCrewResource_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCrewResource > ExpressDataSet::createIfcCrewResource(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCrewResource(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCrewResource * > (allocateIfcCrewResource(this, Step::Id_UNSET));
    }
}

IfcCrewResource *ExpressDataSet::cloneIfcCrewResource(ExpressDataSet *expressDataSet, const IfcCrewResource &obj, const CopyOp &copyop)
{
    IfcCrewResource *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCrewResource(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCrewResource_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCrewResource *ExpressDataSet::cloneIfcCrewResource(const IfcCrewResource &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCrewResource(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCrewResource(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCrewResource  > &ExpressDataSet::getAllIfcCrewResource ()
{
    return m_refIfcCrewResourceList;
}



IfcCsgPrimitive3D *ExpressDataSet::getIfcCsgPrimitive3D(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCsgPrimitive3D * > (current->second.get());
    }
    else
    {
        IfcCsgPrimitive3D *ret = static_cast< IfcCsgPrimitive3D * > (allocateIfcCsgPrimitive3D(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCsgPrimitive3D(IfcCsgPrimitive3D *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCsgPrimitive3D_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCsgPrimitive3D(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCsgPrimitive3D *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCsgPrimitive3D(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCsgPrimitive3D_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCsgPrimitive3D > ExpressDataSet::createIfcCsgPrimitive3D(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCsgPrimitive3D(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCsgPrimitive3D * > (allocateIfcCsgPrimitive3D(this, Step::Id_UNSET));
    }
}

IfcCsgPrimitive3D *ExpressDataSet::cloneIfcCsgPrimitive3D(ExpressDataSet *expressDataSet, const IfcCsgPrimitive3D &obj, const CopyOp &copyop)
{
    IfcCsgPrimitive3D *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCsgPrimitive3D(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCsgPrimitive3D_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCsgPrimitive3D *ExpressDataSet::cloneIfcCsgPrimitive3D(const IfcCsgPrimitive3D &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCsgPrimitive3D(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCsgPrimitive3D(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCsgPrimitive3D  > &ExpressDataSet::getAllIfcCsgPrimitive3D ()
{
    return m_refIfcCsgPrimitive3DList;
}



IfcCsgSolid *ExpressDataSet::getIfcCsgSolid(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCsgSolid * > (current->second.get());
    }
    else
    {
        IfcCsgSolid *ret = static_cast< IfcCsgSolid * > (allocateIfcCsgSolid(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCsgSolid(IfcCsgSolid *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCsgSolid_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCsgSolid(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCsgSolid *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCsgSolid(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCsgSolid_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCsgSolid > ExpressDataSet::createIfcCsgSolid(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCsgSolid(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCsgSolid * > (allocateIfcCsgSolid(this, Step::Id_UNSET));
    }
}

IfcCsgSolid *ExpressDataSet::cloneIfcCsgSolid(ExpressDataSet *expressDataSet, const IfcCsgSolid &obj, const CopyOp &copyop)
{
    IfcCsgSolid *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCsgSolid(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCsgSolid_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCsgSolid *ExpressDataSet::cloneIfcCsgSolid(const IfcCsgSolid &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCsgSolid(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCsgSolid(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCsgSolid  > &ExpressDataSet::getAllIfcCsgSolid ()
{
    return m_refIfcCsgSolidList;
}



IfcCShapeProfileDef *ExpressDataSet::getIfcCShapeProfileDef(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCShapeProfileDef * > (current->second.get());
    }
    else
    {
        IfcCShapeProfileDef *ret = static_cast< IfcCShapeProfileDef * > (allocateIfcCShapeProfileDef(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCShapeProfileDef(IfcCShapeProfileDef *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCShapeProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCShapeProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCShapeProfileDef *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCShapeProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCShapeProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCShapeProfileDef > ExpressDataSet::createIfcCShapeProfileDef(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCShapeProfileDef(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCShapeProfileDef * > (allocateIfcCShapeProfileDef(this, Step::Id_UNSET));
    }
}

IfcCShapeProfileDef *ExpressDataSet::cloneIfcCShapeProfileDef(ExpressDataSet *expressDataSet, const IfcCShapeProfileDef &obj, const CopyOp &copyop)
{
    IfcCShapeProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCShapeProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCShapeProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCShapeProfileDef *ExpressDataSet::cloneIfcCShapeProfileDef(const IfcCShapeProfileDef &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCShapeProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCShapeProfileDef(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCShapeProfileDef  > &ExpressDataSet::getAllIfcCShapeProfileDef ()
{
    return m_refIfcCShapeProfileDefList;
}



IfcCurrencyRelationship *ExpressDataSet::getIfcCurrencyRelationship(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCurrencyRelationship * > (current->second.get());
    }
    else
    {
        IfcCurrencyRelationship *ret = static_cast< IfcCurrencyRelationship * > (allocateIfcCurrencyRelationship(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCurrencyRelationship(IfcCurrencyRelationship *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCurrencyRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCurrencyRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCurrencyRelationship *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCurrencyRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCurrencyRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCurrencyRelationship > ExpressDataSet::createIfcCurrencyRelationship(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCurrencyRelationship(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCurrencyRelationship * > (allocateIfcCurrencyRelationship(this, Step::Id_UNSET));
    }
}

IfcCurrencyRelationship *ExpressDataSet::cloneIfcCurrencyRelationship(ExpressDataSet *expressDataSet, const IfcCurrencyRelationship &obj, const CopyOp &copyop)
{
    IfcCurrencyRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCurrencyRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCurrencyRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCurrencyRelationship *ExpressDataSet::cloneIfcCurrencyRelationship(const IfcCurrencyRelationship &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCurrencyRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCurrencyRelationship(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCurrencyRelationship  > &ExpressDataSet::getAllIfcCurrencyRelationship ()
{
    return m_refIfcCurrencyRelationshipList;
}



IfcCurtainWall *ExpressDataSet::getIfcCurtainWall(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCurtainWall * > (current->second.get());
    }
    else
    {
        IfcCurtainWall *ret = static_cast< IfcCurtainWall * > (allocateIfcCurtainWall(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCurtainWall(IfcCurtainWall *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCurtainWall_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCurtainWall(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCurtainWall *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCurtainWall(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCurtainWall_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCurtainWall > ExpressDataSet::createIfcCurtainWall(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCurtainWall(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCurtainWall * > (allocateIfcCurtainWall(this, Step::Id_UNSET));
    }
}

IfcCurtainWall *ExpressDataSet::cloneIfcCurtainWall(ExpressDataSet *expressDataSet, const IfcCurtainWall &obj, const CopyOp &copyop)
{
    IfcCurtainWall *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCurtainWall(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCurtainWall_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCurtainWall *ExpressDataSet::cloneIfcCurtainWall(const IfcCurtainWall &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCurtainWall(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCurtainWall(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCurtainWall  > &ExpressDataSet::getAllIfcCurtainWall ()
{
    return m_refIfcCurtainWallList;
}



IfcCurtainWallType *ExpressDataSet::getIfcCurtainWallType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCurtainWallType * > (current->second.get());
    }
    else
    {
        IfcCurtainWallType *ret = static_cast< IfcCurtainWallType * > (allocateIfcCurtainWallType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCurtainWallType(IfcCurtainWallType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCurtainWallType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCurtainWallType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCurtainWallType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCurtainWallType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCurtainWallType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCurtainWallType > ExpressDataSet::createIfcCurtainWallType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCurtainWallType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCurtainWallType * > (allocateIfcCurtainWallType(this, Step::Id_UNSET));
    }
}

IfcCurtainWallType *ExpressDataSet::cloneIfcCurtainWallType(ExpressDataSet *expressDataSet, const IfcCurtainWallType &obj, const CopyOp &copyop)
{
    IfcCurtainWallType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCurtainWallType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCurtainWallType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCurtainWallType *ExpressDataSet::cloneIfcCurtainWallType(const IfcCurtainWallType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCurtainWallType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCurtainWallType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCurtainWallType  > &ExpressDataSet::getAllIfcCurtainWallType ()
{
    return m_refIfcCurtainWallTypeList;
}



IfcCurve *ExpressDataSet::getIfcCurve(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCurve * > (current->second.get());
    }
    else
    {
        IfcCurve *ret = static_cast< IfcCurve * > (allocateIfcCurve(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCurve(IfcCurve *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCurve_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCurve(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCurve *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCurve(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCurve_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCurve > ExpressDataSet::createIfcCurve(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCurve(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCurve * > (allocateIfcCurve(this, Step::Id_UNSET));
    }
}

IfcCurve *ExpressDataSet::cloneIfcCurve(ExpressDataSet *expressDataSet, const IfcCurve &obj, const CopyOp &copyop)
{
    IfcCurve *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCurve(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCurve_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCurve *ExpressDataSet::cloneIfcCurve(const IfcCurve &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCurve(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCurve(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCurve  > &ExpressDataSet::getAllIfcCurve ()
{
    return m_refIfcCurveList;
}



IfcCurveBoundedPlane *ExpressDataSet::getIfcCurveBoundedPlane(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCurveBoundedPlane * > (current->second.get());
    }
    else
    {
        IfcCurveBoundedPlane *ret = static_cast< IfcCurveBoundedPlane * > (allocateIfcCurveBoundedPlane(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCurveBoundedPlane(IfcCurveBoundedPlane *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCurveBoundedPlane_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCurveBoundedPlane(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCurveBoundedPlane *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCurveBoundedPlane(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCurveBoundedPlane_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCurveBoundedPlane > ExpressDataSet::createIfcCurveBoundedPlane(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCurveBoundedPlane(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCurveBoundedPlane * > (allocateIfcCurveBoundedPlane(this, Step::Id_UNSET));
    }
}

IfcCurveBoundedPlane *ExpressDataSet::cloneIfcCurveBoundedPlane(ExpressDataSet *expressDataSet, const IfcCurveBoundedPlane &obj, const CopyOp &copyop)
{
    IfcCurveBoundedPlane *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCurveBoundedPlane(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCurveBoundedPlane_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCurveBoundedPlane *ExpressDataSet::cloneIfcCurveBoundedPlane(const IfcCurveBoundedPlane &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCurveBoundedPlane(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCurveBoundedPlane(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCurveBoundedPlane  > &ExpressDataSet::getAllIfcCurveBoundedPlane ()
{
    return m_refIfcCurveBoundedPlaneList;
}



IfcCurveStyle *ExpressDataSet::getIfcCurveStyle(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCurveStyle * > (current->second.get());
    }
    else
    {
        IfcCurveStyle *ret = static_cast< IfcCurveStyle * > (allocateIfcCurveStyle(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCurveStyle(IfcCurveStyle *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCurveStyle_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCurveStyle(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCurveStyle *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCurveStyle(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCurveStyle_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCurveStyle > ExpressDataSet::createIfcCurveStyle(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCurveStyle(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCurveStyle * > (allocateIfcCurveStyle(this, Step::Id_UNSET));
    }
}

IfcCurveStyle *ExpressDataSet::cloneIfcCurveStyle(ExpressDataSet *expressDataSet, const IfcCurveStyle &obj, const CopyOp &copyop)
{
    IfcCurveStyle *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCurveStyle(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCurveStyle_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCurveStyle *ExpressDataSet::cloneIfcCurveStyle(const IfcCurveStyle &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCurveStyle(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCurveStyle(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCurveStyle  > &ExpressDataSet::getAllIfcCurveStyle ()
{
    return m_refIfcCurveStyleList;
}



IfcCurveStyleFont *ExpressDataSet::getIfcCurveStyleFont(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCurveStyleFont * > (current->second.get());
    }
    else
    {
        IfcCurveStyleFont *ret = static_cast< IfcCurveStyleFont * > (allocateIfcCurveStyleFont(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCurveStyleFont(IfcCurveStyleFont *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCurveStyleFont_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCurveStyleFont(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCurveStyleFont *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCurveStyleFont(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCurveStyleFont_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCurveStyleFont > ExpressDataSet::createIfcCurveStyleFont(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCurveStyleFont(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCurveStyleFont * > (allocateIfcCurveStyleFont(this, Step::Id_UNSET));
    }
}

IfcCurveStyleFont *ExpressDataSet::cloneIfcCurveStyleFont(ExpressDataSet *expressDataSet, const IfcCurveStyleFont &obj, const CopyOp &copyop)
{
    IfcCurveStyleFont *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCurveStyleFont(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCurveStyleFont_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCurveStyleFont *ExpressDataSet::cloneIfcCurveStyleFont(const IfcCurveStyleFont &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCurveStyleFont(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCurveStyleFont(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCurveStyleFont  > &ExpressDataSet::getAllIfcCurveStyleFont ()
{
    return m_refIfcCurveStyleFontList;
}



IfcCurveStyleFontAndScaling *ExpressDataSet::getIfcCurveStyleFontAndScaling(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCurveStyleFontAndScaling * > (current->second.get());
    }
    else
    {
        IfcCurveStyleFontAndScaling *ret = static_cast< IfcCurveStyleFontAndScaling * > (allocateIfcCurveStyleFontAndScaling(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCurveStyleFontAndScaling(IfcCurveStyleFontAndScaling *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCurveStyleFontAndScaling_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCurveStyleFontAndScaling(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCurveStyleFontAndScaling *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCurveStyleFontAndScaling(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCurveStyleFontAndScaling_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCurveStyleFontAndScaling > ExpressDataSet::createIfcCurveStyleFontAndScaling(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCurveStyleFontAndScaling(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCurveStyleFontAndScaling * > (allocateIfcCurveStyleFontAndScaling(this, Step::Id_UNSET));
    }
}

IfcCurveStyleFontAndScaling *ExpressDataSet::cloneIfcCurveStyleFontAndScaling(ExpressDataSet *expressDataSet, const IfcCurveStyleFontAndScaling &obj, const CopyOp &copyop)
{
    IfcCurveStyleFontAndScaling *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCurveStyleFontAndScaling(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCurveStyleFontAndScaling_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCurveStyleFontAndScaling *ExpressDataSet::cloneIfcCurveStyleFontAndScaling(const IfcCurveStyleFontAndScaling &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCurveStyleFontAndScaling(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCurveStyleFontAndScaling(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCurveStyleFontAndScaling  > &ExpressDataSet::getAllIfcCurveStyleFontAndScaling ()
{
    return m_refIfcCurveStyleFontAndScalingList;
}



IfcCurveStyleFontPattern *ExpressDataSet::getIfcCurveStyleFontPattern(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcCurveStyleFontPattern * > (current->second.get());
    }
    else
    {
        IfcCurveStyleFontPattern *ret = static_cast< IfcCurveStyleFontPattern * > (allocateIfcCurveStyleFontPattern(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcCurveStyleFontPattern(IfcCurveStyleFontPattern *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcCurveStyleFontPattern_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCurveStyleFontPattern(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcCurveStyleFontPattern *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCurveStyleFontPattern(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCurveStyleFontPattern_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCurveStyleFontPattern > ExpressDataSet::createIfcCurveStyleFontPattern(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcCurveStyleFontPattern(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcCurveStyleFontPattern * > (allocateIfcCurveStyleFontPattern(this, Step::Id_UNSET));
    }
}

IfcCurveStyleFontPattern *ExpressDataSet::cloneIfcCurveStyleFontPattern(ExpressDataSet *expressDataSet, const IfcCurveStyleFontPattern &obj, const CopyOp &copyop)
{
    IfcCurveStyleFontPattern *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCurveStyleFontPattern(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCurveStyleFontPattern_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCurveStyleFontPattern *ExpressDataSet::cloneIfcCurveStyleFontPattern(const IfcCurveStyleFontPattern &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcCurveStyleFontPattern(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcCurveStyleFontPattern(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcCurveStyleFontPattern  > &ExpressDataSet::getAllIfcCurveStyleFontPattern ()
{
    return m_refIfcCurveStyleFontPatternList;
}



IfcDamperType *ExpressDataSet::getIfcDamperType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDamperType * > (current->second.get());
    }
    else
    {
        IfcDamperType *ret = static_cast< IfcDamperType * > (allocateIfcDamperType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDamperType(IfcDamperType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDamperType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDamperType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDamperType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDamperType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDamperType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDamperType > ExpressDataSet::createIfcDamperType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDamperType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDamperType * > (allocateIfcDamperType(this, Step::Id_UNSET));
    }
}

IfcDamperType *ExpressDataSet::cloneIfcDamperType(ExpressDataSet *expressDataSet, const IfcDamperType &obj, const CopyOp &copyop)
{
    IfcDamperType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDamperType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDamperType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDamperType *ExpressDataSet::cloneIfcDamperType(const IfcDamperType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDamperType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDamperType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDamperType  > &ExpressDataSet::getAllIfcDamperType ()
{
    return m_refIfcDamperTypeList;
}



IfcDateAndTime *ExpressDataSet::getIfcDateAndTime(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDateAndTime * > (current->second.get());
    }
    else
    {
        IfcDateAndTime *ret = static_cast< IfcDateAndTime * > (allocateIfcDateAndTime(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDateAndTime(IfcDateAndTime *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDateAndTime_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDateAndTime(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDateAndTime *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDateAndTime(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDateAndTime_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDateAndTime > ExpressDataSet::createIfcDateAndTime(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDateAndTime(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDateAndTime * > (allocateIfcDateAndTime(this, Step::Id_UNSET));
    }
}

IfcDateAndTime *ExpressDataSet::cloneIfcDateAndTime(ExpressDataSet *expressDataSet, const IfcDateAndTime &obj, const CopyOp &copyop)
{
    IfcDateAndTime *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDateAndTime(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDateAndTime_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDateAndTime *ExpressDataSet::cloneIfcDateAndTime(const IfcDateAndTime &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDateAndTime(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDateAndTime(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDateAndTime  > &ExpressDataSet::getAllIfcDateAndTime ()
{
    return m_refIfcDateAndTimeList;
}



IfcDefinedSymbol *ExpressDataSet::getIfcDefinedSymbol(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDefinedSymbol * > (current->second.get());
    }
    else
    {
        IfcDefinedSymbol *ret = static_cast< IfcDefinedSymbol * > (allocateIfcDefinedSymbol(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDefinedSymbol(IfcDefinedSymbol *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDefinedSymbol_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDefinedSymbol(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDefinedSymbol *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDefinedSymbol(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDefinedSymbol_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDefinedSymbol > ExpressDataSet::createIfcDefinedSymbol(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDefinedSymbol(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDefinedSymbol * > (allocateIfcDefinedSymbol(this, Step::Id_UNSET));
    }
}

IfcDefinedSymbol *ExpressDataSet::cloneIfcDefinedSymbol(ExpressDataSet *expressDataSet, const IfcDefinedSymbol &obj, const CopyOp &copyop)
{
    IfcDefinedSymbol *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDefinedSymbol(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDefinedSymbol_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDefinedSymbol *ExpressDataSet::cloneIfcDefinedSymbol(const IfcDefinedSymbol &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDefinedSymbol(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDefinedSymbol(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDefinedSymbol  > &ExpressDataSet::getAllIfcDefinedSymbol ()
{
    return m_refIfcDefinedSymbolList;
}



IfcDerivedProfileDef *ExpressDataSet::getIfcDerivedProfileDef(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDerivedProfileDef * > (current->second.get());
    }
    else
    {
        IfcDerivedProfileDef *ret = static_cast< IfcDerivedProfileDef * > (allocateIfcDerivedProfileDef(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDerivedProfileDef(IfcDerivedProfileDef *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDerivedProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDerivedProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDerivedProfileDef *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDerivedProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDerivedProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDerivedProfileDef > ExpressDataSet::createIfcDerivedProfileDef(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDerivedProfileDef(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDerivedProfileDef * > (allocateIfcDerivedProfileDef(this, Step::Id_UNSET));
    }
}

IfcDerivedProfileDef *ExpressDataSet::cloneIfcDerivedProfileDef(ExpressDataSet *expressDataSet, const IfcDerivedProfileDef &obj, const CopyOp &copyop)
{
    IfcDerivedProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDerivedProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDerivedProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDerivedProfileDef *ExpressDataSet::cloneIfcDerivedProfileDef(const IfcDerivedProfileDef &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDerivedProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDerivedProfileDef(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDerivedProfileDef  > &ExpressDataSet::getAllIfcDerivedProfileDef ()
{
    return m_refIfcDerivedProfileDefList;
}



IfcDerivedUnit *ExpressDataSet::getIfcDerivedUnit(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDerivedUnit * > (current->second.get());
    }
    else
    {
        IfcDerivedUnit *ret = static_cast< IfcDerivedUnit * > (allocateIfcDerivedUnit(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDerivedUnit(IfcDerivedUnit *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDerivedUnit_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDerivedUnit(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDerivedUnit *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDerivedUnit(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDerivedUnit_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDerivedUnit > ExpressDataSet::createIfcDerivedUnit(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDerivedUnit(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDerivedUnit * > (allocateIfcDerivedUnit(this, Step::Id_UNSET));
    }
}

IfcDerivedUnit *ExpressDataSet::cloneIfcDerivedUnit(ExpressDataSet *expressDataSet, const IfcDerivedUnit &obj, const CopyOp &copyop)
{
    IfcDerivedUnit *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDerivedUnit(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDerivedUnit_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDerivedUnit *ExpressDataSet::cloneIfcDerivedUnit(const IfcDerivedUnit &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDerivedUnit(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDerivedUnit(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDerivedUnit  > &ExpressDataSet::getAllIfcDerivedUnit ()
{
    return m_refIfcDerivedUnitList;
}



IfcDerivedUnitElement *ExpressDataSet::getIfcDerivedUnitElement(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDerivedUnitElement * > (current->second.get());
    }
    else
    {
        IfcDerivedUnitElement *ret = static_cast< IfcDerivedUnitElement * > (allocateIfcDerivedUnitElement(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDerivedUnitElement(IfcDerivedUnitElement *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDerivedUnitElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDerivedUnitElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDerivedUnitElement *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDerivedUnitElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDerivedUnitElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDerivedUnitElement > ExpressDataSet::createIfcDerivedUnitElement(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDerivedUnitElement(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDerivedUnitElement * > (allocateIfcDerivedUnitElement(this, Step::Id_UNSET));
    }
}

IfcDerivedUnitElement *ExpressDataSet::cloneIfcDerivedUnitElement(ExpressDataSet *expressDataSet, const IfcDerivedUnitElement &obj, const CopyOp &copyop)
{
    IfcDerivedUnitElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDerivedUnitElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDerivedUnitElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDerivedUnitElement *ExpressDataSet::cloneIfcDerivedUnitElement(const IfcDerivedUnitElement &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDerivedUnitElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDerivedUnitElement(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDerivedUnitElement  > &ExpressDataSet::getAllIfcDerivedUnitElement ()
{
    return m_refIfcDerivedUnitElementList;
}



IfcDiameterDimension *ExpressDataSet::getIfcDiameterDimension(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDiameterDimension * > (current->second.get());
    }
    else
    {
        IfcDiameterDimension *ret = static_cast< IfcDiameterDimension * > (allocateIfcDiameterDimension(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDiameterDimension(IfcDiameterDimension *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDiameterDimension_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDiameterDimension(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDiameterDimension *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDiameterDimension(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDiameterDimension_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDiameterDimension > ExpressDataSet::createIfcDiameterDimension(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDiameterDimension(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDiameterDimension * > (allocateIfcDiameterDimension(this, Step::Id_UNSET));
    }
}

IfcDiameterDimension *ExpressDataSet::cloneIfcDiameterDimension(ExpressDataSet *expressDataSet, const IfcDiameterDimension &obj, const CopyOp &copyop)
{
    IfcDiameterDimension *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDiameterDimension(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDiameterDimension_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDiameterDimension *ExpressDataSet::cloneIfcDiameterDimension(const IfcDiameterDimension &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDiameterDimension(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDiameterDimension(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDiameterDimension  > &ExpressDataSet::getAllIfcDiameterDimension ()
{
    return m_refIfcDiameterDimensionList;
}



IfcDimensionalExponents *ExpressDataSet::getIfcDimensionalExponents(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDimensionalExponents * > (current->second.get());
    }
    else
    {
        IfcDimensionalExponents *ret = static_cast< IfcDimensionalExponents * > (allocateIfcDimensionalExponents(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDimensionalExponents(IfcDimensionalExponents *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDimensionalExponents_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDimensionalExponents(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDimensionalExponents *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDimensionalExponents(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDimensionalExponents_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDimensionalExponents > ExpressDataSet::createIfcDimensionalExponents(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDimensionalExponents(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDimensionalExponents * > (allocateIfcDimensionalExponents(this, Step::Id_UNSET));
    }
}

IfcDimensionalExponents *ExpressDataSet::cloneIfcDimensionalExponents(ExpressDataSet *expressDataSet, const IfcDimensionalExponents &obj, const CopyOp &copyop)
{
    IfcDimensionalExponents *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDimensionalExponents(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDimensionalExponents_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDimensionalExponents *ExpressDataSet::cloneIfcDimensionalExponents(const IfcDimensionalExponents &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDimensionalExponents(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDimensionalExponents(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDimensionalExponents  > &ExpressDataSet::getAllIfcDimensionalExponents ()
{
    return m_refIfcDimensionalExponentsList;
}



IfcDimensionCalloutRelationship *ExpressDataSet::getIfcDimensionCalloutRelationship(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDimensionCalloutRelationship * > (current->second.get());
    }
    else
    {
        IfcDimensionCalloutRelationship *ret = static_cast< IfcDimensionCalloutRelationship * > (allocateIfcDimensionCalloutRelationship(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDimensionCalloutRelationship(IfcDimensionCalloutRelationship *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDimensionCalloutRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDimensionCalloutRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDimensionCalloutRelationship *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDimensionCalloutRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDimensionCalloutRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDimensionCalloutRelationship > ExpressDataSet::createIfcDimensionCalloutRelationship(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDimensionCalloutRelationship(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDimensionCalloutRelationship * > (allocateIfcDimensionCalloutRelationship(this, Step::Id_UNSET));
    }
}

IfcDimensionCalloutRelationship *ExpressDataSet::cloneIfcDimensionCalloutRelationship(ExpressDataSet *expressDataSet, const IfcDimensionCalloutRelationship &obj, const CopyOp &copyop)
{
    IfcDimensionCalloutRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDimensionCalloutRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDimensionCalloutRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDimensionCalloutRelationship *ExpressDataSet::cloneIfcDimensionCalloutRelationship(const IfcDimensionCalloutRelationship &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDimensionCalloutRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDimensionCalloutRelationship(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDimensionCalloutRelationship  > &ExpressDataSet::getAllIfcDimensionCalloutRelationship ()
{
    return m_refIfcDimensionCalloutRelationshipList;
}



IfcDimensionCurve *ExpressDataSet::getIfcDimensionCurve(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDimensionCurve * > (current->second.get());
    }
    else
    {
        IfcDimensionCurve *ret = static_cast< IfcDimensionCurve * > (allocateIfcDimensionCurve(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDimensionCurve(IfcDimensionCurve *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDimensionCurve_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDimensionCurve(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDimensionCurve *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDimensionCurve(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDimensionCurve_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDimensionCurve > ExpressDataSet::createIfcDimensionCurve(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDimensionCurve(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDimensionCurve * > (allocateIfcDimensionCurve(this, Step::Id_UNSET));
    }
}

IfcDimensionCurve *ExpressDataSet::cloneIfcDimensionCurve(ExpressDataSet *expressDataSet, const IfcDimensionCurve &obj, const CopyOp &copyop)
{
    IfcDimensionCurve *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDimensionCurve(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDimensionCurve_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDimensionCurve *ExpressDataSet::cloneIfcDimensionCurve(const IfcDimensionCurve &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDimensionCurve(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDimensionCurve(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDimensionCurve  > &ExpressDataSet::getAllIfcDimensionCurve ()
{
    return m_refIfcDimensionCurveList;
}



IfcDimensionCurveDirectedCallout *ExpressDataSet::getIfcDimensionCurveDirectedCallout(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDimensionCurveDirectedCallout * > (current->second.get());
    }
    else
    {
        IfcDimensionCurveDirectedCallout *ret = static_cast< IfcDimensionCurveDirectedCallout * > (allocateIfcDimensionCurveDirectedCallout(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDimensionCurveDirectedCallout(IfcDimensionCurveDirectedCallout *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDimensionCurveDirectedCallout_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDimensionCurveDirectedCallout(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDimensionCurveDirectedCallout *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDimensionCurveDirectedCallout(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDimensionCurveDirectedCallout_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDimensionCurveDirectedCallout > ExpressDataSet::createIfcDimensionCurveDirectedCallout(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDimensionCurveDirectedCallout(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDimensionCurveDirectedCallout * > (allocateIfcDimensionCurveDirectedCallout(this, Step::Id_UNSET));
    }
}

IfcDimensionCurveDirectedCallout *ExpressDataSet::cloneIfcDimensionCurveDirectedCallout(ExpressDataSet *expressDataSet, const IfcDimensionCurveDirectedCallout &obj, const CopyOp &copyop)
{
    IfcDimensionCurveDirectedCallout *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDimensionCurveDirectedCallout(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDimensionCurveDirectedCallout_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDimensionCurveDirectedCallout *ExpressDataSet::cloneIfcDimensionCurveDirectedCallout(const IfcDimensionCurveDirectedCallout &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDimensionCurveDirectedCallout(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDimensionCurveDirectedCallout(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDimensionCurveDirectedCallout  > &ExpressDataSet::getAllIfcDimensionCurveDirectedCallout ()
{
    return m_refIfcDimensionCurveDirectedCalloutList;
}



IfcDimensionCurveTerminator *ExpressDataSet::getIfcDimensionCurveTerminator(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDimensionCurveTerminator * > (current->second.get());
    }
    else
    {
        IfcDimensionCurveTerminator *ret = static_cast< IfcDimensionCurveTerminator * > (allocateIfcDimensionCurveTerminator(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDimensionCurveTerminator(IfcDimensionCurveTerminator *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDimensionCurveTerminator_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDimensionCurveTerminator(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDimensionCurveTerminator *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDimensionCurveTerminator(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDimensionCurveTerminator_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDimensionCurveTerminator > ExpressDataSet::createIfcDimensionCurveTerminator(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDimensionCurveTerminator(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDimensionCurveTerminator * > (allocateIfcDimensionCurveTerminator(this, Step::Id_UNSET));
    }
}

IfcDimensionCurveTerminator *ExpressDataSet::cloneIfcDimensionCurveTerminator(ExpressDataSet *expressDataSet, const IfcDimensionCurveTerminator &obj, const CopyOp &copyop)
{
    IfcDimensionCurveTerminator *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDimensionCurveTerminator(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDimensionCurveTerminator_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDimensionCurveTerminator *ExpressDataSet::cloneIfcDimensionCurveTerminator(const IfcDimensionCurveTerminator &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDimensionCurveTerminator(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDimensionCurveTerminator(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDimensionCurveTerminator  > &ExpressDataSet::getAllIfcDimensionCurveTerminator ()
{
    return m_refIfcDimensionCurveTerminatorList;
}



IfcDimensionPair *ExpressDataSet::getIfcDimensionPair(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDimensionPair * > (current->second.get());
    }
    else
    {
        IfcDimensionPair *ret = static_cast< IfcDimensionPair * > (allocateIfcDimensionPair(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDimensionPair(IfcDimensionPair *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDimensionPair_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDimensionPair(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDimensionPair *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDimensionPair(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDimensionPair_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDimensionPair > ExpressDataSet::createIfcDimensionPair(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDimensionPair(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDimensionPair * > (allocateIfcDimensionPair(this, Step::Id_UNSET));
    }
}

IfcDimensionPair *ExpressDataSet::cloneIfcDimensionPair(ExpressDataSet *expressDataSet, const IfcDimensionPair &obj, const CopyOp &copyop)
{
    IfcDimensionPair *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDimensionPair(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDimensionPair_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDimensionPair *ExpressDataSet::cloneIfcDimensionPair(const IfcDimensionPair &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDimensionPair(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDimensionPair(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDimensionPair  > &ExpressDataSet::getAllIfcDimensionPair ()
{
    return m_refIfcDimensionPairList;
}



IfcDirection *ExpressDataSet::getIfcDirection(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDirection * > (current->second.get());
    }
    else
    {
        IfcDirection *ret = static_cast< IfcDirection * > (allocateIfcDirection(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDirection(IfcDirection *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDirection_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDirection(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDirection *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDirection(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDirection_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDirection > ExpressDataSet::createIfcDirection(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDirection(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDirection * > (allocateIfcDirection(this, Step::Id_UNSET));
    }
}

IfcDirection *ExpressDataSet::cloneIfcDirection(ExpressDataSet *expressDataSet, const IfcDirection &obj, const CopyOp &copyop)
{
    IfcDirection *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDirection(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDirection_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDirection *ExpressDataSet::cloneIfcDirection(const IfcDirection &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDirection(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDirection(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDirection  > &ExpressDataSet::getAllIfcDirection ()
{
    return m_refIfcDirectionList;
}



IfcDiscreteAccessory *ExpressDataSet::getIfcDiscreteAccessory(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDiscreteAccessory * > (current->second.get());
    }
    else
    {
        IfcDiscreteAccessory *ret = static_cast< IfcDiscreteAccessory * > (allocateIfcDiscreteAccessory(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDiscreteAccessory(IfcDiscreteAccessory *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDiscreteAccessory_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDiscreteAccessory(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDiscreteAccessory *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDiscreteAccessory(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDiscreteAccessory_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDiscreteAccessory > ExpressDataSet::createIfcDiscreteAccessory(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDiscreteAccessory(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDiscreteAccessory * > (allocateIfcDiscreteAccessory(this, Step::Id_UNSET));
    }
}

IfcDiscreteAccessory *ExpressDataSet::cloneIfcDiscreteAccessory(ExpressDataSet *expressDataSet, const IfcDiscreteAccessory &obj, const CopyOp &copyop)
{
    IfcDiscreteAccessory *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDiscreteAccessory(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDiscreteAccessory_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDiscreteAccessory *ExpressDataSet::cloneIfcDiscreteAccessory(const IfcDiscreteAccessory &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDiscreteAccessory(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDiscreteAccessory(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDiscreteAccessory  > &ExpressDataSet::getAllIfcDiscreteAccessory ()
{
    return m_refIfcDiscreteAccessoryList;
}



IfcDiscreteAccessoryType *ExpressDataSet::getIfcDiscreteAccessoryType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDiscreteAccessoryType * > (current->second.get());
    }
    else
    {
        IfcDiscreteAccessoryType *ret = static_cast< IfcDiscreteAccessoryType * > (allocateIfcDiscreteAccessoryType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDiscreteAccessoryType(IfcDiscreteAccessoryType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDiscreteAccessoryType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDiscreteAccessoryType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDiscreteAccessoryType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDiscreteAccessoryType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDiscreteAccessoryType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDiscreteAccessoryType > ExpressDataSet::createIfcDiscreteAccessoryType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDiscreteAccessoryType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDiscreteAccessoryType * > (allocateIfcDiscreteAccessoryType(this, Step::Id_UNSET));
    }
}

IfcDiscreteAccessoryType *ExpressDataSet::cloneIfcDiscreteAccessoryType(ExpressDataSet *expressDataSet, const IfcDiscreteAccessoryType &obj, const CopyOp &copyop)
{
    IfcDiscreteAccessoryType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDiscreteAccessoryType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDiscreteAccessoryType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDiscreteAccessoryType *ExpressDataSet::cloneIfcDiscreteAccessoryType(const IfcDiscreteAccessoryType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDiscreteAccessoryType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDiscreteAccessoryType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDiscreteAccessoryType  > &ExpressDataSet::getAllIfcDiscreteAccessoryType ()
{
    return m_refIfcDiscreteAccessoryTypeList;
}



IfcDistributionChamberElement *ExpressDataSet::getIfcDistributionChamberElement(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDistributionChamberElement * > (current->second.get());
    }
    else
    {
        IfcDistributionChamberElement *ret = static_cast< IfcDistributionChamberElement * > (allocateIfcDistributionChamberElement(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDistributionChamberElement(IfcDistributionChamberElement *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDistributionChamberElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDistributionChamberElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDistributionChamberElement *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDistributionChamberElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDistributionChamberElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDistributionChamberElement > ExpressDataSet::createIfcDistributionChamberElement(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDistributionChamberElement(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDistributionChamberElement * > (allocateIfcDistributionChamberElement(this, Step::Id_UNSET));
    }
}

IfcDistributionChamberElement *ExpressDataSet::cloneIfcDistributionChamberElement(ExpressDataSet *expressDataSet, const IfcDistributionChamberElement &obj, const CopyOp &copyop)
{
    IfcDistributionChamberElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDistributionChamberElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDistributionChamberElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDistributionChamberElement *ExpressDataSet::cloneIfcDistributionChamberElement(const IfcDistributionChamberElement &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDistributionChamberElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDistributionChamberElement(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDistributionChamberElement  > &ExpressDataSet::getAllIfcDistributionChamberElement ()
{
    return m_refIfcDistributionChamberElementList;
}



IfcDistributionChamberElementType *ExpressDataSet::getIfcDistributionChamberElementType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDistributionChamberElementType * > (current->second.get());
    }
    else
    {
        IfcDistributionChamberElementType *ret = static_cast< IfcDistributionChamberElementType * > (allocateIfcDistributionChamberElementType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDistributionChamberElementType(IfcDistributionChamberElementType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDistributionChamberElementType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDistributionChamberElementType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDistributionChamberElementType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDistributionChamberElementType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDistributionChamberElementType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDistributionChamberElementType > ExpressDataSet::createIfcDistributionChamberElementType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDistributionChamberElementType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDistributionChamberElementType * > (allocateIfcDistributionChamberElementType(this, Step::Id_UNSET));
    }
}

IfcDistributionChamberElementType *ExpressDataSet::cloneIfcDistributionChamberElementType(ExpressDataSet *expressDataSet, const IfcDistributionChamberElementType &obj, const CopyOp &copyop)
{
    IfcDistributionChamberElementType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDistributionChamberElementType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDistributionChamberElementType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDistributionChamberElementType *ExpressDataSet::cloneIfcDistributionChamberElementType(const IfcDistributionChamberElementType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDistributionChamberElementType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDistributionChamberElementType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDistributionChamberElementType  > &ExpressDataSet::getAllIfcDistributionChamberElementType ()
{
    return m_refIfcDistributionChamberElementTypeList;
}



IfcDistributionControlElement *ExpressDataSet::getIfcDistributionControlElement(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDistributionControlElement * > (current->second.get());
    }
    else
    {
        IfcDistributionControlElement *ret = static_cast< IfcDistributionControlElement * > (allocateIfcDistributionControlElement(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDistributionControlElement(IfcDistributionControlElement *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDistributionControlElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDistributionControlElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDistributionControlElement *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDistributionControlElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDistributionControlElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDistributionControlElement > ExpressDataSet::createIfcDistributionControlElement(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDistributionControlElement(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDistributionControlElement * > (allocateIfcDistributionControlElement(this, Step::Id_UNSET));
    }
}

IfcDistributionControlElement *ExpressDataSet::cloneIfcDistributionControlElement(ExpressDataSet *expressDataSet, const IfcDistributionControlElement &obj, const CopyOp &copyop)
{
    IfcDistributionControlElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDistributionControlElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDistributionControlElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDistributionControlElement *ExpressDataSet::cloneIfcDistributionControlElement(const IfcDistributionControlElement &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDistributionControlElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDistributionControlElement(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDistributionControlElement  > &ExpressDataSet::getAllIfcDistributionControlElement ()
{
    return m_refIfcDistributionControlElementList;
}



IfcDistributionControlElementType *ExpressDataSet::getIfcDistributionControlElementType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDistributionControlElementType * > (current->second.get());
    }
    else
    {
        IfcDistributionControlElementType *ret = static_cast< IfcDistributionControlElementType * > (allocateIfcDistributionControlElementType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDistributionControlElementType(IfcDistributionControlElementType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDistributionControlElementType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDistributionControlElementType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDistributionControlElementType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDistributionControlElementType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDistributionControlElementType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDistributionControlElementType > ExpressDataSet::createIfcDistributionControlElementType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDistributionControlElementType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDistributionControlElementType * > (allocateIfcDistributionControlElementType(this, Step::Id_UNSET));
    }
}

IfcDistributionControlElementType *ExpressDataSet::cloneIfcDistributionControlElementType(ExpressDataSet *expressDataSet, const IfcDistributionControlElementType &obj, const CopyOp &copyop)
{
    IfcDistributionControlElementType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDistributionControlElementType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDistributionControlElementType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDistributionControlElementType *ExpressDataSet::cloneIfcDistributionControlElementType(const IfcDistributionControlElementType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDistributionControlElementType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDistributionControlElementType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDistributionControlElementType  > &ExpressDataSet::getAllIfcDistributionControlElementType ()
{
    return m_refIfcDistributionControlElementTypeList;
}



IfcDistributionElement *ExpressDataSet::getIfcDistributionElement(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDistributionElement * > (current->second.get());
    }
    else
    {
        IfcDistributionElement *ret = static_cast< IfcDistributionElement * > (allocateIfcDistributionElement(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDistributionElement(IfcDistributionElement *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDistributionElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDistributionElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDistributionElement *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDistributionElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDistributionElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDistributionElement > ExpressDataSet::createIfcDistributionElement(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDistributionElement(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDistributionElement * > (allocateIfcDistributionElement(this, Step::Id_UNSET));
    }
}

IfcDistributionElement *ExpressDataSet::cloneIfcDistributionElement(ExpressDataSet *expressDataSet, const IfcDistributionElement &obj, const CopyOp &copyop)
{
    IfcDistributionElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDistributionElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDistributionElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDistributionElement *ExpressDataSet::cloneIfcDistributionElement(const IfcDistributionElement &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDistributionElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDistributionElement(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDistributionElement  > &ExpressDataSet::getAllIfcDistributionElement ()
{
    return m_refIfcDistributionElementList;
}



IfcDistributionElementType *ExpressDataSet::getIfcDistributionElementType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDistributionElementType * > (current->second.get());
    }
    else
    {
        IfcDistributionElementType *ret = static_cast< IfcDistributionElementType * > (allocateIfcDistributionElementType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDistributionElementType(IfcDistributionElementType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDistributionElementType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDistributionElementType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDistributionElementType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDistributionElementType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDistributionElementType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDistributionElementType > ExpressDataSet::createIfcDistributionElementType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDistributionElementType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDistributionElementType * > (allocateIfcDistributionElementType(this, Step::Id_UNSET));
    }
}

IfcDistributionElementType *ExpressDataSet::cloneIfcDistributionElementType(ExpressDataSet *expressDataSet, const IfcDistributionElementType &obj, const CopyOp &copyop)
{
    IfcDistributionElementType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDistributionElementType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDistributionElementType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDistributionElementType *ExpressDataSet::cloneIfcDistributionElementType(const IfcDistributionElementType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDistributionElementType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDistributionElementType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDistributionElementType  > &ExpressDataSet::getAllIfcDistributionElementType ()
{
    return m_refIfcDistributionElementTypeList;
}



IfcDistributionFlowElement *ExpressDataSet::getIfcDistributionFlowElement(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDistributionFlowElement * > (current->second.get());
    }
    else
    {
        IfcDistributionFlowElement *ret = static_cast< IfcDistributionFlowElement * > (allocateIfcDistributionFlowElement(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDistributionFlowElement(IfcDistributionFlowElement *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDistributionFlowElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDistributionFlowElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDistributionFlowElement *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDistributionFlowElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDistributionFlowElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDistributionFlowElement > ExpressDataSet::createIfcDistributionFlowElement(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDistributionFlowElement(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDistributionFlowElement * > (allocateIfcDistributionFlowElement(this, Step::Id_UNSET));
    }
}

IfcDistributionFlowElement *ExpressDataSet::cloneIfcDistributionFlowElement(ExpressDataSet *expressDataSet, const IfcDistributionFlowElement &obj, const CopyOp &copyop)
{
    IfcDistributionFlowElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDistributionFlowElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDistributionFlowElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDistributionFlowElement *ExpressDataSet::cloneIfcDistributionFlowElement(const IfcDistributionFlowElement &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDistributionFlowElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDistributionFlowElement(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDistributionFlowElement  > &ExpressDataSet::getAllIfcDistributionFlowElement ()
{
    return m_refIfcDistributionFlowElementList;
}



IfcDistributionFlowElementType *ExpressDataSet::getIfcDistributionFlowElementType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDistributionFlowElementType * > (current->second.get());
    }
    else
    {
        IfcDistributionFlowElementType *ret = static_cast< IfcDistributionFlowElementType * > (allocateIfcDistributionFlowElementType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDistributionFlowElementType(IfcDistributionFlowElementType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDistributionFlowElementType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDistributionFlowElementType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDistributionFlowElementType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDistributionFlowElementType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDistributionFlowElementType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDistributionFlowElementType > ExpressDataSet::createIfcDistributionFlowElementType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDistributionFlowElementType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDistributionFlowElementType * > (allocateIfcDistributionFlowElementType(this, Step::Id_UNSET));
    }
}

IfcDistributionFlowElementType *ExpressDataSet::cloneIfcDistributionFlowElementType(ExpressDataSet *expressDataSet, const IfcDistributionFlowElementType &obj, const CopyOp &copyop)
{
    IfcDistributionFlowElementType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDistributionFlowElementType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDistributionFlowElementType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDistributionFlowElementType *ExpressDataSet::cloneIfcDistributionFlowElementType(const IfcDistributionFlowElementType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDistributionFlowElementType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDistributionFlowElementType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDistributionFlowElementType  > &ExpressDataSet::getAllIfcDistributionFlowElementType ()
{
    return m_refIfcDistributionFlowElementTypeList;
}



IfcDistributionPort *ExpressDataSet::getIfcDistributionPort(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDistributionPort * > (current->second.get());
    }
    else
    {
        IfcDistributionPort *ret = static_cast< IfcDistributionPort * > (allocateIfcDistributionPort(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDistributionPort(IfcDistributionPort *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDistributionPort_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDistributionPort(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDistributionPort *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDistributionPort(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDistributionPort_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDistributionPort > ExpressDataSet::createIfcDistributionPort(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDistributionPort(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDistributionPort * > (allocateIfcDistributionPort(this, Step::Id_UNSET));
    }
}

IfcDistributionPort *ExpressDataSet::cloneIfcDistributionPort(ExpressDataSet *expressDataSet, const IfcDistributionPort &obj, const CopyOp &copyop)
{
    IfcDistributionPort *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDistributionPort(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDistributionPort_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDistributionPort *ExpressDataSet::cloneIfcDistributionPort(const IfcDistributionPort &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDistributionPort(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDistributionPort(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDistributionPort  > &ExpressDataSet::getAllIfcDistributionPort ()
{
    return m_refIfcDistributionPortList;
}



IfcDocumentElectronicFormat *ExpressDataSet::getIfcDocumentElectronicFormat(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDocumentElectronicFormat * > (current->second.get());
    }
    else
    {
        IfcDocumentElectronicFormat *ret = static_cast< IfcDocumentElectronicFormat * > (allocateIfcDocumentElectronicFormat(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDocumentElectronicFormat(IfcDocumentElectronicFormat *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDocumentElectronicFormat_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDocumentElectronicFormat(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDocumentElectronicFormat *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDocumentElectronicFormat(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDocumentElectronicFormat_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDocumentElectronicFormat > ExpressDataSet::createIfcDocumentElectronicFormat(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDocumentElectronicFormat(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDocumentElectronicFormat * > (allocateIfcDocumentElectronicFormat(this, Step::Id_UNSET));
    }
}

IfcDocumentElectronicFormat *ExpressDataSet::cloneIfcDocumentElectronicFormat(ExpressDataSet *expressDataSet, const IfcDocumentElectronicFormat &obj, const CopyOp &copyop)
{
    IfcDocumentElectronicFormat *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDocumentElectronicFormat(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDocumentElectronicFormat_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDocumentElectronicFormat *ExpressDataSet::cloneIfcDocumentElectronicFormat(const IfcDocumentElectronicFormat &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDocumentElectronicFormat(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDocumentElectronicFormat(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDocumentElectronicFormat  > &ExpressDataSet::getAllIfcDocumentElectronicFormat ()
{
    return m_refIfcDocumentElectronicFormatList;
}



IfcDocumentInformation *ExpressDataSet::getIfcDocumentInformation(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDocumentInformation * > (current->second.get());
    }
    else
    {
        IfcDocumentInformation *ret = static_cast< IfcDocumentInformation * > (allocateIfcDocumentInformation(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDocumentInformation(IfcDocumentInformation *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDocumentInformation_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDocumentInformation(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDocumentInformation *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDocumentInformation(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDocumentInformation_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDocumentInformation > ExpressDataSet::createIfcDocumentInformation(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDocumentInformation(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDocumentInformation * > (allocateIfcDocumentInformation(this, Step::Id_UNSET));
    }
}

IfcDocumentInformation *ExpressDataSet::cloneIfcDocumentInformation(ExpressDataSet *expressDataSet, const IfcDocumentInformation &obj, const CopyOp &copyop)
{
    IfcDocumentInformation *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDocumentInformation(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDocumentInformation_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDocumentInformation *ExpressDataSet::cloneIfcDocumentInformation(const IfcDocumentInformation &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDocumentInformation(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDocumentInformation(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDocumentInformation  > &ExpressDataSet::getAllIfcDocumentInformation ()
{
    return m_refIfcDocumentInformationList;
}



IfcDocumentInformationRelationship *ExpressDataSet::getIfcDocumentInformationRelationship(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDocumentInformationRelationship * > (current->second.get());
    }
    else
    {
        IfcDocumentInformationRelationship *ret = static_cast< IfcDocumentInformationRelationship * > (allocateIfcDocumentInformationRelationship(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDocumentInformationRelationship(IfcDocumentInformationRelationship *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDocumentInformationRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDocumentInformationRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDocumentInformationRelationship *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDocumentInformationRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDocumentInformationRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDocumentInformationRelationship > ExpressDataSet::createIfcDocumentInformationRelationship(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDocumentInformationRelationship(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDocumentInformationRelationship * > (allocateIfcDocumentInformationRelationship(this, Step::Id_UNSET));
    }
}

IfcDocumentInformationRelationship *ExpressDataSet::cloneIfcDocumentInformationRelationship(ExpressDataSet *expressDataSet, const IfcDocumentInformationRelationship &obj, const CopyOp &copyop)
{
    IfcDocumentInformationRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDocumentInformationRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDocumentInformationRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDocumentInformationRelationship *ExpressDataSet::cloneIfcDocumentInformationRelationship(const IfcDocumentInformationRelationship &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDocumentInformationRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDocumentInformationRelationship(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDocumentInformationRelationship  > &ExpressDataSet::getAllIfcDocumentInformationRelationship ()
{
    return m_refIfcDocumentInformationRelationshipList;
}



IfcDocumentReference *ExpressDataSet::getIfcDocumentReference(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDocumentReference * > (current->second.get());
    }
    else
    {
        IfcDocumentReference *ret = static_cast< IfcDocumentReference * > (allocateIfcDocumentReference(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDocumentReference(IfcDocumentReference *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDocumentReference_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDocumentReference(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDocumentReference *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDocumentReference(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDocumentReference_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDocumentReference > ExpressDataSet::createIfcDocumentReference(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDocumentReference(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDocumentReference * > (allocateIfcDocumentReference(this, Step::Id_UNSET));
    }
}

IfcDocumentReference *ExpressDataSet::cloneIfcDocumentReference(ExpressDataSet *expressDataSet, const IfcDocumentReference &obj, const CopyOp &copyop)
{
    IfcDocumentReference *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDocumentReference(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDocumentReference_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDocumentReference *ExpressDataSet::cloneIfcDocumentReference(const IfcDocumentReference &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDocumentReference(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDocumentReference(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDocumentReference  > &ExpressDataSet::getAllIfcDocumentReference ()
{
    return m_refIfcDocumentReferenceList;
}



IfcDoor *ExpressDataSet::getIfcDoor(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDoor * > (current->second.get());
    }
    else
    {
        IfcDoor *ret = static_cast< IfcDoor * > (allocateIfcDoor(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDoor(IfcDoor *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDoor_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDoor(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDoor *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDoor(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDoor_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDoor > ExpressDataSet::createIfcDoor(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDoor(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDoor * > (allocateIfcDoor(this, Step::Id_UNSET));
    }
}

IfcDoor *ExpressDataSet::cloneIfcDoor(ExpressDataSet *expressDataSet, const IfcDoor &obj, const CopyOp &copyop)
{
    IfcDoor *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDoor(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDoor_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDoor *ExpressDataSet::cloneIfcDoor(const IfcDoor &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDoor(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDoor(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDoor  > &ExpressDataSet::getAllIfcDoor ()
{
    return m_refIfcDoorList;
}



IfcDoorLiningProperties *ExpressDataSet::getIfcDoorLiningProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDoorLiningProperties * > (current->second.get());
    }
    else
    {
        IfcDoorLiningProperties *ret = static_cast< IfcDoorLiningProperties * > (allocateIfcDoorLiningProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDoorLiningProperties(IfcDoorLiningProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDoorLiningProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDoorLiningProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDoorLiningProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDoorLiningProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDoorLiningProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDoorLiningProperties > ExpressDataSet::createIfcDoorLiningProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDoorLiningProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDoorLiningProperties * > (allocateIfcDoorLiningProperties(this, Step::Id_UNSET));
    }
}

IfcDoorLiningProperties *ExpressDataSet::cloneIfcDoorLiningProperties(ExpressDataSet *expressDataSet, const IfcDoorLiningProperties &obj, const CopyOp &copyop)
{
    IfcDoorLiningProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDoorLiningProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDoorLiningProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDoorLiningProperties *ExpressDataSet::cloneIfcDoorLiningProperties(const IfcDoorLiningProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDoorLiningProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDoorLiningProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDoorLiningProperties  > &ExpressDataSet::getAllIfcDoorLiningProperties ()
{
    return m_refIfcDoorLiningPropertiesList;
}



IfcDoorPanelProperties *ExpressDataSet::getIfcDoorPanelProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDoorPanelProperties * > (current->second.get());
    }
    else
    {
        IfcDoorPanelProperties *ret = static_cast< IfcDoorPanelProperties * > (allocateIfcDoorPanelProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDoorPanelProperties(IfcDoorPanelProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDoorPanelProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDoorPanelProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDoorPanelProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDoorPanelProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDoorPanelProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDoorPanelProperties > ExpressDataSet::createIfcDoorPanelProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDoorPanelProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDoorPanelProperties * > (allocateIfcDoorPanelProperties(this, Step::Id_UNSET));
    }
}

IfcDoorPanelProperties *ExpressDataSet::cloneIfcDoorPanelProperties(ExpressDataSet *expressDataSet, const IfcDoorPanelProperties &obj, const CopyOp &copyop)
{
    IfcDoorPanelProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDoorPanelProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDoorPanelProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDoorPanelProperties *ExpressDataSet::cloneIfcDoorPanelProperties(const IfcDoorPanelProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDoorPanelProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDoorPanelProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDoorPanelProperties  > &ExpressDataSet::getAllIfcDoorPanelProperties ()
{
    return m_refIfcDoorPanelPropertiesList;
}



IfcDoorStyle *ExpressDataSet::getIfcDoorStyle(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDoorStyle * > (current->second.get());
    }
    else
    {
        IfcDoorStyle *ret = static_cast< IfcDoorStyle * > (allocateIfcDoorStyle(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDoorStyle(IfcDoorStyle *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDoorStyle_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDoorStyle(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDoorStyle *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDoorStyle(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDoorStyle_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDoorStyle > ExpressDataSet::createIfcDoorStyle(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDoorStyle(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDoorStyle * > (allocateIfcDoorStyle(this, Step::Id_UNSET));
    }
}

IfcDoorStyle *ExpressDataSet::cloneIfcDoorStyle(ExpressDataSet *expressDataSet, const IfcDoorStyle &obj, const CopyOp &copyop)
{
    IfcDoorStyle *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDoorStyle(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDoorStyle_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDoorStyle *ExpressDataSet::cloneIfcDoorStyle(const IfcDoorStyle &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDoorStyle(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDoorStyle(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDoorStyle  > &ExpressDataSet::getAllIfcDoorStyle ()
{
    return m_refIfcDoorStyleList;
}



IfcDraughtingCallout *ExpressDataSet::getIfcDraughtingCallout(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDraughtingCallout * > (current->second.get());
    }
    else
    {
        IfcDraughtingCallout *ret = static_cast< IfcDraughtingCallout * > (allocateIfcDraughtingCallout(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDraughtingCallout(IfcDraughtingCallout *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDraughtingCallout_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDraughtingCallout(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDraughtingCallout *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDraughtingCallout(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDraughtingCallout_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDraughtingCallout > ExpressDataSet::createIfcDraughtingCallout(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDraughtingCallout(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDraughtingCallout * > (allocateIfcDraughtingCallout(this, Step::Id_UNSET));
    }
}

IfcDraughtingCallout *ExpressDataSet::cloneIfcDraughtingCallout(ExpressDataSet *expressDataSet, const IfcDraughtingCallout &obj, const CopyOp &copyop)
{
    IfcDraughtingCallout *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDraughtingCallout(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDraughtingCallout_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDraughtingCallout *ExpressDataSet::cloneIfcDraughtingCallout(const IfcDraughtingCallout &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDraughtingCallout(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDraughtingCallout(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDraughtingCallout  > &ExpressDataSet::getAllIfcDraughtingCallout ()
{
    return m_refIfcDraughtingCalloutList;
}



IfcDraughtingCalloutRelationship *ExpressDataSet::getIfcDraughtingCalloutRelationship(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDraughtingCalloutRelationship * > (current->second.get());
    }
    else
    {
        IfcDraughtingCalloutRelationship *ret = static_cast< IfcDraughtingCalloutRelationship * > (allocateIfcDraughtingCalloutRelationship(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDraughtingCalloutRelationship(IfcDraughtingCalloutRelationship *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDraughtingCalloutRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDraughtingCalloutRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDraughtingCalloutRelationship *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDraughtingCalloutRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDraughtingCalloutRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDraughtingCalloutRelationship > ExpressDataSet::createIfcDraughtingCalloutRelationship(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDraughtingCalloutRelationship(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDraughtingCalloutRelationship * > (allocateIfcDraughtingCalloutRelationship(this, Step::Id_UNSET));
    }
}

IfcDraughtingCalloutRelationship *ExpressDataSet::cloneIfcDraughtingCalloutRelationship(ExpressDataSet *expressDataSet, const IfcDraughtingCalloutRelationship &obj, const CopyOp &copyop)
{
    IfcDraughtingCalloutRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDraughtingCalloutRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDraughtingCalloutRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDraughtingCalloutRelationship *ExpressDataSet::cloneIfcDraughtingCalloutRelationship(const IfcDraughtingCalloutRelationship &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDraughtingCalloutRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDraughtingCalloutRelationship(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDraughtingCalloutRelationship  > &ExpressDataSet::getAllIfcDraughtingCalloutRelationship ()
{
    return m_refIfcDraughtingCalloutRelationshipList;
}



IfcDraughtingPreDefinedColour *ExpressDataSet::getIfcDraughtingPreDefinedColour(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDraughtingPreDefinedColour * > (current->second.get());
    }
    else
    {
        IfcDraughtingPreDefinedColour *ret = static_cast< IfcDraughtingPreDefinedColour * > (allocateIfcDraughtingPreDefinedColour(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDraughtingPreDefinedColour(IfcDraughtingPreDefinedColour *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDraughtingPreDefinedColour_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDraughtingPreDefinedColour(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDraughtingPreDefinedColour *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDraughtingPreDefinedColour(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDraughtingPreDefinedColour_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDraughtingPreDefinedColour > ExpressDataSet::createIfcDraughtingPreDefinedColour(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDraughtingPreDefinedColour(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDraughtingPreDefinedColour * > (allocateIfcDraughtingPreDefinedColour(this, Step::Id_UNSET));
    }
}

IfcDraughtingPreDefinedColour *ExpressDataSet::cloneIfcDraughtingPreDefinedColour(ExpressDataSet *expressDataSet, const IfcDraughtingPreDefinedColour &obj, const CopyOp &copyop)
{
    IfcDraughtingPreDefinedColour *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDraughtingPreDefinedColour(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDraughtingPreDefinedColour_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDraughtingPreDefinedColour *ExpressDataSet::cloneIfcDraughtingPreDefinedColour(const IfcDraughtingPreDefinedColour &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDraughtingPreDefinedColour(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDraughtingPreDefinedColour(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDraughtingPreDefinedColour  > &ExpressDataSet::getAllIfcDraughtingPreDefinedColour ()
{
    return m_refIfcDraughtingPreDefinedColourList;
}



IfcDraughtingPreDefinedCurveFont *ExpressDataSet::getIfcDraughtingPreDefinedCurveFont(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDraughtingPreDefinedCurveFont * > (current->second.get());
    }
    else
    {
        IfcDraughtingPreDefinedCurveFont *ret = static_cast< IfcDraughtingPreDefinedCurveFont * > (allocateIfcDraughtingPreDefinedCurveFont(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDraughtingPreDefinedCurveFont(IfcDraughtingPreDefinedCurveFont *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDraughtingPreDefinedCurveFont_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDraughtingPreDefinedCurveFont(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDraughtingPreDefinedCurveFont *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDraughtingPreDefinedCurveFont(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDraughtingPreDefinedCurveFont_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDraughtingPreDefinedCurveFont > ExpressDataSet::createIfcDraughtingPreDefinedCurveFont(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDraughtingPreDefinedCurveFont(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDraughtingPreDefinedCurveFont * > (allocateIfcDraughtingPreDefinedCurveFont(this, Step::Id_UNSET));
    }
}

IfcDraughtingPreDefinedCurveFont *ExpressDataSet::cloneIfcDraughtingPreDefinedCurveFont(ExpressDataSet *expressDataSet, const IfcDraughtingPreDefinedCurveFont &obj, const CopyOp &copyop)
{
    IfcDraughtingPreDefinedCurveFont *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDraughtingPreDefinedCurveFont(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDraughtingPreDefinedCurveFont_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDraughtingPreDefinedCurveFont *ExpressDataSet::cloneIfcDraughtingPreDefinedCurveFont(const IfcDraughtingPreDefinedCurveFont &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDraughtingPreDefinedCurveFont(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDraughtingPreDefinedCurveFont(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDraughtingPreDefinedCurveFont  > &ExpressDataSet::getAllIfcDraughtingPreDefinedCurveFont ()
{
    return m_refIfcDraughtingPreDefinedCurveFontList;
}



IfcDraughtingPreDefinedTextFont *ExpressDataSet::getIfcDraughtingPreDefinedTextFont(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDraughtingPreDefinedTextFont * > (current->second.get());
    }
    else
    {
        IfcDraughtingPreDefinedTextFont *ret = static_cast< IfcDraughtingPreDefinedTextFont * > (allocateIfcDraughtingPreDefinedTextFont(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDraughtingPreDefinedTextFont(IfcDraughtingPreDefinedTextFont *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDraughtingPreDefinedTextFont_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDraughtingPreDefinedTextFont(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDraughtingPreDefinedTextFont *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDraughtingPreDefinedTextFont(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDraughtingPreDefinedTextFont_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDraughtingPreDefinedTextFont > ExpressDataSet::createIfcDraughtingPreDefinedTextFont(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDraughtingPreDefinedTextFont(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDraughtingPreDefinedTextFont * > (allocateIfcDraughtingPreDefinedTextFont(this, Step::Id_UNSET));
    }
}

IfcDraughtingPreDefinedTextFont *ExpressDataSet::cloneIfcDraughtingPreDefinedTextFont(ExpressDataSet *expressDataSet, const IfcDraughtingPreDefinedTextFont &obj, const CopyOp &copyop)
{
    IfcDraughtingPreDefinedTextFont *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDraughtingPreDefinedTextFont(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDraughtingPreDefinedTextFont_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDraughtingPreDefinedTextFont *ExpressDataSet::cloneIfcDraughtingPreDefinedTextFont(const IfcDraughtingPreDefinedTextFont &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDraughtingPreDefinedTextFont(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDraughtingPreDefinedTextFont(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDraughtingPreDefinedTextFont  > &ExpressDataSet::getAllIfcDraughtingPreDefinedTextFont ()
{
    return m_refIfcDraughtingPreDefinedTextFontList;
}



IfcDuctFittingType *ExpressDataSet::getIfcDuctFittingType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDuctFittingType * > (current->second.get());
    }
    else
    {
        IfcDuctFittingType *ret = static_cast< IfcDuctFittingType * > (allocateIfcDuctFittingType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDuctFittingType(IfcDuctFittingType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDuctFittingType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDuctFittingType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDuctFittingType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDuctFittingType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDuctFittingType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDuctFittingType > ExpressDataSet::createIfcDuctFittingType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDuctFittingType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDuctFittingType * > (allocateIfcDuctFittingType(this, Step::Id_UNSET));
    }
}

IfcDuctFittingType *ExpressDataSet::cloneIfcDuctFittingType(ExpressDataSet *expressDataSet, const IfcDuctFittingType &obj, const CopyOp &copyop)
{
    IfcDuctFittingType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDuctFittingType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDuctFittingType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDuctFittingType *ExpressDataSet::cloneIfcDuctFittingType(const IfcDuctFittingType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDuctFittingType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDuctFittingType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDuctFittingType  > &ExpressDataSet::getAllIfcDuctFittingType ()
{
    return m_refIfcDuctFittingTypeList;
}



IfcDuctSegmentType *ExpressDataSet::getIfcDuctSegmentType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDuctSegmentType * > (current->second.get());
    }
    else
    {
        IfcDuctSegmentType *ret = static_cast< IfcDuctSegmentType * > (allocateIfcDuctSegmentType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDuctSegmentType(IfcDuctSegmentType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDuctSegmentType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDuctSegmentType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDuctSegmentType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDuctSegmentType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDuctSegmentType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDuctSegmentType > ExpressDataSet::createIfcDuctSegmentType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDuctSegmentType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDuctSegmentType * > (allocateIfcDuctSegmentType(this, Step::Id_UNSET));
    }
}

IfcDuctSegmentType *ExpressDataSet::cloneIfcDuctSegmentType(ExpressDataSet *expressDataSet, const IfcDuctSegmentType &obj, const CopyOp &copyop)
{
    IfcDuctSegmentType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDuctSegmentType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDuctSegmentType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDuctSegmentType *ExpressDataSet::cloneIfcDuctSegmentType(const IfcDuctSegmentType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDuctSegmentType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDuctSegmentType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDuctSegmentType  > &ExpressDataSet::getAllIfcDuctSegmentType ()
{
    return m_refIfcDuctSegmentTypeList;
}



IfcDuctSilencerType *ExpressDataSet::getIfcDuctSilencerType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcDuctSilencerType * > (current->second.get());
    }
    else
    {
        IfcDuctSilencerType *ret = static_cast< IfcDuctSilencerType * > (allocateIfcDuctSilencerType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcDuctSilencerType(IfcDuctSilencerType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcDuctSilencerType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDuctSilencerType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcDuctSilencerType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDuctSilencerType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDuctSilencerType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDuctSilencerType > ExpressDataSet::createIfcDuctSilencerType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcDuctSilencerType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcDuctSilencerType * > (allocateIfcDuctSilencerType(this, Step::Id_UNSET));
    }
}

IfcDuctSilencerType *ExpressDataSet::cloneIfcDuctSilencerType(ExpressDataSet *expressDataSet, const IfcDuctSilencerType &obj, const CopyOp &copyop)
{
    IfcDuctSilencerType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDuctSilencerType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDuctSilencerType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDuctSilencerType *ExpressDataSet::cloneIfcDuctSilencerType(const IfcDuctSilencerType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcDuctSilencerType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcDuctSilencerType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcDuctSilencerType  > &ExpressDataSet::getAllIfcDuctSilencerType ()
{
    return m_refIfcDuctSilencerTypeList;
}



IfcEdge *ExpressDataSet::getIfcEdge(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcEdge * > (current->second.get());
    }
    else
    {
        IfcEdge *ret = static_cast< IfcEdge * > (allocateIfcEdge(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcEdge(IfcEdge *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcEdge_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcEdge(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcEdge *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcEdge(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcEdge_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcEdge > ExpressDataSet::createIfcEdge(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcEdge(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcEdge * > (allocateIfcEdge(this, Step::Id_UNSET));
    }
}

IfcEdge *ExpressDataSet::cloneIfcEdge(ExpressDataSet *expressDataSet, const IfcEdge &obj, const CopyOp &copyop)
{
    IfcEdge *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcEdge(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcEdge_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcEdge *ExpressDataSet::cloneIfcEdge(const IfcEdge &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcEdge(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcEdge(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcEdge  > &ExpressDataSet::getAllIfcEdge ()
{
    return m_refIfcEdgeList;
}



IfcEdgeCurve *ExpressDataSet::getIfcEdgeCurve(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcEdgeCurve * > (current->second.get());
    }
    else
    {
        IfcEdgeCurve *ret = static_cast< IfcEdgeCurve * > (allocateIfcEdgeCurve(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcEdgeCurve(IfcEdgeCurve *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcEdgeCurve_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcEdgeCurve(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcEdgeCurve *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcEdgeCurve(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcEdgeCurve_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcEdgeCurve > ExpressDataSet::createIfcEdgeCurve(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcEdgeCurve(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcEdgeCurve * > (allocateIfcEdgeCurve(this, Step::Id_UNSET));
    }
}

IfcEdgeCurve *ExpressDataSet::cloneIfcEdgeCurve(ExpressDataSet *expressDataSet, const IfcEdgeCurve &obj, const CopyOp &copyop)
{
    IfcEdgeCurve *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcEdgeCurve(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcEdgeCurve_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcEdgeCurve *ExpressDataSet::cloneIfcEdgeCurve(const IfcEdgeCurve &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcEdgeCurve(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcEdgeCurve(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcEdgeCurve  > &ExpressDataSet::getAllIfcEdgeCurve ()
{
    return m_refIfcEdgeCurveList;
}



IfcEdgeFeature *ExpressDataSet::getIfcEdgeFeature(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcEdgeFeature * > (current->second.get());
    }
    else
    {
        IfcEdgeFeature *ret = static_cast< IfcEdgeFeature * > (allocateIfcEdgeFeature(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcEdgeFeature(IfcEdgeFeature *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcEdgeFeature_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcEdgeFeature(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcEdgeFeature *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcEdgeFeature(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcEdgeFeature_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcEdgeFeature > ExpressDataSet::createIfcEdgeFeature(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcEdgeFeature(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcEdgeFeature * > (allocateIfcEdgeFeature(this, Step::Id_UNSET));
    }
}

IfcEdgeFeature *ExpressDataSet::cloneIfcEdgeFeature(ExpressDataSet *expressDataSet, const IfcEdgeFeature &obj, const CopyOp &copyop)
{
    IfcEdgeFeature *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcEdgeFeature(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcEdgeFeature_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcEdgeFeature *ExpressDataSet::cloneIfcEdgeFeature(const IfcEdgeFeature &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcEdgeFeature(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcEdgeFeature(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcEdgeFeature  > &ExpressDataSet::getAllIfcEdgeFeature ()
{
    return m_refIfcEdgeFeatureList;
}



IfcEdgeLoop *ExpressDataSet::getIfcEdgeLoop(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcEdgeLoop * > (current->second.get());
    }
    else
    {
        IfcEdgeLoop *ret = static_cast< IfcEdgeLoop * > (allocateIfcEdgeLoop(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcEdgeLoop(IfcEdgeLoop *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcEdgeLoop_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcEdgeLoop(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcEdgeLoop *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcEdgeLoop(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcEdgeLoop_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcEdgeLoop > ExpressDataSet::createIfcEdgeLoop(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcEdgeLoop(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcEdgeLoop * > (allocateIfcEdgeLoop(this, Step::Id_UNSET));
    }
}

IfcEdgeLoop *ExpressDataSet::cloneIfcEdgeLoop(ExpressDataSet *expressDataSet, const IfcEdgeLoop &obj, const CopyOp &copyop)
{
    IfcEdgeLoop *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcEdgeLoop(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcEdgeLoop_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcEdgeLoop *ExpressDataSet::cloneIfcEdgeLoop(const IfcEdgeLoop &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcEdgeLoop(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcEdgeLoop(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcEdgeLoop  > &ExpressDataSet::getAllIfcEdgeLoop ()
{
    return m_refIfcEdgeLoopList;
}



IfcElectricalBaseProperties *ExpressDataSet::getIfcElectricalBaseProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcElectricalBaseProperties * > (current->second.get());
    }
    else
    {
        IfcElectricalBaseProperties *ret = static_cast< IfcElectricalBaseProperties * > (allocateIfcElectricalBaseProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcElectricalBaseProperties(IfcElectricalBaseProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcElectricalBaseProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElectricalBaseProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcElectricalBaseProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElectricalBaseProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElectricalBaseProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElectricalBaseProperties > ExpressDataSet::createIfcElectricalBaseProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcElectricalBaseProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcElectricalBaseProperties * > (allocateIfcElectricalBaseProperties(this, Step::Id_UNSET));
    }
}

IfcElectricalBaseProperties *ExpressDataSet::cloneIfcElectricalBaseProperties(ExpressDataSet *expressDataSet, const IfcElectricalBaseProperties &obj, const CopyOp &copyop)
{
    IfcElectricalBaseProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElectricalBaseProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElectricalBaseProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElectricalBaseProperties *ExpressDataSet::cloneIfcElectricalBaseProperties(const IfcElectricalBaseProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcElectricalBaseProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcElectricalBaseProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcElectricalBaseProperties  > &ExpressDataSet::getAllIfcElectricalBaseProperties ()
{
    return m_refIfcElectricalBasePropertiesList;
}



IfcElectricalCircuit *ExpressDataSet::getIfcElectricalCircuit(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcElectricalCircuit * > (current->second.get());
    }
    else
    {
        IfcElectricalCircuit *ret = static_cast< IfcElectricalCircuit * > (allocateIfcElectricalCircuit(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcElectricalCircuit(IfcElectricalCircuit *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcElectricalCircuit_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElectricalCircuit(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcElectricalCircuit *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElectricalCircuit(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElectricalCircuit_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElectricalCircuit > ExpressDataSet::createIfcElectricalCircuit(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcElectricalCircuit(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcElectricalCircuit * > (allocateIfcElectricalCircuit(this, Step::Id_UNSET));
    }
}

IfcElectricalCircuit *ExpressDataSet::cloneIfcElectricalCircuit(ExpressDataSet *expressDataSet, const IfcElectricalCircuit &obj, const CopyOp &copyop)
{
    IfcElectricalCircuit *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElectricalCircuit(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElectricalCircuit_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElectricalCircuit *ExpressDataSet::cloneIfcElectricalCircuit(const IfcElectricalCircuit &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcElectricalCircuit(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcElectricalCircuit(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcElectricalCircuit  > &ExpressDataSet::getAllIfcElectricalCircuit ()
{
    return m_refIfcElectricalCircuitList;
}



IfcElectricalElement *ExpressDataSet::getIfcElectricalElement(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcElectricalElement * > (current->second.get());
    }
    else
    {
        IfcElectricalElement *ret = static_cast< IfcElectricalElement * > (allocateIfcElectricalElement(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcElectricalElement(IfcElectricalElement *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcElectricalElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElectricalElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcElectricalElement *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElectricalElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElectricalElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElectricalElement > ExpressDataSet::createIfcElectricalElement(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcElectricalElement(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcElectricalElement * > (allocateIfcElectricalElement(this, Step::Id_UNSET));
    }
}

IfcElectricalElement *ExpressDataSet::cloneIfcElectricalElement(ExpressDataSet *expressDataSet, const IfcElectricalElement &obj, const CopyOp &copyop)
{
    IfcElectricalElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElectricalElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElectricalElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElectricalElement *ExpressDataSet::cloneIfcElectricalElement(const IfcElectricalElement &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcElectricalElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcElectricalElement(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcElectricalElement  > &ExpressDataSet::getAllIfcElectricalElement ()
{
    return m_refIfcElectricalElementList;
}



IfcElectricApplianceType *ExpressDataSet::getIfcElectricApplianceType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcElectricApplianceType * > (current->second.get());
    }
    else
    {
        IfcElectricApplianceType *ret = static_cast< IfcElectricApplianceType * > (allocateIfcElectricApplianceType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcElectricApplianceType(IfcElectricApplianceType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcElectricApplianceType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElectricApplianceType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcElectricApplianceType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElectricApplianceType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElectricApplianceType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElectricApplianceType > ExpressDataSet::createIfcElectricApplianceType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcElectricApplianceType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcElectricApplianceType * > (allocateIfcElectricApplianceType(this, Step::Id_UNSET));
    }
}

IfcElectricApplianceType *ExpressDataSet::cloneIfcElectricApplianceType(ExpressDataSet *expressDataSet, const IfcElectricApplianceType &obj, const CopyOp &copyop)
{
    IfcElectricApplianceType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElectricApplianceType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElectricApplianceType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElectricApplianceType *ExpressDataSet::cloneIfcElectricApplianceType(const IfcElectricApplianceType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcElectricApplianceType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcElectricApplianceType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcElectricApplianceType  > &ExpressDataSet::getAllIfcElectricApplianceType ()
{
    return m_refIfcElectricApplianceTypeList;
}



IfcElectricDistributionPoint *ExpressDataSet::getIfcElectricDistributionPoint(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcElectricDistributionPoint * > (current->second.get());
    }
    else
    {
        IfcElectricDistributionPoint *ret = static_cast< IfcElectricDistributionPoint * > (allocateIfcElectricDistributionPoint(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcElectricDistributionPoint(IfcElectricDistributionPoint *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcElectricDistributionPoint_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElectricDistributionPoint(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcElectricDistributionPoint *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElectricDistributionPoint(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElectricDistributionPoint_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElectricDistributionPoint > ExpressDataSet::createIfcElectricDistributionPoint(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcElectricDistributionPoint(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcElectricDistributionPoint * > (allocateIfcElectricDistributionPoint(this, Step::Id_UNSET));
    }
}

IfcElectricDistributionPoint *ExpressDataSet::cloneIfcElectricDistributionPoint(ExpressDataSet *expressDataSet, const IfcElectricDistributionPoint &obj, const CopyOp &copyop)
{
    IfcElectricDistributionPoint *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElectricDistributionPoint(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElectricDistributionPoint_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElectricDistributionPoint *ExpressDataSet::cloneIfcElectricDistributionPoint(const IfcElectricDistributionPoint &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcElectricDistributionPoint(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcElectricDistributionPoint(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcElectricDistributionPoint  > &ExpressDataSet::getAllIfcElectricDistributionPoint ()
{
    return m_refIfcElectricDistributionPointList;
}



IfcElectricFlowStorageDeviceType *ExpressDataSet::getIfcElectricFlowStorageDeviceType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcElectricFlowStorageDeviceType * > (current->second.get());
    }
    else
    {
        IfcElectricFlowStorageDeviceType *ret = static_cast< IfcElectricFlowStorageDeviceType * > (allocateIfcElectricFlowStorageDeviceType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcElectricFlowStorageDeviceType(IfcElectricFlowStorageDeviceType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcElectricFlowStorageDeviceType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElectricFlowStorageDeviceType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcElectricFlowStorageDeviceType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElectricFlowStorageDeviceType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElectricFlowStorageDeviceType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElectricFlowStorageDeviceType > ExpressDataSet::createIfcElectricFlowStorageDeviceType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcElectricFlowStorageDeviceType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcElectricFlowStorageDeviceType * > (allocateIfcElectricFlowStorageDeviceType(this, Step::Id_UNSET));
    }
}

IfcElectricFlowStorageDeviceType *ExpressDataSet::cloneIfcElectricFlowStorageDeviceType(ExpressDataSet *expressDataSet, const IfcElectricFlowStorageDeviceType &obj, const CopyOp &copyop)
{
    IfcElectricFlowStorageDeviceType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElectricFlowStorageDeviceType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElectricFlowStorageDeviceType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElectricFlowStorageDeviceType *ExpressDataSet::cloneIfcElectricFlowStorageDeviceType(const IfcElectricFlowStorageDeviceType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcElectricFlowStorageDeviceType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcElectricFlowStorageDeviceType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcElectricFlowStorageDeviceType  > &ExpressDataSet::getAllIfcElectricFlowStorageDeviceType ()
{
    return m_refIfcElectricFlowStorageDeviceTypeList;
}



IfcElectricGeneratorType *ExpressDataSet::getIfcElectricGeneratorType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcElectricGeneratorType * > (current->second.get());
    }
    else
    {
        IfcElectricGeneratorType *ret = static_cast< IfcElectricGeneratorType * > (allocateIfcElectricGeneratorType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcElectricGeneratorType(IfcElectricGeneratorType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcElectricGeneratorType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElectricGeneratorType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcElectricGeneratorType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElectricGeneratorType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElectricGeneratorType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElectricGeneratorType > ExpressDataSet::createIfcElectricGeneratorType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcElectricGeneratorType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcElectricGeneratorType * > (allocateIfcElectricGeneratorType(this, Step::Id_UNSET));
    }
}

IfcElectricGeneratorType *ExpressDataSet::cloneIfcElectricGeneratorType(ExpressDataSet *expressDataSet, const IfcElectricGeneratorType &obj, const CopyOp &copyop)
{
    IfcElectricGeneratorType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElectricGeneratorType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElectricGeneratorType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElectricGeneratorType *ExpressDataSet::cloneIfcElectricGeneratorType(const IfcElectricGeneratorType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcElectricGeneratorType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcElectricGeneratorType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcElectricGeneratorType  > &ExpressDataSet::getAllIfcElectricGeneratorType ()
{
    return m_refIfcElectricGeneratorTypeList;
}



IfcElectricHeaterType *ExpressDataSet::getIfcElectricHeaterType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcElectricHeaterType * > (current->second.get());
    }
    else
    {
        IfcElectricHeaterType *ret = static_cast< IfcElectricHeaterType * > (allocateIfcElectricHeaterType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcElectricHeaterType(IfcElectricHeaterType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcElectricHeaterType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElectricHeaterType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcElectricHeaterType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElectricHeaterType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElectricHeaterType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElectricHeaterType > ExpressDataSet::createIfcElectricHeaterType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcElectricHeaterType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcElectricHeaterType * > (allocateIfcElectricHeaterType(this, Step::Id_UNSET));
    }
}

IfcElectricHeaterType *ExpressDataSet::cloneIfcElectricHeaterType(ExpressDataSet *expressDataSet, const IfcElectricHeaterType &obj, const CopyOp &copyop)
{
    IfcElectricHeaterType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElectricHeaterType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElectricHeaterType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElectricHeaterType *ExpressDataSet::cloneIfcElectricHeaterType(const IfcElectricHeaterType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcElectricHeaterType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcElectricHeaterType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcElectricHeaterType  > &ExpressDataSet::getAllIfcElectricHeaterType ()
{
    return m_refIfcElectricHeaterTypeList;
}



IfcElectricMotorType *ExpressDataSet::getIfcElectricMotorType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcElectricMotorType * > (current->second.get());
    }
    else
    {
        IfcElectricMotorType *ret = static_cast< IfcElectricMotorType * > (allocateIfcElectricMotorType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcElectricMotorType(IfcElectricMotorType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcElectricMotorType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElectricMotorType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcElectricMotorType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElectricMotorType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElectricMotorType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElectricMotorType > ExpressDataSet::createIfcElectricMotorType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcElectricMotorType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcElectricMotorType * > (allocateIfcElectricMotorType(this, Step::Id_UNSET));
    }
}

IfcElectricMotorType *ExpressDataSet::cloneIfcElectricMotorType(ExpressDataSet *expressDataSet, const IfcElectricMotorType &obj, const CopyOp &copyop)
{
    IfcElectricMotorType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElectricMotorType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElectricMotorType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElectricMotorType *ExpressDataSet::cloneIfcElectricMotorType(const IfcElectricMotorType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcElectricMotorType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcElectricMotorType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcElectricMotorType  > &ExpressDataSet::getAllIfcElectricMotorType ()
{
    return m_refIfcElectricMotorTypeList;
}



IfcElectricTimeControlType *ExpressDataSet::getIfcElectricTimeControlType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcElectricTimeControlType * > (current->second.get());
    }
    else
    {
        IfcElectricTimeControlType *ret = static_cast< IfcElectricTimeControlType * > (allocateIfcElectricTimeControlType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcElectricTimeControlType(IfcElectricTimeControlType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcElectricTimeControlType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElectricTimeControlType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcElectricTimeControlType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElectricTimeControlType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElectricTimeControlType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElectricTimeControlType > ExpressDataSet::createIfcElectricTimeControlType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcElectricTimeControlType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcElectricTimeControlType * > (allocateIfcElectricTimeControlType(this, Step::Id_UNSET));
    }
}

IfcElectricTimeControlType *ExpressDataSet::cloneIfcElectricTimeControlType(ExpressDataSet *expressDataSet, const IfcElectricTimeControlType &obj, const CopyOp &copyop)
{
    IfcElectricTimeControlType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElectricTimeControlType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElectricTimeControlType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElectricTimeControlType *ExpressDataSet::cloneIfcElectricTimeControlType(const IfcElectricTimeControlType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcElectricTimeControlType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcElectricTimeControlType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcElectricTimeControlType  > &ExpressDataSet::getAllIfcElectricTimeControlType ()
{
    return m_refIfcElectricTimeControlTypeList;
}



IfcElement *ExpressDataSet::getIfcElement(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcElement * > (current->second.get());
    }
    else
    {
        IfcElement *ret = static_cast< IfcElement * > (allocateIfcElement(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcElement(IfcElement *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcElement *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElement > ExpressDataSet::createIfcElement(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcElement(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcElement * > (allocateIfcElement(this, Step::Id_UNSET));
    }
}

IfcElement *ExpressDataSet::cloneIfcElement(ExpressDataSet *expressDataSet, const IfcElement &obj, const CopyOp &copyop)
{
    IfcElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElement *ExpressDataSet::cloneIfcElement(const IfcElement &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcElement(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcElement  > &ExpressDataSet::getAllIfcElement ()
{
    return m_refIfcElementList;
}



IfcElementarySurface *ExpressDataSet::getIfcElementarySurface(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcElementarySurface * > (current->second.get());
    }
    else
    {
        IfcElementarySurface *ret = static_cast< IfcElementarySurface * > (allocateIfcElementarySurface(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcElementarySurface(IfcElementarySurface *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcElementarySurface_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElementarySurface(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcElementarySurface *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElementarySurface(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElementarySurface_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElementarySurface > ExpressDataSet::createIfcElementarySurface(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcElementarySurface(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcElementarySurface * > (allocateIfcElementarySurface(this, Step::Id_UNSET));
    }
}

IfcElementarySurface *ExpressDataSet::cloneIfcElementarySurface(ExpressDataSet *expressDataSet, const IfcElementarySurface &obj, const CopyOp &copyop)
{
    IfcElementarySurface *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElementarySurface(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElementarySurface_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElementarySurface *ExpressDataSet::cloneIfcElementarySurface(const IfcElementarySurface &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcElementarySurface(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcElementarySurface(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcElementarySurface  > &ExpressDataSet::getAllIfcElementarySurface ()
{
    return m_refIfcElementarySurfaceList;
}



IfcElementAssembly *ExpressDataSet::getIfcElementAssembly(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcElementAssembly * > (current->second.get());
    }
    else
    {
        IfcElementAssembly *ret = static_cast< IfcElementAssembly * > (allocateIfcElementAssembly(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcElementAssembly(IfcElementAssembly *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcElementAssembly_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElementAssembly(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcElementAssembly *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElementAssembly(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElementAssembly_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElementAssembly > ExpressDataSet::createIfcElementAssembly(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcElementAssembly(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcElementAssembly * > (allocateIfcElementAssembly(this, Step::Id_UNSET));
    }
}

IfcElementAssembly *ExpressDataSet::cloneIfcElementAssembly(ExpressDataSet *expressDataSet, const IfcElementAssembly &obj, const CopyOp &copyop)
{
    IfcElementAssembly *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElementAssembly(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElementAssembly_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElementAssembly *ExpressDataSet::cloneIfcElementAssembly(const IfcElementAssembly &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcElementAssembly(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcElementAssembly(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcElementAssembly  > &ExpressDataSet::getAllIfcElementAssembly ()
{
    return m_refIfcElementAssemblyList;
}



IfcElementComponent *ExpressDataSet::getIfcElementComponent(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcElementComponent * > (current->second.get());
    }
    else
    {
        IfcElementComponent *ret = static_cast< IfcElementComponent * > (allocateIfcElementComponent(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcElementComponent(IfcElementComponent *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcElementComponent_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElementComponent(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcElementComponent *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElementComponent(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElementComponent_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElementComponent > ExpressDataSet::createIfcElementComponent(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcElementComponent(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcElementComponent * > (allocateIfcElementComponent(this, Step::Id_UNSET));
    }
}

IfcElementComponent *ExpressDataSet::cloneIfcElementComponent(ExpressDataSet *expressDataSet, const IfcElementComponent &obj, const CopyOp &copyop)
{
    IfcElementComponent *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElementComponent(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElementComponent_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElementComponent *ExpressDataSet::cloneIfcElementComponent(const IfcElementComponent &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcElementComponent(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcElementComponent(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcElementComponent  > &ExpressDataSet::getAllIfcElementComponent ()
{
    return m_refIfcElementComponentList;
}



IfcElementComponentType *ExpressDataSet::getIfcElementComponentType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcElementComponentType * > (current->second.get());
    }
    else
    {
        IfcElementComponentType *ret = static_cast< IfcElementComponentType * > (allocateIfcElementComponentType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcElementComponentType(IfcElementComponentType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcElementComponentType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElementComponentType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcElementComponentType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElementComponentType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElementComponentType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElementComponentType > ExpressDataSet::createIfcElementComponentType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcElementComponentType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcElementComponentType * > (allocateIfcElementComponentType(this, Step::Id_UNSET));
    }
}

IfcElementComponentType *ExpressDataSet::cloneIfcElementComponentType(ExpressDataSet *expressDataSet, const IfcElementComponentType &obj, const CopyOp &copyop)
{
    IfcElementComponentType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElementComponentType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElementComponentType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElementComponentType *ExpressDataSet::cloneIfcElementComponentType(const IfcElementComponentType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcElementComponentType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcElementComponentType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcElementComponentType  > &ExpressDataSet::getAllIfcElementComponentType ()
{
    return m_refIfcElementComponentTypeList;
}



IfcElementQuantity *ExpressDataSet::getIfcElementQuantity(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcElementQuantity * > (current->second.get());
    }
    else
    {
        IfcElementQuantity *ret = static_cast< IfcElementQuantity * > (allocateIfcElementQuantity(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcElementQuantity(IfcElementQuantity *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcElementQuantity_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElementQuantity(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcElementQuantity *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElementQuantity(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElementQuantity_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElementQuantity > ExpressDataSet::createIfcElementQuantity(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcElementQuantity(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcElementQuantity * > (allocateIfcElementQuantity(this, Step::Id_UNSET));
    }
}

IfcElementQuantity *ExpressDataSet::cloneIfcElementQuantity(ExpressDataSet *expressDataSet, const IfcElementQuantity &obj, const CopyOp &copyop)
{
    IfcElementQuantity *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElementQuantity(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElementQuantity_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElementQuantity *ExpressDataSet::cloneIfcElementQuantity(const IfcElementQuantity &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcElementQuantity(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcElementQuantity(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcElementQuantity  > &ExpressDataSet::getAllIfcElementQuantity ()
{
    return m_refIfcElementQuantityList;
}



IfcElementType *ExpressDataSet::getIfcElementType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcElementType * > (current->second.get());
    }
    else
    {
        IfcElementType *ret = static_cast< IfcElementType * > (allocateIfcElementType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcElementType(IfcElementType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcElementType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElementType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcElementType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElementType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElementType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElementType > ExpressDataSet::createIfcElementType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcElementType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcElementType * > (allocateIfcElementType(this, Step::Id_UNSET));
    }
}

IfcElementType *ExpressDataSet::cloneIfcElementType(ExpressDataSet *expressDataSet, const IfcElementType &obj, const CopyOp &copyop)
{
    IfcElementType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElementType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElementType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElementType *ExpressDataSet::cloneIfcElementType(const IfcElementType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcElementType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcElementType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcElementType  > &ExpressDataSet::getAllIfcElementType ()
{
    return m_refIfcElementTypeList;
}



IfcEllipse *ExpressDataSet::getIfcEllipse(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcEllipse * > (current->second.get());
    }
    else
    {
        IfcEllipse *ret = static_cast< IfcEllipse * > (allocateIfcEllipse(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcEllipse(IfcEllipse *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcEllipse_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcEllipse(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcEllipse *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcEllipse(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcEllipse_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcEllipse > ExpressDataSet::createIfcEllipse(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcEllipse(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcEllipse * > (allocateIfcEllipse(this, Step::Id_UNSET));
    }
}

IfcEllipse *ExpressDataSet::cloneIfcEllipse(ExpressDataSet *expressDataSet, const IfcEllipse &obj, const CopyOp &copyop)
{
    IfcEllipse *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcEllipse(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcEllipse_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcEllipse *ExpressDataSet::cloneIfcEllipse(const IfcEllipse &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcEllipse(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcEllipse(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcEllipse  > &ExpressDataSet::getAllIfcEllipse ()
{
    return m_refIfcEllipseList;
}



IfcEllipseProfileDef *ExpressDataSet::getIfcEllipseProfileDef(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcEllipseProfileDef * > (current->second.get());
    }
    else
    {
        IfcEllipseProfileDef *ret = static_cast< IfcEllipseProfileDef * > (allocateIfcEllipseProfileDef(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcEllipseProfileDef(IfcEllipseProfileDef *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcEllipseProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcEllipseProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcEllipseProfileDef *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcEllipseProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcEllipseProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcEllipseProfileDef > ExpressDataSet::createIfcEllipseProfileDef(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcEllipseProfileDef(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcEllipseProfileDef * > (allocateIfcEllipseProfileDef(this, Step::Id_UNSET));
    }
}

IfcEllipseProfileDef *ExpressDataSet::cloneIfcEllipseProfileDef(ExpressDataSet *expressDataSet, const IfcEllipseProfileDef &obj, const CopyOp &copyop)
{
    IfcEllipseProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcEllipseProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcEllipseProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcEllipseProfileDef *ExpressDataSet::cloneIfcEllipseProfileDef(const IfcEllipseProfileDef &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcEllipseProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcEllipseProfileDef(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcEllipseProfileDef  > &ExpressDataSet::getAllIfcEllipseProfileDef ()
{
    return m_refIfcEllipseProfileDefList;
}



IfcEnergyConversionDevice *ExpressDataSet::getIfcEnergyConversionDevice(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcEnergyConversionDevice * > (current->second.get());
    }
    else
    {
        IfcEnergyConversionDevice *ret = static_cast< IfcEnergyConversionDevice * > (allocateIfcEnergyConversionDevice(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcEnergyConversionDevice(IfcEnergyConversionDevice *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcEnergyConversionDevice_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcEnergyConversionDevice(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcEnergyConversionDevice *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcEnergyConversionDevice(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcEnergyConversionDevice_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcEnergyConversionDevice > ExpressDataSet::createIfcEnergyConversionDevice(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcEnergyConversionDevice(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcEnergyConversionDevice * > (allocateIfcEnergyConversionDevice(this, Step::Id_UNSET));
    }
}

IfcEnergyConversionDevice *ExpressDataSet::cloneIfcEnergyConversionDevice(ExpressDataSet *expressDataSet, const IfcEnergyConversionDevice &obj, const CopyOp &copyop)
{
    IfcEnergyConversionDevice *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcEnergyConversionDevice(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcEnergyConversionDevice_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcEnergyConversionDevice *ExpressDataSet::cloneIfcEnergyConversionDevice(const IfcEnergyConversionDevice &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcEnergyConversionDevice(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcEnergyConversionDevice(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcEnergyConversionDevice  > &ExpressDataSet::getAllIfcEnergyConversionDevice ()
{
    return m_refIfcEnergyConversionDeviceList;
}



IfcEnergyConversionDeviceType *ExpressDataSet::getIfcEnergyConversionDeviceType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcEnergyConversionDeviceType * > (current->second.get());
    }
    else
    {
        IfcEnergyConversionDeviceType *ret = static_cast< IfcEnergyConversionDeviceType * > (allocateIfcEnergyConversionDeviceType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcEnergyConversionDeviceType(IfcEnergyConversionDeviceType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcEnergyConversionDeviceType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcEnergyConversionDeviceType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcEnergyConversionDeviceType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcEnergyConversionDeviceType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcEnergyConversionDeviceType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcEnergyConversionDeviceType > ExpressDataSet::createIfcEnergyConversionDeviceType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcEnergyConversionDeviceType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcEnergyConversionDeviceType * > (allocateIfcEnergyConversionDeviceType(this, Step::Id_UNSET));
    }
}

IfcEnergyConversionDeviceType *ExpressDataSet::cloneIfcEnergyConversionDeviceType(ExpressDataSet *expressDataSet, const IfcEnergyConversionDeviceType &obj, const CopyOp &copyop)
{
    IfcEnergyConversionDeviceType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcEnergyConversionDeviceType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcEnergyConversionDeviceType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcEnergyConversionDeviceType *ExpressDataSet::cloneIfcEnergyConversionDeviceType(const IfcEnergyConversionDeviceType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcEnergyConversionDeviceType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcEnergyConversionDeviceType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcEnergyConversionDeviceType  > &ExpressDataSet::getAllIfcEnergyConversionDeviceType ()
{
    return m_refIfcEnergyConversionDeviceTypeList;
}



IfcEnergyProperties *ExpressDataSet::getIfcEnergyProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcEnergyProperties * > (current->second.get());
    }
    else
    {
        IfcEnergyProperties *ret = static_cast< IfcEnergyProperties * > (allocateIfcEnergyProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcEnergyProperties(IfcEnergyProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcEnergyProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcEnergyProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcEnergyProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcEnergyProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcEnergyProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcEnergyProperties > ExpressDataSet::createIfcEnergyProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcEnergyProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcEnergyProperties * > (allocateIfcEnergyProperties(this, Step::Id_UNSET));
    }
}

IfcEnergyProperties *ExpressDataSet::cloneIfcEnergyProperties(ExpressDataSet *expressDataSet, const IfcEnergyProperties &obj, const CopyOp &copyop)
{
    IfcEnergyProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcEnergyProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcEnergyProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcEnergyProperties *ExpressDataSet::cloneIfcEnergyProperties(const IfcEnergyProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcEnergyProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcEnergyProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcEnergyProperties  > &ExpressDataSet::getAllIfcEnergyProperties ()
{
    return m_refIfcEnergyPropertiesList;
}



IfcEnvironmentalImpactValue *ExpressDataSet::getIfcEnvironmentalImpactValue(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcEnvironmentalImpactValue * > (current->second.get());
    }
    else
    {
        IfcEnvironmentalImpactValue *ret = static_cast< IfcEnvironmentalImpactValue * > (allocateIfcEnvironmentalImpactValue(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcEnvironmentalImpactValue(IfcEnvironmentalImpactValue *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcEnvironmentalImpactValue_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcEnvironmentalImpactValue(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcEnvironmentalImpactValue *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcEnvironmentalImpactValue(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcEnvironmentalImpactValue_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcEnvironmentalImpactValue > ExpressDataSet::createIfcEnvironmentalImpactValue(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcEnvironmentalImpactValue(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcEnvironmentalImpactValue * > (allocateIfcEnvironmentalImpactValue(this, Step::Id_UNSET));
    }
}

IfcEnvironmentalImpactValue *ExpressDataSet::cloneIfcEnvironmentalImpactValue(ExpressDataSet *expressDataSet, const IfcEnvironmentalImpactValue &obj, const CopyOp &copyop)
{
    IfcEnvironmentalImpactValue *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcEnvironmentalImpactValue(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcEnvironmentalImpactValue_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcEnvironmentalImpactValue *ExpressDataSet::cloneIfcEnvironmentalImpactValue(const IfcEnvironmentalImpactValue &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcEnvironmentalImpactValue(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcEnvironmentalImpactValue(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcEnvironmentalImpactValue  > &ExpressDataSet::getAllIfcEnvironmentalImpactValue ()
{
    return m_refIfcEnvironmentalImpactValueList;
}



IfcEquipmentElement *ExpressDataSet::getIfcEquipmentElement(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcEquipmentElement * > (current->second.get());
    }
    else
    {
        IfcEquipmentElement *ret = static_cast< IfcEquipmentElement * > (allocateIfcEquipmentElement(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcEquipmentElement(IfcEquipmentElement *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcEquipmentElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcEquipmentElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcEquipmentElement *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcEquipmentElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcEquipmentElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcEquipmentElement > ExpressDataSet::createIfcEquipmentElement(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcEquipmentElement(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcEquipmentElement * > (allocateIfcEquipmentElement(this, Step::Id_UNSET));
    }
}

IfcEquipmentElement *ExpressDataSet::cloneIfcEquipmentElement(ExpressDataSet *expressDataSet, const IfcEquipmentElement &obj, const CopyOp &copyop)
{
    IfcEquipmentElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcEquipmentElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcEquipmentElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcEquipmentElement *ExpressDataSet::cloneIfcEquipmentElement(const IfcEquipmentElement &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcEquipmentElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcEquipmentElement(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcEquipmentElement  > &ExpressDataSet::getAllIfcEquipmentElement ()
{
    return m_refIfcEquipmentElementList;
}



IfcEquipmentStandard *ExpressDataSet::getIfcEquipmentStandard(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcEquipmentStandard * > (current->second.get());
    }
    else
    {
        IfcEquipmentStandard *ret = static_cast< IfcEquipmentStandard * > (allocateIfcEquipmentStandard(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcEquipmentStandard(IfcEquipmentStandard *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcEquipmentStandard_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcEquipmentStandard(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcEquipmentStandard *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcEquipmentStandard(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcEquipmentStandard_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcEquipmentStandard > ExpressDataSet::createIfcEquipmentStandard(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcEquipmentStandard(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcEquipmentStandard * > (allocateIfcEquipmentStandard(this, Step::Id_UNSET));
    }
}

IfcEquipmentStandard *ExpressDataSet::cloneIfcEquipmentStandard(ExpressDataSet *expressDataSet, const IfcEquipmentStandard &obj, const CopyOp &copyop)
{
    IfcEquipmentStandard *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcEquipmentStandard(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcEquipmentStandard_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcEquipmentStandard *ExpressDataSet::cloneIfcEquipmentStandard(const IfcEquipmentStandard &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcEquipmentStandard(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcEquipmentStandard(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcEquipmentStandard  > &ExpressDataSet::getAllIfcEquipmentStandard ()
{
    return m_refIfcEquipmentStandardList;
}



IfcEvaporativeCoolerType *ExpressDataSet::getIfcEvaporativeCoolerType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcEvaporativeCoolerType * > (current->second.get());
    }
    else
    {
        IfcEvaporativeCoolerType *ret = static_cast< IfcEvaporativeCoolerType * > (allocateIfcEvaporativeCoolerType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcEvaporativeCoolerType(IfcEvaporativeCoolerType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcEvaporativeCoolerType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcEvaporativeCoolerType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcEvaporativeCoolerType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcEvaporativeCoolerType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcEvaporativeCoolerType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcEvaporativeCoolerType > ExpressDataSet::createIfcEvaporativeCoolerType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcEvaporativeCoolerType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcEvaporativeCoolerType * > (allocateIfcEvaporativeCoolerType(this, Step::Id_UNSET));
    }
}

IfcEvaporativeCoolerType *ExpressDataSet::cloneIfcEvaporativeCoolerType(ExpressDataSet *expressDataSet, const IfcEvaporativeCoolerType &obj, const CopyOp &copyop)
{
    IfcEvaporativeCoolerType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcEvaporativeCoolerType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcEvaporativeCoolerType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcEvaporativeCoolerType *ExpressDataSet::cloneIfcEvaporativeCoolerType(const IfcEvaporativeCoolerType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcEvaporativeCoolerType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcEvaporativeCoolerType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcEvaporativeCoolerType  > &ExpressDataSet::getAllIfcEvaporativeCoolerType ()
{
    return m_refIfcEvaporativeCoolerTypeList;
}



IfcEvaporatorType *ExpressDataSet::getIfcEvaporatorType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcEvaporatorType * > (current->second.get());
    }
    else
    {
        IfcEvaporatorType *ret = static_cast< IfcEvaporatorType * > (allocateIfcEvaporatorType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcEvaporatorType(IfcEvaporatorType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcEvaporatorType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcEvaporatorType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcEvaporatorType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcEvaporatorType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcEvaporatorType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcEvaporatorType > ExpressDataSet::createIfcEvaporatorType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcEvaporatorType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcEvaporatorType * > (allocateIfcEvaporatorType(this, Step::Id_UNSET));
    }
}

IfcEvaporatorType *ExpressDataSet::cloneIfcEvaporatorType(ExpressDataSet *expressDataSet, const IfcEvaporatorType &obj, const CopyOp &copyop)
{
    IfcEvaporatorType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcEvaporatorType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcEvaporatorType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcEvaporatorType *ExpressDataSet::cloneIfcEvaporatorType(const IfcEvaporatorType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcEvaporatorType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcEvaporatorType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcEvaporatorType  > &ExpressDataSet::getAllIfcEvaporatorType ()
{
    return m_refIfcEvaporatorTypeList;
}



IfcExtendedMaterialProperties *ExpressDataSet::getIfcExtendedMaterialProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcExtendedMaterialProperties * > (current->second.get());
    }
    else
    {
        IfcExtendedMaterialProperties *ret = static_cast< IfcExtendedMaterialProperties * > (allocateIfcExtendedMaterialProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcExtendedMaterialProperties(IfcExtendedMaterialProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcExtendedMaterialProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcExtendedMaterialProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcExtendedMaterialProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcExtendedMaterialProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcExtendedMaterialProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcExtendedMaterialProperties > ExpressDataSet::createIfcExtendedMaterialProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcExtendedMaterialProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcExtendedMaterialProperties * > (allocateIfcExtendedMaterialProperties(this, Step::Id_UNSET));
    }
}

IfcExtendedMaterialProperties *ExpressDataSet::cloneIfcExtendedMaterialProperties(ExpressDataSet *expressDataSet, const IfcExtendedMaterialProperties &obj, const CopyOp &copyop)
{
    IfcExtendedMaterialProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcExtendedMaterialProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcExtendedMaterialProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcExtendedMaterialProperties *ExpressDataSet::cloneIfcExtendedMaterialProperties(const IfcExtendedMaterialProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcExtendedMaterialProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcExtendedMaterialProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcExtendedMaterialProperties  > &ExpressDataSet::getAllIfcExtendedMaterialProperties ()
{
    return m_refIfcExtendedMaterialPropertiesList;
}



IfcExternallyDefinedHatchStyle *ExpressDataSet::getIfcExternallyDefinedHatchStyle(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcExternallyDefinedHatchStyle * > (current->second.get());
    }
    else
    {
        IfcExternallyDefinedHatchStyle *ret = static_cast< IfcExternallyDefinedHatchStyle * > (allocateIfcExternallyDefinedHatchStyle(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcExternallyDefinedHatchStyle(IfcExternallyDefinedHatchStyle *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcExternallyDefinedHatchStyle_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcExternallyDefinedHatchStyle(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcExternallyDefinedHatchStyle *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcExternallyDefinedHatchStyle(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcExternallyDefinedHatchStyle_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcExternallyDefinedHatchStyle > ExpressDataSet::createIfcExternallyDefinedHatchStyle(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcExternallyDefinedHatchStyle(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcExternallyDefinedHatchStyle * > (allocateIfcExternallyDefinedHatchStyle(this, Step::Id_UNSET));
    }
}

IfcExternallyDefinedHatchStyle *ExpressDataSet::cloneIfcExternallyDefinedHatchStyle(ExpressDataSet *expressDataSet, const IfcExternallyDefinedHatchStyle &obj, const CopyOp &copyop)
{
    IfcExternallyDefinedHatchStyle *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcExternallyDefinedHatchStyle(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcExternallyDefinedHatchStyle_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcExternallyDefinedHatchStyle *ExpressDataSet::cloneIfcExternallyDefinedHatchStyle(const IfcExternallyDefinedHatchStyle &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcExternallyDefinedHatchStyle(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcExternallyDefinedHatchStyle(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcExternallyDefinedHatchStyle  > &ExpressDataSet::getAllIfcExternallyDefinedHatchStyle ()
{
    return m_refIfcExternallyDefinedHatchStyleList;
}



IfcExternallyDefinedSurfaceStyle *ExpressDataSet::getIfcExternallyDefinedSurfaceStyle(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcExternallyDefinedSurfaceStyle * > (current->second.get());
    }
    else
    {
        IfcExternallyDefinedSurfaceStyle *ret = static_cast< IfcExternallyDefinedSurfaceStyle * > (allocateIfcExternallyDefinedSurfaceStyle(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcExternallyDefinedSurfaceStyle(IfcExternallyDefinedSurfaceStyle *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcExternallyDefinedSurfaceStyle_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcExternallyDefinedSurfaceStyle(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcExternallyDefinedSurfaceStyle *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcExternallyDefinedSurfaceStyle(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcExternallyDefinedSurfaceStyle_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcExternallyDefinedSurfaceStyle > ExpressDataSet::createIfcExternallyDefinedSurfaceStyle(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcExternallyDefinedSurfaceStyle(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcExternallyDefinedSurfaceStyle * > (allocateIfcExternallyDefinedSurfaceStyle(this, Step::Id_UNSET));
    }
}

IfcExternallyDefinedSurfaceStyle *ExpressDataSet::cloneIfcExternallyDefinedSurfaceStyle(ExpressDataSet *expressDataSet, const IfcExternallyDefinedSurfaceStyle &obj, const CopyOp &copyop)
{
    IfcExternallyDefinedSurfaceStyle *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcExternallyDefinedSurfaceStyle(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcExternallyDefinedSurfaceStyle_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcExternallyDefinedSurfaceStyle *ExpressDataSet::cloneIfcExternallyDefinedSurfaceStyle(const IfcExternallyDefinedSurfaceStyle &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcExternallyDefinedSurfaceStyle(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcExternallyDefinedSurfaceStyle(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcExternallyDefinedSurfaceStyle  > &ExpressDataSet::getAllIfcExternallyDefinedSurfaceStyle ()
{
    return m_refIfcExternallyDefinedSurfaceStyleList;
}



IfcExternallyDefinedSymbol *ExpressDataSet::getIfcExternallyDefinedSymbol(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcExternallyDefinedSymbol * > (current->second.get());
    }
    else
    {
        IfcExternallyDefinedSymbol *ret = static_cast< IfcExternallyDefinedSymbol * > (allocateIfcExternallyDefinedSymbol(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcExternallyDefinedSymbol(IfcExternallyDefinedSymbol *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcExternallyDefinedSymbol_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcExternallyDefinedSymbol(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcExternallyDefinedSymbol *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcExternallyDefinedSymbol(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcExternallyDefinedSymbol_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcExternallyDefinedSymbol > ExpressDataSet::createIfcExternallyDefinedSymbol(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcExternallyDefinedSymbol(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcExternallyDefinedSymbol * > (allocateIfcExternallyDefinedSymbol(this, Step::Id_UNSET));
    }
}

IfcExternallyDefinedSymbol *ExpressDataSet::cloneIfcExternallyDefinedSymbol(ExpressDataSet *expressDataSet, const IfcExternallyDefinedSymbol &obj, const CopyOp &copyop)
{
    IfcExternallyDefinedSymbol *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcExternallyDefinedSymbol(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcExternallyDefinedSymbol_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcExternallyDefinedSymbol *ExpressDataSet::cloneIfcExternallyDefinedSymbol(const IfcExternallyDefinedSymbol &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcExternallyDefinedSymbol(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcExternallyDefinedSymbol(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcExternallyDefinedSymbol  > &ExpressDataSet::getAllIfcExternallyDefinedSymbol ()
{
    return m_refIfcExternallyDefinedSymbolList;
}



IfcExternallyDefinedTextFont *ExpressDataSet::getIfcExternallyDefinedTextFont(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcExternallyDefinedTextFont * > (current->second.get());
    }
    else
    {
        IfcExternallyDefinedTextFont *ret = static_cast< IfcExternallyDefinedTextFont * > (allocateIfcExternallyDefinedTextFont(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcExternallyDefinedTextFont(IfcExternallyDefinedTextFont *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcExternallyDefinedTextFont_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcExternallyDefinedTextFont(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcExternallyDefinedTextFont *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcExternallyDefinedTextFont(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcExternallyDefinedTextFont_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcExternallyDefinedTextFont > ExpressDataSet::createIfcExternallyDefinedTextFont(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcExternallyDefinedTextFont(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcExternallyDefinedTextFont * > (allocateIfcExternallyDefinedTextFont(this, Step::Id_UNSET));
    }
}

IfcExternallyDefinedTextFont *ExpressDataSet::cloneIfcExternallyDefinedTextFont(ExpressDataSet *expressDataSet, const IfcExternallyDefinedTextFont &obj, const CopyOp &copyop)
{
    IfcExternallyDefinedTextFont *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcExternallyDefinedTextFont(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcExternallyDefinedTextFont_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcExternallyDefinedTextFont *ExpressDataSet::cloneIfcExternallyDefinedTextFont(const IfcExternallyDefinedTextFont &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcExternallyDefinedTextFont(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcExternallyDefinedTextFont(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcExternallyDefinedTextFont  > &ExpressDataSet::getAllIfcExternallyDefinedTextFont ()
{
    return m_refIfcExternallyDefinedTextFontList;
}



IfcExternalReference *ExpressDataSet::getIfcExternalReference(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcExternalReference * > (current->second.get());
    }
    else
    {
        IfcExternalReference *ret = static_cast< IfcExternalReference * > (allocateIfcExternalReference(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcExternalReference(IfcExternalReference *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcExternalReference_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcExternalReference(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcExternalReference *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcExternalReference(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcExternalReference_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcExternalReference > ExpressDataSet::createIfcExternalReference(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcExternalReference(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcExternalReference * > (allocateIfcExternalReference(this, Step::Id_UNSET));
    }
}

IfcExternalReference *ExpressDataSet::cloneIfcExternalReference(ExpressDataSet *expressDataSet, const IfcExternalReference &obj, const CopyOp &copyop)
{
    IfcExternalReference *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcExternalReference(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcExternalReference_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcExternalReference *ExpressDataSet::cloneIfcExternalReference(const IfcExternalReference &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcExternalReference(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcExternalReference(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcExternalReference  > &ExpressDataSet::getAllIfcExternalReference ()
{
    return m_refIfcExternalReferenceList;
}



IfcExtrudedAreaSolid *ExpressDataSet::getIfcExtrudedAreaSolid(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcExtrudedAreaSolid * > (current->second.get());
    }
    else
    {
        IfcExtrudedAreaSolid *ret = static_cast< IfcExtrudedAreaSolid * > (allocateIfcExtrudedAreaSolid(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcExtrudedAreaSolid(IfcExtrudedAreaSolid *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcExtrudedAreaSolid_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcExtrudedAreaSolid(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcExtrudedAreaSolid *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcExtrudedAreaSolid(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcExtrudedAreaSolid_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcExtrudedAreaSolid > ExpressDataSet::createIfcExtrudedAreaSolid(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcExtrudedAreaSolid(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcExtrudedAreaSolid * > (allocateIfcExtrudedAreaSolid(this, Step::Id_UNSET));
    }
}

IfcExtrudedAreaSolid *ExpressDataSet::cloneIfcExtrudedAreaSolid(ExpressDataSet *expressDataSet, const IfcExtrudedAreaSolid &obj, const CopyOp &copyop)
{
    IfcExtrudedAreaSolid *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcExtrudedAreaSolid(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcExtrudedAreaSolid_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcExtrudedAreaSolid *ExpressDataSet::cloneIfcExtrudedAreaSolid(const IfcExtrudedAreaSolid &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcExtrudedAreaSolid(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcExtrudedAreaSolid(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcExtrudedAreaSolid  > &ExpressDataSet::getAllIfcExtrudedAreaSolid ()
{
    return m_refIfcExtrudedAreaSolidList;
}



IfcFace *ExpressDataSet::getIfcFace(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFace * > (current->second.get());
    }
    else
    {
        IfcFace *ret = static_cast< IfcFace * > (allocateIfcFace(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFace(IfcFace *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFace_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFace(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFace *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFace(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFace_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFace > ExpressDataSet::createIfcFace(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFace(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFace * > (allocateIfcFace(this, Step::Id_UNSET));
    }
}

IfcFace *ExpressDataSet::cloneIfcFace(ExpressDataSet *expressDataSet, const IfcFace &obj, const CopyOp &copyop)
{
    IfcFace *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFace(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFace_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFace *ExpressDataSet::cloneIfcFace(const IfcFace &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFace(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFace(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFace  > &ExpressDataSet::getAllIfcFace ()
{
    return m_refIfcFaceList;
}



IfcFaceBasedSurfaceModel *ExpressDataSet::getIfcFaceBasedSurfaceModel(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFaceBasedSurfaceModel * > (current->second.get());
    }
    else
    {
        IfcFaceBasedSurfaceModel *ret = static_cast< IfcFaceBasedSurfaceModel * > (allocateIfcFaceBasedSurfaceModel(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFaceBasedSurfaceModel(IfcFaceBasedSurfaceModel *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFaceBasedSurfaceModel_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFaceBasedSurfaceModel(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFaceBasedSurfaceModel *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFaceBasedSurfaceModel(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFaceBasedSurfaceModel_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFaceBasedSurfaceModel > ExpressDataSet::createIfcFaceBasedSurfaceModel(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFaceBasedSurfaceModel(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFaceBasedSurfaceModel * > (allocateIfcFaceBasedSurfaceModel(this, Step::Id_UNSET));
    }
}

IfcFaceBasedSurfaceModel *ExpressDataSet::cloneIfcFaceBasedSurfaceModel(ExpressDataSet *expressDataSet, const IfcFaceBasedSurfaceModel &obj, const CopyOp &copyop)
{
    IfcFaceBasedSurfaceModel *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFaceBasedSurfaceModel(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFaceBasedSurfaceModel_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFaceBasedSurfaceModel *ExpressDataSet::cloneIfcFaceBasedSurfaceModel(const IfcFaceBasedSurfaceModel &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFaceBasedSurfaceModel(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFaceBasedSurfaceModel(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFaceBasedSurfaceModel  > &ExpressDataSet::getAllIfcFaceBasedSurfaceModel ()
{
    return m_refIfcFaceBasedSurfaceModelList;
}



IfcFaceBound *ExpressDataSet::getIfcFaceBound(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFaceBound * > (current->second.get());
    }
    else
    {
        IfcFaceBound *ret = static_cast< IfcFaceBound * > (allocateIfcFaceBound(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFaceBound(IfcFaceBound *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFaceBound_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFaceBound(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFaceBound *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFaceBound(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFaceBound_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFaceBound > ExpressDataSet::createIfcFaceBound(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFaceBound(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFaceBound * > (allocateIfcFaceBound(this, Step::Id_UNSET));
    }
}

IfcFaceBound *ExpressDataSet::cloneIfcFaceBound(ExpressDataSet *expressDataSet, const IfcFaceBound &obj, const CopyOp &copyop)
{
    IfcFaceBound *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFaceBound(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFaceBound_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFaceBound *ExpressDataSet::cloneIfcFaceBound(const IfcFaceBound &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFaceBound(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFaceBound(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFaceBound  > &ExpressDataSet::getAllIfcFaceBound ()
{
    return m_refIfcFaceBoundList;
}



IfcFaceOuterBound *ExpressDataSet::getIfcFaceOuterBound(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFaceOuterBound * > (current->second.get());
    }
    else
    {
        IfcFaceOuterBound *ret = static_cast< IfcFaceOuterBound * > (allocateIfcFaceOuterBound(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFaceOuterBound(IfcFaceOuterBound *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFaceOuterBound_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFaceOuterBound(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFaceOuterBound *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFaceOuterBound(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFaceOuterBound_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFaceOuterBound > ExpressDataSet::createIfcFaceOuterBound(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFaceOuterBound(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFaceOuterBound * > (allocateIfcFaceOuterBound(this, Step::Id_UNSET));
    }
}

IfcFaceOuterBound *ExpressDataSet::cloneIfcFaceOuterBound(ExpressDataSet *expressDataSet, const IfcFaceOuterBound &obj, const CopyOp &copyop)
{
    IfcFaceOuterBound *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFaceOuterBound(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFaceOuterBound_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFaceOuterBound *ExpressDataSet::cloneIfcFaceOuterBound(const IfcFaceOuterBound &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFaceOuterBound(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFaceOuterBound(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFaceOuterBound  > &ExpressDataSet::getAllIfcFaceOuterBound ()
{
    return m_refIfcFaceOuterBoundList;
}



IfcFaceSurface *ExpressDataSet::getIfcFaceSurface(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFaceSurface * > (current->second.get());
    }
    else
    {
        IfcFaceSurface *ret = static_cast< IfcFaceSurface * > (allocateIfcFaceSurface(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFaceSurface(IfcFaceSurface *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFaceSurface_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFaceSurface(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFaceSurface *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFaceSurface(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFaceSurface_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFaceSurface > ExpressDataSet::createIfcFaceSurface(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFaceSurface(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFaceSurface * > (allocateIfcFaceSurface(this, Step::Id_UNSET));
    }
}

IfcFaceSurface *ExpressDataSet::cloneIfcFaceSurface(ExpressDataSet *expressDataSet, const IfcFaceSurface &obj, const CopyOp &copyop)
{
    IfcFaceSurface *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFaceSurface(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFaceSurface_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFaceSurface *ExpressDataSet::cloneIfcFaceSurface(const IfcFaceSurface &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFaceSurface(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFaceSurface(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFaceSurface  > &ExpressDataSet::getAllIfcFaceSurface ()
{
    return m_refIfcFaceSurfaceList;
}



IfcFacetedBrep *ExpressDataSet::getIfcFacetedBrep(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFacetedBrep * > (current->second.get());
    }
    else
    {
        IfcFacetedBrep *ret = static_cast< IfcFacetedBrep * > (allocateIfcFacetedBrep(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFacetedBrep(IfcFacetedBrep *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFacetedBrep_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFacetedBrep(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFacetedBrep *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFacetedBrep(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFacetedBrep_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFacetedBrep > ExpressDataSet::createIfcFacetedBrep(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFacetedBrep(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFacetedBrep * > (allocateIfcFacetedBrep(this, Step::Id_UNSET));
    }
}

IfcFacetedBrep *ExpressDataSet::cloneIfcFacetedBrep(ExpressDataSet *expressDataSet, const IfcFacetedBrep &obj, const CopyOp &copyop)
{
    IfcFacetedBrep *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFacetedBrep(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFacetedBrep_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFacetedBrep *ExpressDataSet::cloneIfcFacetedBrep(const IfcFacetedBrep &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFacetedBrep(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFacetedBrep(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFacetedBrep  > &ExpressDataSet::getAllIfcFacetedBrep ()
{
    return m_refIfcFacetedBrepList;
}



IfcFacetedBrepWithVoids *ExpressDataSet::getIfcFacetedBrepWithVoids(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFacetedBrepWithVoids * > (current->second.get());
    }
    else
    {
        IfcFacetedBrepWithVoids *ret = static_cast< IfcFacetedBrepWithVoids * > (allocateIfcFacetedBrepWithVoids(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFacetedBrepWithVoids(IfcFacetedBrepWithVoids *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFacetedBrepWithVoids_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFacetedBrepWithVoids(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFacetedBrepWithVoids *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFacetedBrepWithVoids(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFacetedBrepWithVoids_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFacetedBrepWithVoids > ExpressDataSet::createIfcFacetedBrepWithVoids(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFacetedBrepWithVoids(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFacetedBrepWithVoids * > (allocateIfcFacetedBrepWithVoids(this, Step::Id_UNSET));
    }
}

IfcFacetedBrepWithVoids *ExpressDataSet::cloneIfcFacetedBrepWithVoids(ExpressDataSet *expressDataSet, const IfcFacetedBrepWithVoids &obj, const CopyOp &copyop)
{
    IfcFacetedBrepWithVoids *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFacetedBrepWithVoids(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFacetedBrepWithVoids_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFacetedBrepWithVoids *ExpressDataSet::cloneIfcFacetedBrepWithVoids(const IfcFacetedBrepWithVoids &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFacetedBrepWithVoids(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFacetedBrepWithVoids(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFacetedBrepWithVoids  > &ExpressDataSet::getAllIfcFacetedBrepWithVoids ()
{
    return m_refIfcFacetedBrepWithVoidsList;
}



IfcFailureConnectionCondition *ExpressDataSet::getIfcFailureConnectionCondition(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFailureConnectionCondition * > (current->second.get());
    }
    else
    {
        IfcFailureConnectionCondition *ret = static_cast< IfcFailureConnectionCondition * > (allocateIfcFailureConnectionCondition(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFailureConnectionCondition(IfcFailureConnectionCondition *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFailureConnectionCondition_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFailureConnectionCondition(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFailureConnectionCondition *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFailureConnectionCondition(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFailureConnectionCondition_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFailureConnectionCondition > ExpressDataSet::createIfcFailureConnectionCondition(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFailureConnectionCondition(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFailureConnectionCondition * > (allocateIfcFailureConnectionCondition(this, Step::Id_UNSET));
    }
}

IfcFailureConnectionCondition *ExpressDataSet::cloneIfcFailureConnectionCondition(ExpressDataSet *expressDataSet, const IfcFailureConnectionCondition &obj, const CopyOp &copyop)
{
    IfcFailureConnectionCondition *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFailureConnectionCondition(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFailureConnectionCondition_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFailureConnectionCondition *ExpressDataSet::cloneIfcFailureConnectionCondition(const IfcFailureConnectionCondition &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFailureConnectionCondition(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFailureConnectionCondition(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFailureConnectionCondition  > &ExpressDataSet::getAllIfcFailureConnectionCondition ()
{
    return m_refIfcFailureConnectionConditionList;
}



IfcFanType *ExpressDataSet::getIfcFanType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFanType * > (current->second.get());
    }
    else
    {
        IfcFanType *ret = static_cast< IfcFanType * > (allocateIfcFanType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFanType(IfcFanType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFanType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFanType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFanType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFanType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFanType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFanType > ExpressDataSet::createIfcFanType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFanType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFanType * > (allocateIfcFanType(this, Step::Id_UNSET));
    }
}

IfcFanType *ExpressDataSet::cloneIfcFanType(ExpressDataSet *expressDataSet, const IfcFanType &obj, const CopyOp &copyop)
{
    IfcFanType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFanType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFanType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFanType *ExpressDataSet::cloneIfcFanType(const IfcFanType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFanType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFanType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFanType  > &ExpressDataSet::getAllIfcFanType ()
{
    return m_refIfcFanTypeList;
}



IfcFastener *ExpressDataSet::getIfcFastener(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFastener * > (current->second.get());
    }
    else
    {
        IfcFastener *ret = static_cast< IfcFastener * > (allocateIfcFastener(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFastener(IfcFastener *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFastener_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFastener(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFastener *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFastener(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFastener_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFastener > ExpressDataSet::createIfcFastener(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFastener(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFastener * > (allocateIfcFastener(this, Step::Id_UNSET));
    }
}

IfcFastener *ExpressDataSet::cloneIfcFastener(ExpressDataSet *expressDataSet, const IfcFastener &obj, const CopyOp &copyop)
{
    IfcFastener *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFastener(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFastener_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFastener *ExpressDataSet::cloneIfcFastener(const IfcFastener &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFastener(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFastener(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFastener  > &ExpressDataSet::getAllIfcFastener ()
{
    return m_refIfcFastenerList;
}



IfcFastenerType *ExpressDataSet::getIfcFastenerType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFastenerType * > (current->second.get());
    }
    else
    {
        IfcFastenerType *ret = static_cast< IfcFastenerType * > (allocateIfcFastenerType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFastenerType(IfcFastenerType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFastenerType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFastenerType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFastenerType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFastenerType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFastenerType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFastenerType > ExpressDataSet::createIfcFastenerType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFastenerType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFastenerType * > (allocateIfcFastenerType(this, Step::Id_UNSET));
    }
}

IfcFastenerType *ExpressDataSet::cloneIfcFastenerType(ExpressDataSet *expressDataSet, const IfcFastenerType &obj, const CopyOp &copyop)
{
    IfcFastenerType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFastenerType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFastenerType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFastenerType *ExpressDataSet::cloneIfcFastenerType(const IfcFastenerType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFastenerType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFastenerType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFastenerType  > &ExpressDataSet::getAllIfcFastenerType ()
{
    return m_refIfcFastenerTypeList;
}



IfcFeatureElement *ExpressDataSet::getIfcFeatureElement(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFeatureElement * > (current->second.get());
    }
    else
    {
        IfcFeatureElement *ret = static_cast< IfcFeatureElement * > (allocateIfcFeatureElement(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFeatureElement(IfcFeatureElement *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFeatureElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFeatureElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFeatureElement *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFeatureElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFeatureElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFeatureElement > ExpressDataSet::createIfcFeatureElement(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFeatureElement(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFeatureElement * > (allocateIfcFeatureElement(this, Step::Id_UNSET));
    }
}

IfcFeatureElement *ExpressDataSet::cloneIfcFeatureElement(ExpressDataSet *expressDataSet, const IfcFeatureElement &obj, const CopyOp &copyop)
{
    IfcFeatureElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFeatureElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFeatureElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFeatureElement *ExpressDataSet::cloneIfcFeatureElement(const IfcFeatureElement &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFeatureElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFeatureElement(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFeatureElement  > &ExpressDataSet::getAllIfcFeatureElement ()
{
    return m_refIfcFeatureElementList;
}



IfcFeatureElementAddition *ExpressDataSet::getIfcFeatureElementAddition(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFeatureElementAddition * > (current->second.get());
    }
    else
    {
        IfcFeatureElementAddition *ret = static_cast< IfcFeatureElementAddition * > (allocateIfcFeatureElementAddition(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFeatureElementAddition(IfcFeatureElementAddition *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFeatureElementAddition_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFeatureElementAddition(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFeatureElementAddition *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFeatureElementAddition(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFeatureElementAddition_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFeatureElementAddition > ExpressDataSet::createIfcFeatureElementAddition(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFeatureElementAddition(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFeatureElementAddition * > (allocateIfcFeatureElementAddition(this, Step::Id_UNSET));
    }
}

IfcFeatureElementAddition *ExpressDataSet::cloneIfcFeatureElementAddition(ExpressDataSet *expressDataSet, const IfcFeatureElementAddition &obj, const CopyOp &copyop)
{
    IfcFeatureElementAddition *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFeatureElementAddition(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFeatureElementAddition_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFeatureElementAddition *ExpressDataSet::cloneIfcFeatureElementAddition(const IfcFeatureElementAddition &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFeatureElementAddition(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFeatureElementAddition(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFeatureElementAddition  > &ExpressDataSet::getAllIfcFeatureElementAddition ()
{
    return m_refIfcFeatureElementAdditionList;
}



IfcFeatureElementSubtraction *ExpressDataSet::getIfcFeatureElementSubtraction(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFeatureElementSubtraction * > (current->second.get());
    }
    else
    {
        IfcFeatureElementSubtraction *ret = static_cast< IfcFeatureElementSubtraction * > (allocateIfcFeatureElementSubtraction(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFeatureElementSubtraction(IfcFeatureElementSubtraction *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFeatureElementSubtraction_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFeatureElementSubtraction(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFeatureElementSubtraction *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFeatureElementSubtraction(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFeatureElementSubtraction_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFeatureElementSubtraction > ExpressDataSet::createIfcFeatureElementSubtraction(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFeatureElementSubtraction(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFeatureElementSubtraction * > (allocateIfcFeatureElementSubtraction(this, Step::Id_UNSET));
    }
}

IfcFeatureElementSubtraction *ExpressDataSet::cloneIfcFeatureElementSubtraction(ExpressDataSet *expressDataSet, const IfcFeatureElementSubtraction &obj, const CopyOp &copyop)
{
    IfcFeatureElementSubtraction *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFeatureElementSubtraction(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFeatureElementSubtraction_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFeatureElementSubtraction *ExpressDataSet::cloneIfcFeatureElementSubtraction(const IfcFeatureElementSubtraction &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFeatureElementSubtraction(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFeatureElementSubtraction(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFeatureElementSubtraction  > &ExpressDataSet::getAllIfcFeatureElementSubtraction ()
{
    return m_refIfcFeatureElementSubtractionList;
}



IfcFillAreaStyle *ExpressDataSet::getIfcFillAreaStyle(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFillAreaStyle * > (current->second.get());
    }
    else
    {
        IfcFillAreaStyle *ret = static_cast< IfcFillAreaStyle * > (allocateIfcFillAreaStyle(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFillAreaStyle(IfcFillAreaStyle *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFillAreaStyle_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFillAreaStyle(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFillAreaStyle *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFillAreaStyle(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFillAreaStyle_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFillAreaStyle > ExpressDataSet::createIfcFillAreaStyle(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFillAreaStyle(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFillAreaStyle * > (allocateIfcFillAreaStyle(this, Step::Id_UNSET));
    }
}

IfcFillAreaStyle *ExpressDataSet::cloneIfcFillAreaStyle(ExpressDataSet *expressDataSet, const IfcFillAreaStyle &obj, const CopyOp &copyop)
{
    IfcFillAreaStyle *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFillAreaStyle(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFillAreaStyle_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFillAreaStyle *ExpressDataSet::cloneIfcFillAreaStyle(const IfcFillAreaStyle &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFillAreaStyle(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFillAreaStyle(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFillAreaStyle  > &ExpressDataSet::getAllIfcFillAreaStyle ()
{
    return m_refIfcFillAreaStyleList;
}



IfcFillAreaStyleHatching *ExpressDataSet::getIfcFillAreaStyleHatching(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFillAreaStyleHatching * > (current->second.get());
    }
    else
    {
        IfcFillAreaStyleHatching *ret = static_cast< IfcFillAreaStyleHatching * > (allocateIfcFillAreaStyleHatching(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFillAreaStyleHatching(IfcFillAreaStyleHatching *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFillAreaStyleHatching_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFillAreaStyleHatching(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFillAreaStyleHatching *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFillAreaStyleHatching(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFillAreaStyleHatching_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFillAreaStyleHatching > ExpressDataSet::createIfcFillAreaStyleHatching(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFillAreaStyleHatching(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFillAreaStyleHatching * > (allocateIfcFillAreaStyleHatching(this, Step::Id_UNSET));
    }
}

IfcFillAreaStyleHatching *ExpressDataSet::cloneIfcFillAreaStyleHatching(ExpressDataSet *expressDataSet, const IfcFillAreaStyleHatching &obj, const CopyOp &copyop)
{
    IfcFillAreaStyleHatching *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFillAreaStyleHatching(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFillAreaStyleHatching_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFillAreaStyleHatching *ExpressDataSet::cloneIfcFillAreaStyleHatching(const IfcFillAreaStyleHatching &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFillAreaStyleHatching(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFillAreaStyleHatching(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFillAreaStyleHatching  > &ExpressDataSet::getAllIfcFillAreaStyleHatching ()
{
    return m_refIfcFillAreaStyleHatchingList;
}



IfcFillAreaStyleTiles *ExpressDataSet::getIfcFillAreaStyleTiles(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFillAreaStyleTiles * > (current->second.get());
    }
    else
    {
        IfcFillAreaStyleTiles *ret = static_cast< IfcFillAreaStyleTiles * > (allocateIfcFillAreaStyleTiles(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFillAreaStyleTiles(IfcFillAreaStyleTiles *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFillAreaStyleTiles_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFillAreaStyleTiles(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFillAreaStyleTiles *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFillAreaStyleTiles(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFillAreaStyleTiles_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFillAreaStyleTiles > ExpressDataSet::createIfcFillAreaStyleTiles(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFillAreaStyleTiles(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFillAreaStyleTiles * > (allocateIfcFillAreaStyleTiles(this, Step::Id_UNSET));
    }
}

IfcFillAreaStyleTiles *ExpressDataSet::cloneIfcFillAreaStyleTiles(ExpressDataSet *expressDataSet, const IfcFillAreaStyleTiles &obj, const CopyOp &copyop)
{
    IfcFillAreaStyleTiles *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFillAreaStyleTiles(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFillAreaStyleTiles_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFillAreaStyleTiles *ExpressDataSet::cloneIfcFillAreaStyleTiles(const IfcFillAreaStyleTiles &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFillAreaStyleTiles(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFillAreaStyleTiles(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFillAreaStyleTiles  > &ExpressDataSet::getAllIfcFillAreaStyleTiles ()
{
    return m_refIfcFillAreaStyleTilesList;
}



IfcFillAreaStyleTileSymbolWithStyle *ExpressDataSet::getIfcFillAreaStyleTileSymbolWithStyle(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFillAreaStyleTileSymbolWithStyle * > (current->second.get());
    }
    else
    {
        IfcFillAreaStyleTileSymbolWithStyle *ret = static_cast< IfcFillAreaStyleTileSymbolWithStyle * > (allocateIfcFillAreaStyleTileSymbolWithStyle(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFillAreaStyleTileSymbolWithStyle(IfcFillAreaStyleTileSymbolWithStyle *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFillAreaStyleTileSymbolWithStyle_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFillAreaStyleTileSymbolWithStyle(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFillAreaStyleTileSymbolWithStyle *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFillAreaStyleTileSymbolWithStyle(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFillAreaStyleTileSymbolWithStyle_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFillAreaStyleTileSymbolWithStyle > ExpressDataSet::createIfcFillAreaStyleTileSymbolWithStyle(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFillAreaStyleTileSymbolWithStyle(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFillAreaStyleTileSymbolWithStyle * > (allocateIfcFillAreaStyleTileSymbolWithStyle(this, Step::Id_UNSET));
    }
}

IfcFillAreaStyleTileSymbolWithStyle *ExpressDataSet::cloneIfcFillAreaStyleTileSymbolWithStyle(ExpressDataSet *expressDataSet, const IfcFillAreaStyleTileSymbolWithStyle &obj, const CopyOp &copyop)
{
    IfcFillAreaStyleTileSymbolWithStyle *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFillAreaStyleTileSymbolWithStyle(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFillAreaStyleTileSymbolWithStyle_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFillAreaStyleTileSymbolWithStyle *ExpressDataSet::cloneIfcFillAreaStyleTileSymbolWithStyle(const IfcFillAreaStyleTileSymbolWithStyle &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFillAreaStyleTileSymbolWithStyle(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFillAreaStyleTileSymbolWithStyle(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFillAreaStyleTileSymbolWithStyle  > &ExpressDataSet::getAllIfcFillAreaStyleTileSymbolWithStyle ()
{
    return m_refIfcFillAreaStyleTileSymbolWithStyleList;
}



IfcFilterType *ExpressDataSet::getIfcFilterType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFilterType * > (current->second.get());
    }
    else
    {
        IfcFilterType *ret = static_cast< IfcFilterType * > (allocateIfcFilterType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFilterType(IfcFilterType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFilterType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFilterType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFilterType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFilterType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFilterType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFilterType > ExpressDataSet::createIfcFilterType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFilterType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFilterType * > (allocateIfcFilterType(this, Step::Id_UNSET));
    }
}

IfcFilterType *ExpressDataSet::cloneIfcFilterType(ExpressDataSet *expressDataSet, const IfcFilterType &obj, const CopyOp &copyop)
{
    IfcFilterType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFilterType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFilterType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFilterType *ExpressDataSet::cloneIfcFilterType(const IfcFilterType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFilterType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFilterType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFilterType  > &ExpressDataSet::getAllIfcFilterType ()
{
    return m_refIfcFilterTypeList;
}



IfcFireSuppressionTerminalType *ExpressDataSet::getIfcFireSuppressionTerminalType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFireSuppressionTerminalType * > (current->second.get());
    }
    else
    {
        IfcFireSuppressionTerminalType *ret = static_cast< IfcFireSuppressionTerminalType * > (allocateIfcFireSuppressionTerminalType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFireSuppressionTerminalType(IfcFireSuppressionTerminalType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFireSuppressionTerminalType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFireSuppressionTerminalType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFireSuppressionTerminalType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFireSuppressionTerminalType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFireSuppressionTerminalType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFireSuppressionTerminalType > ExpressDataSet::createIfcFireSuppressionTerminalType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFireSuppressionTerminalType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFireSuppressionTerminalType * > (allocateIfcFireSuppressionTerminalType(this, Step::Id_UNSET));
    }
}

IfcFireSuppressionTerminalType *ExpressDataSet::cloneIfcFireSuppressionTerminalType(ExpressDataSet *expressDataSet, const IfcFireSuppressionTerminalType &obj, const CopyOp &copyop)
{
    IfcFireSuppressionTerminalType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFireSuppressionTerminalType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFireSuppressionTerminalType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFireSuppressionTerminalType *ExpressDataSet::cloneIfcFireSuppressionTerminalType(const IfcFireSuppressionTerminalType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFireSuppressionTerminalType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFireSuppressionTerminalType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFireSuppressionTerminalType  > &ExpressDataSet::getAllIfcFireSuppressionTerminalType ()
{
    return m_refIfcFireSuppressionTerminalTypeList;
}



IfcFlowController *ExpressDataSet::getIfcFlowController(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFlowController * > (current->second.get());
    }
    else
    {
        IfcFlowController *ret = static_cast< IfcFlowController * > (allocateIfcFlowController(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFlowController(IfcFlowController *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFlowController_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFlowController(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFlowController *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFlowController(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFlowController_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFlowController > ExpressDataSet::createIfcFlowController(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFlowController(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFlowController * > (allocateIfcFlowController(this, Step::Id_UNSET));
    }
}

IfcFlowController *ExpressDataSet::cloneIfcFlowController(ExpressDataSet *expressDataSet, const IfcFlowController &obj, const CopyOp &copyop)
{
    IfcFlowController *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFlowController(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFlowController_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFlowController *ExpressDataSet::cloneIfcFlowController(const IfcFlowController &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFlowController(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFlowController(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFlowController  > &ExpressDataSet::getAllIfcFlowController ()
{
    return m_refIfcFlowControllerList;
}



IfcFlowControllerType *ExpressDataSet::getIfcFlowControllerType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFlowControllerType * > (current->second.get());
    }
    else
    {
        IfcFlowControllerType *ret = static_cast< IfcFlowControllerType * > (allocateIfcFlowControllerType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFlowControllerType(IfcFlowControllerType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFlowControllerType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFlowControllerType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFlowControllerType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFlowControllerType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFlowControllerType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFlowControllerType > ExpressDataSet::createIfcFlowControllerType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFlowControllerType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFlowControllerType * > (allocateIfcFlowControllerType(this, Step::Id_UNSET));
    }
}

IfcFlowControllerType *ExpressDataSet::cloneIfcFlowControllerType(ExpressDataSet *expressDataSet, const IfcFlowControllerType &obj, const CopyOp &copyop)
{
    IfcFlowControllerType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFlowControllerType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFlowControllerType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFlowControllerType *ExpressDataSet::cloneIfcFlowControllerType(const IfcFlowControllerType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFlowControllerType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFlowControllerType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFlowControllerType  > &ExpressDataSet::getAllIfcFlowControllerType ()
{
    return m_refIfcFlowControllerTypeList;
}



IfcFlowFitting *ExpressDataSet::getIfcFlowFitting(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFlowFitting * > (current->second.get());
    }
    else
    {
        IfcFlowFitting *ret = static_cast< IfcFlowFitting * > (allocateIfcFlowFitting(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFlowFitting(IfcFlowFitting *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFlowFitting_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFlowFitting(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFlowFitting *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFlowFitting(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFlowFitting_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFlowFitting > ExpressDataSet::createIfcFlowFitting(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFlowFitting(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFlowFitting * > (allocateIfcFlowFitting(this, Step::Id_UNSET));
    }
}

IfcFlowFitting *ExpressDataSet::cloneIfcFlowFitting(ExpressDataSet *expressDataSet, const IfcFlowFitting &obj, const CopyOp &copyop)
{
    IfcFlowFitting *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFlowFitting(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFlowFitting_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFlowFitting *ExpressDataSet::cloneIfcFlowFitting(const IfcFlowFitting &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFlowFitting(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFlowFitting(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFlowFitting  > &ExpressDataSet::getAllIfcFlowFitting ()
{
    return m_refIfcFlowFittingList;
}



IfcFlowFittingType *ExpressDataSet::getIfcFlowFittingType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFlowFittingType * > (current->second.get());
    }
    else
    {
        IfcFlowFittingType *ret = static_cast< IfcFlowFittingType * > (allocateIfcFlowFittingType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFlowFittingType(IfcFlowFittingType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFlowFittingType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFlowFittingType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFlowFittingType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFlowFittingType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFlowFittingType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFlowFittingType > ExpressDataSet::createIfcFlowFittingType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFlowFittingType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFlowFittingType * > (allocateIfcFlowFittingType(this, Step::Id_UNSET));
    }
}

IfcFlowFittingType *ExpressDataSet::cloneIfcFlowFittingType(ExpressDataSet *expressDataSet, const IfcFlowFittingType &obj, const CopyOp &copyop)
{
    IfcFlowFittingType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFlowFittingType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFlowFittingType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFlowFittingType *ExpressDataSet::cloneIfcFlowFittingType(const IfcFlowFittingType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFlowFittingType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFlowFittingType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFlowFittingType  > &ExpressDataSet::getAllIfcFlowFittingType ()
{
    return m_refIfcFlowFittingTypeList;
}



IfcFlowInstrumentType *ExpressDataSet::getIfcFlowInstrumentType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFlowInstrumentType * > (current->second.get());
    }
    else
    {
        IfcFlowInstrumentType *ret = static_cast< IfcFlowInstrumentType * > (allocateIfcFlowInstrumentType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFlowInstrumentType(IfcFlowInstrumentType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFlowInstrumentType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFlowInstrumentType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFlowInstrumentType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFlowInstrumentType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFlowInstrumentType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFlowInstrumentType > ExpressDataSet::createIfcFlowInstrumentType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFlowInstrumentType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFlowInstrumentType * > (allocateIfcFlowInstrumentType(this, Step::Id_UNSET));
    }
}

IfcFlowInstrumentType *ExpressDataSet::cloneIfcFlowInstrumentType(ExpressDataSet *expressDataSet, const IfcFlowInstrumentType &obj, const CopyOp &copyop)
{
    IfcFlowInstrumentType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFlowInstrumentType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFlowInstrumentType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFlowInstrumentType *ExpressDataSet::cloneIfcFlowInstrumentType(const IfcFlowInstrumentType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFlowInstrumentType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFlowInstrumentType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFlowInstrumentType  > &ExpressDataSet::getAllIfcFlowInstrumentType ()
{
    return m_refIfcFlowInstrumentTypeList;
}



IfcFlowMeterType *ExpressDataSet::getIfcFlowMeterType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFlowMeterType * > (current->second.get());
    }
    else
    {
        IfcFlowMeterType *ret = static_cast< IfcFlowMeterType * > (allocateIfcFlowMeterType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFlowMeterType(IfcFlowMeterType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFlowMeterType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFlowMeterType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFlowMeterType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFlowMeterType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFlowMeterType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFlowMeterType > ExpressDataSet::createIfcFlowMeterType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFlowMeterType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFlowMeterType * > (allocateIfcFlowMeterType(this, Step::Id_UNSET));
    }
}

IfcFlowMeterType *ExpressDataSet::cloneIfcFlowMeterType(ExpressDataSet *expressDataSet, const IfcFlowMeterType &obj, const CopyOp &copyop)
{
    IfcFlowMeterType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFlowMeterType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFlowMeterType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFlowMeterType *ExpressDataSet::cloneIfcFlowMeterType(const IfcFlowMeterType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFlowMeterType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFlowMeterType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFlowMeterType  > &ExpressDataSet::getAllIfcFlowMeterType ()
{
    return m_refIfcFlowMeterTypeList;
}



IfcFlowMovingDevice *ExpressDataSet::getIfcFlowMovingDevice(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFlowMovingDevice * > (current->second.get());
    }
    else
    {
        IfcFlowMovingDevice *ret = static_cast< IfcFlowMovingDevice * > (allocateIfcFlowMovingDevice(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFlowMovingDevice(IfcFlowMovingDevice *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFlowMovingDevice_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFlowMovingDevice(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFlowMovingDevice *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFlowMovingDevice(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFlowMovingDevice_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFlowMovingDevice > ExpressDataSet::createIfcFlowMovingDevice(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFlowMovingDevice(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFlowMovingDevice * > (allocateIfcFlowMovingDevice(this, Step::Id_UNSET));
    }
}

IfcFlowMovingDevice *ExpressDataSet::cloneIfcFlowMovingDevice(ExpressDataSet *expressDataSet, const IfcFlowMovingDevice &obj, const CopyOp &copyop)
{
    IfcFlowMovingDevice *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFlowMovingDevice(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFlowMovingDevice_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFlowMovingDevice *ExpressDataSet::cloneIfcFlowMovingDevice(const IfcFlowMovingDevice &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFlowMovingDevice(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFlowMovingDevice(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFlowMovingDevice  > &ExpressDataSet::getAllIfcFlowMovingDevice ()
{
    return m_refIfcFlowMovingDeviceList;
}



IfcFlowMovingDeviceType *ExpressDataSet::getIfcFlowMovingDeviceType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFlowMovingDeviceType * > (current->second.get());
    }
    else
    {
        IfcFlowMovingDeviceType *ret = static_cast< IfcFlowMovingDeviceType * > (allocateIfcFlowMovingDeviceType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFlowMovingDeviceType(IfcFlowMovingDeviceType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFlowMovingDeviceType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFlowMovingDeviceType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFlowMovingDeviceType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFlowMovingDeviceType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFlowMovingDeviceType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFlowMovingDeviceType > ExpressDataSet::createIfcFlowMovingDeviceType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFlowMovingDeviceType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFlowMovingDeviceType * > (allocateIfcFlowMovingDeviceType(this, Step::Id_UNSET));
    }
}

IfcFlowMovingDeviceType *ExpressDataSet::cloneIfcFlowMovingDeviceType(ExpressDataSet *expressDataSet, const IfcFlowMovingDeviceType &obj, const CopyOp &copyop)
{
    IfcFlowMovingDeviceType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFlowMovingDeviceType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFlowMovingDeviceType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFlowMovingDeviceType *ExpressDataSet::cloneIfcFlowMovingDeviceType(const IfcFlowMovingDeviceType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFlowMovingDeviceType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFlowMovingDeviceType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFlowMovingDeviceType  > &ExpressDataSet::getAllIfcFlowMovingDeviceType ()
{
    return m_refIfcFlowMovingDeviceTypeList;
}



IfcFlowSegment *ExpressDataSet::getIfcFlowSegment(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFlowSegment * > (current->second.get());
    }
    else
    {
        IfcFlowSegment *ret = static_cast< IfcFlowSegment * > (allocateIfcFlowSegment(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFlowSegment(IfcFlowSegment *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFlowSegment_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFlowSegment(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFlowSegment *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFlowSegment(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFlowSegment_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFlowSegment > ExpressDataSet::createIfcFlowSegment(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFlowSegment(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFlowSegment * > (allocateIfcFlowSegment(this, Step::Id_UNSET));
    }
}

IfcFlowSegment *ExpressDataSet::cloneIfcFlowSegment(ExpressDataSet *expressDataSet, const IfcFlowSegment &obj, const CopyOp &copyop)
{
    IfcFlowSegment *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFlowSegment(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFlowSegment_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFlowSegment *ExpressDataSet::cloneIfcFlowSegment(const IfcFlowSegment &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFlowSegment(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFlowSegment(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFlowSegment  > &ExpressDataSet::getAllIfcFlowSegment ()
{
    return m_refIfcFlowSegmentList;
}



IfcFlowSegmentType *ExpressDataSet::getIfcFlowSegmentType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFlowSegmentType * > (current->second.get());
    }
    else
    {
        IfcFlowSegmentType *ret = static_cast< IfcFlowSegmentType * > (allocateIfcFlowSegmentType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFlowSegmentType(IfcFlowSegmentType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFlowSegmentType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFlowSegmentType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFlowSegmentType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFlowSegmentType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFlowSegmentType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFlowSegmentType > ExpressDataSet::createIfcFlowSegmentType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFlowSegmentType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFlowSegmentType * > (allocateIfcFlowSegmentType(this, Step::Id_UNSET));
    }
}

IfcFlowSegmentType *ExpressDataSet::cloneIfcFlowSegmentType(ExpressDataSet *expressDataSet, const IfcFlowSegmentType &obj, const CopyOp &copyop)
{
    IfcFlowSegmentType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFlowSegmentType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFlowSegmentType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFlowSegmentType *ExpressDataSet::cloneIfcFlowSegmentType(const IfcFlowSegmentType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFlowSegmentType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFlowSegmentType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFlowSegmentType  > &ExpressDataSet::getAllIfcFlowSegmentType ()
{
    return m_refIfcFlowSegmentTypeList;
}



IfcFlowStorageDevice *ExpressDataSet::getIfcFlowStorageDevice(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFlowStorageDevice * > (current->second.get());
    }
    else
    {
        IfcFlowStorageDevice *ret = static_cast< IfcFlowStorageDevice * > (allocateIfcFlowStorageDevice(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFlowStorageDevice(IfcFlowStorageDevice *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFlowStorageDevice_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFlowStorageDevice(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFlowStorageDevice *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFlowStorageDevice(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFlowStorageDevice_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFlowStorageDevice > ExpressDataSet::createIfcFlowStorageDevice(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFlowStorageDevice(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFlowStorageDevice * > (allocateIfcFlowStorageDevice(this, Step::Id_UNSET));
    }
}

IfcFlowStorageDevice *ExpressDataSet::cloneIfcFlowStorageDevice(ExpressDataSet *expressDataSet, const IfcFlowStorageDevice &obj, const CopyOp &copyop)
{
    IfcFlowStorageDevice *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFlowStorageDevice(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFlowStorageDevice_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFlowStorageDevice *ExpressDataSet::cloneIfcFlowStorageDevice(const IfcFlowStorageDevice &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFlowStorageDevice(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFlowStorageDevice(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFlowStorageDevice  > &ExpressDataSet::getAllIfcFlowStorageDevice ()
{
    return m_refIfcFlowStorageDeviceList;
}



IfcFlowStorageDeviceType *ExpressDataSet::getIfcFlowStorageDeviceType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFlowStorageDeviceType * > (current->second.get());
    }
    else
    {
        IfcFlowStorageDeviceType *ret = static_cast< IfcFlowStorageDeviceType * > (allocateIfcFlowStorageDeviceType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFlowStorageDeviceType(IfcFlowStorageDeviceType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFlowStorageDeviceType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFlowStorageDeviceType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFlowStorageDeviceType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFlowStorageDeviceType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFlowStorageDeviceType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFlowStorageDeviceType > ExpressDataSet::createIfcFlowStorageDeviceType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFlowStorageDeviceType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFlowStorageDeviceType * > (allocateIfcFlowStorageDeviceType(this, Step::Id_UNSET));
    }
}

IfcFlowStorageDeviceType *ExpressDataSet::cloneIfcFlowStorageDeviceType(ExpressDataSet *expressDataSet, const IfcFlowStorageDeviceType &obj, const CopyOp &copyop)
{
    IfcFlowStorageDeviceType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFlowStorageDeviceType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFlowStorageDeviceType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFlowStorageDeviceType *ExpressDataSet::cloneIfcFlowStorageDeviceType(const IfcFlowStorageDeviceType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFlowStorageDeviceType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFlowStorageDeviceType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFlowStorageDeviceType  > &ExpressDataSet::getAllIfcFlowStorageDeviceType ()
{
    return m_refIfcFlowStorageDeviceTypeList;
}



IfcFlowTerminal *ExpressDataSet::getIfcFlowTerminal(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFlowTerminal * > (current->second.get());
    }
    else
    {
        IfcFlowTerminal *ret = static_cast< IfcFlowTerminal * > (allocateIfcFlowTerminal(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFlowTerminal(IfcFlowTerminal *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFlowTerminal_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFlowTerminal(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFlowTerminal *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFlowTerminal(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFlowTerminal_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFlowTerminal > ExpressDataSet::createIfcFlowTerminal(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFlowTerminal(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFlowTerminal * > (allocateIfcFlowTerminal(this, Step::Id_UNSET));
    }
}

IfcFlowTerminal *ExpressDataSet::cloneIfcFlowTerminal(ExpressDataSet *expressDataSet, const IfcFlowTerminal &obj, const CopyOp &copyop)
{
    IfcFlowTerminal *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFlowTerminal(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFlowTerminal_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFlowTerminal *ExpressDataSet::cloneIfcFlowTerminal(const IfcFlowTerminal &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFlowTerminal(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFlowTerminal(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFlowTerminal  > &ExpressDataSet::getAllIfcFlowTerminal ()
{
    return m_refIfcFlowTerminalList;
}



IfcFlowTerminalType *ExpressDataSet::getIfcFlowTerminalType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFlowTerminalType * > (current->second.get());
    }
    else
    {
        IfcFlowTerminalType *ret = static_cast< IfcFlowTerminalType * > (allocateIfcFlowTerminalType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFlowTerminalType(IfcFlowTerminalType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFlowTerminalType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFlowTerminalType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFlowTerminalType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFlowTerminalType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFlowTerminalType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFlowTerminalType > ExpressDataSet::createIfcFlowTerminalType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFlowTerminalType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFlowTerminalType * > (allocateIfcFlowTerminalType(this, Step::Id_UNSET));
    }
}

IfcFlowTerminalType *ExpressDataSet::cloneIfcFlowTerminalType(ExpressDataSet *expressDataSet, const IfcFlowTerminalType &obj, const CopyOp &copyop)
{
    IfcFlowTerminalType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFlowTerminalType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFlowTerminalType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFlowTerminalType *ExpressDataSet::cloneIfcFlowTerminalType(const IfcFlowTerminalType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFlowTerminalType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFlowTerminalType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFlowTerminalType  > &ExpressDataSet::getAllIfcFlowTerminalType ()
{
    return m_refIfcFlowTerminalTypeList;
}



IfcFlowTreatmentDevice *ExpressDataSet::getIfcFlowTreatmentDevice(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFlowTreatmentDevice * > (current->second.get());
    }
    else
    {
        IfcFlowTreatmentDevice *ret = static_cast< IfcFlowTreatmentDevice * > (allocateIfcFlowTreatmentDevice(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFlowTreatmentDevice(IfcFlowTreatmentDevice *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFlowTreatmentDevice_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFlowTreatmentDevice(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFlowTreatmentDevice *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFlowTreatmentDevice(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFlowTreatmentDevice_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFlowTreatmentDevice > ExpressDataSet::createIfcFlowTreatmentDevice(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFlowTreatmentDevice(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFlowTreatmentDevice * > (allocateIfcFlowTreatmentDevice(this, Step::Id_UNSET));
    }
}

IfcFlowTreatmentDevice *ExpressDataSet::cloneIfcFlowTreatmentDevice(ExpressDataSet *expressDataSet, const IfcFlowTreatmentDevice &obj, const CopyOp &copyop)
{
    IfcFlowTreatmentDevice *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFlowTreatmentDevice(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFlowTreatmentDevice_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFlowTreatmentDevice *ExpressDataSet::cloneIfcFlowTreatmentDevice(const IfcFlowTreatmentDevice &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFlowTreatmentDevice(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFlowTreatmentDevice(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFlowTreatmentDevice  > &ExpressDataSet::getAllIfcFlowTreatmentDevice ()
{
    return m_refIfcFlowTreatmentDeviceList;
}



IfcFlowTreatmentDeviceType *ExpressDataSet::getIfcFlowTreatmentDeviceType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFlowTreatmentDeviceType * > (current->second.get());
    }
    else
    {
        IfcFlowTreatmentDeviceType *ret = static_cast< IfcFlowTreatmentDeviceType * > (allocateIfcFlowTreatmentDeviceType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFlowTreatmentDeviceType(IfcFlowTreatmentDeviceType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFlowTreatmentDeviceType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFlowTreatmentDeviceType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFlowTreatmentDeviceType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFlowTreatmentDeviceType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFlowTreatmentDeviceType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFlowTreatmentDeviceType > ExpressDataSet::createIfcFlowTreatmentDeviceType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFlowTreatmentDeviceType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFlowTreatmentDeviceType * > (allocateIfcFlowTreatmentDeviceType(this, Step::Id_UNSET));
    }
}

IfcFlowTreatmentDeviceType *ExpressDataSet::cloneIfcFlowTreatmentDeviceType(ExpressDataSet *expressDataSet, const IfcFlowTreatmentDeviceType &obj, const CopyOp &copyop)
{
    IfcFlowTreatmentDeviceType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFlowTreatmentDeviceType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFlowTreatmentDeviceType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFlowTreatmentDeviceType *ExpressDataSet::cloneIfcFlowTreatmentDeviceType(const IfcFlowTreatmentDeviceType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFlowTreatmentDeviceType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFlowTreatmentDeviceType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFlowTreatmentDeviceType  > &ExpressDataSet::getAllIfcFlowTreatmentDeviceType ()
{
    return m_refIfcFlowTreatmentDeviceTypeList;
}



IfcFluidFlowProperties *ExpressDataSet::getIfcFluidFlowProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFluidFlowProperties * > (current->second.get());
    }
    else
    {
        IfcFluidFlowProperties *ret = static_cast< IfcFluidFlowProperties * > (allocateIfcFluidFlowProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFluidFlowProperties(IfcFluidFlowProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFluidFlowProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFluidFlowProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFluidFlowProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFluidFlowProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFluidFlowProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFluidFlowProperties > ExpressDataSet::createIfcFluidFlowProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFluidFlowProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFluidFlowProperties * > (allocateIfcFluidFlowProperties(this, Step::Id_UNSET));
    }
}

IfcFluidFlowProperties *ExpressDataSet::cloneIfcFluidFlowProperties(ExpressDataSet *expressDataSet, const IfcFluidFlowProperties &obj, const CopyOp &copyop)
{
    IfcFluidFlowProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFluidFlowProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFluidFlowProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFluidFlowProperties *ExpressDataSet::cloneIfcFluidFlowProperties(const IfcFluidFlowProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFluidFlowProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFluidFlowProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFluidFlowProperties  > &ExpressDataSet::getAllIfcFluidFlowProperties ()
{
    return m_refIfcFluidFlowPropertiesList;
}



IfcFooting *ExpressDataSet::getIfcFooting(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFooting * > (current->second.get());
    }
    else
    {
        IfcFooting *ret = static_cast< IfcFooting * > (allocateIfcFooting(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFooting(IfcFooting *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFooting_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFooting(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFooting *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFooting(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFooting_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFooting > ExpressDataSet::createIfcFooting(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFooting(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFooting * > (allocateIfcFooting(this, Step::Id_UNSET));
    }
}

IfcFooting *ExpressDataSet::cloneIfcFooting(ExpressDataSet *expressDataSet, const IfcFooting &obj, const CopyOp &copyop)
{
    IfcFooting *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFooting(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFooting_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFooting *ExpressDataSet::cloneIfcFooting(const IfcFooting &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFooting(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFooting(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFooting  > &ExpressDataSet::getAllIfcFooting ()
{
    return m_refIfcFootingList;
}



IfcFuelProperties *ExpressDataSet::getIfcFuelProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFuelProperties * > (current->second.get());
    }
    else
    {
        IfcFuelProperties *ret = static_cast< IfcFuelProperties * > (allocateIfcFuelProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFuelProperties(IfcFuelProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFuelProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFuelProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFuelProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFuelProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFuelProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFuelProperties > ExpressDataSet::createIfcFuelProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFuelProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFuelProperties * > (allocateIfcFuelProperties(this, Step::Id_UNSET));
    }
}

IfcFuelProperties *ExpressDataSet::cloneIfcFuelProperties(ExpressDataSet *expressDataSet, const IfcFuelProperties &obj, const CopyOp &copyop)
{
    IfcFuelProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFuelProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFuelProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFuelProperties *ExpressDataSet::cloneIfcFuelProperties(const IfcFuelProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFuelProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFuelProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFuelProperties  > &ExpressDataSet::getAllIfcFuelProperties ()
{
    return m_refIfcFuelPropertiesList;
}



IfcFurnishingElement *ExpressDataSet::getIfcFurnishingElement(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFurnishingElement * > (current->second.get());
    }
    else
    {
        IfcFurnishingElement *ret = static_cast< IfcFurnishingElement * > (allocateIfcFurnishingElement(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFurnishingElement(IfcFurnishingElement *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFurnishingElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFurnishingElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFurnishingElement *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFurnishingElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFurnishingElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFurnishingElement > ExpressDataSet::createIfcFurnishingElement(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFurnishingElement(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFurnishingElement * > (allocateIfcFurnishingElement(this, Step::Id_UNSET));
    }
}

IfcFurnishingElement *ExpressDataSet::cloneIfcFurnishingElement(ExpressDataSet *expressDataSet, const IfcFurnishingElement &obj, const CopyOp &copyop)
{
    IfcFurnishingElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFurnishingElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFurnishingElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFurnishingElement *ExpressDataSet::cloneIfcFurnishingElement(const IfcFurnishingElement &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFurnishingElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFurnishingElement(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFurnishingElement  > &ExpressDataSet::getAllIfcFurnishingElement ()
{
    return m_refIfcFurnishingElementList;
}



IfcFurnishingElementType *ExpressDataSet::getIfcFurnishingElementType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFurnishingElementType * > (current->second.get());
    }
    else
    {
        IfcFurnishingElementType *ret = static_cast< IfcFurnishingElementType * > (allocateIfcFurnishingElementType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFurnishingElementType(IfcFurnishingElementType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFurnishingElementType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFurnishingElementType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFurnishingElementType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFurnishingElementType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFurnishingElementType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFurnishingElementType > ExpressDataSet::createIfcFurnishingElementType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFurnishingElementType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFurnishingElementType * > (allocateIfcFurnishingElementType(this, Step::Id_UNSET));
    }
}

IfcFurnishingElementType *ExpressDataSet::cloneIfcFurnishingElementType(ExpressDataSet *expressDataSet, const IfcFurnishingElementType &obj, const CopyOp &copyop)
{
    IfcFurnishingElementType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFurnishingElementType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFurnishingElementType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFurnishingElementType *ExpressDataSet::cloneIfcFurnishingElementType(const IfcFurnishingElementType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFurnishingElementType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFurnishingElementType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFurnishingElementType  > &ExpressDataSet::getAllIfcFurnishingElementType ()
{
    return m_refIfcFurnishingElementTypeList;
}



IfcFurnitureStandard *ExpressDataSet::getIfcFurnitureStandard(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFurnitureStandard * > (current->second.get());
    }
    else
    {
        IfcFurnitureStandard *ret = static_cast< IfcFurnitureStandard * > (allocateIfcFurnitureStandard(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFurnitureStandard(IfcFurnitureStandard *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFurnitureStandard_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFurnitureStandard(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFurnitureStandard *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFurnitureStandard(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFurnitureStandard_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFurnitureStandard > ExpressDataSet::createIfcFurnitureStandard(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFurnitureStandard(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFurnitureStandard * > (allocateIfcFurnitureStandard(this, Step::Id_UNSET));
    }
}

IfcFurnitureStandard *ExpressDataSet::cloneIfcFurnitureStandard(ExpressDataSet *expressDataSet, const IfcFurnitureStandard &obj, const CopyOp &copyop)
{
    IfcFurnitureStandard *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFurnitureStandard(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFurnitureStandard_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFurnitureStandard *ExpressDataSet::cloneIfcFurnitureStandard(const IfcFurnitureStandard &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFurnitureStandard(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFurnitureStandard(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFurnitureStandard  > &ExpressDataSet::getAllIfcFurnitureStandard ()
{
    return m_refIfcFurnitureStandardList;
}



IfcFurnitureType *ExpressDataSet::getIfcFurnitureType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcFurnitureType * > (current->second.get());
    }
    else
    {
        IfcFurnitureType *ret = static_cast< IfcFurnitureType * > (allocateIfcFurnitureType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcFurnitureType(IfcFurnitureType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcFurnitureType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFurnitureType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcFurnitureType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFurnitureType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFurnitureType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFurnitureType > ExpressDataSet::createIfcFurnitureType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcFurnitureType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcFurnitureType * > (allocateIfcFurnitureType(this, Step::Id_UNSET));
    }
}

IfcFurnitureType *ExpressDataSet::cloneIfcFurnitureType(ExpressDataSet *expressDataSet, const IfcFurnitureType &obj, const CopyOp &copyop)
{
    IfcFurnitureType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFurnitureType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFurnitureType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFurnitureType *ExpressDataSet::cloneIfcFurnitureType(const IfcFurnitureType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcFurnitureType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcFurnitureType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcFurnitureType  > &ExpressDataSet::getAllIfcFurnitureType ()
{
    return m_refIfcFurnitureTypeList;
}



IfcGasTerminalType *ExpressDataSet::getIfcGasTerminalType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcGasTerminalType * > (current->second.get());
    }
    else
    {
        IfcGasTerminalType *ret = static_cast< IfcGasTerminalType * > (allocateIfcGasTerminalType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcGasTerminalType(IfcGasTerminalType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcGasTerminalType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcGasTerminalType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcGasTerminalType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcGasTerminalType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcGasTerminalType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcGasTerminalType > ExpressDataSet::createIfcGasTerminalType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcGasTerminalType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcGasTerminalType * > (allocateIfcGasTerminalType(this, Step::Id_UNSET));
    }
}

IfcGasTerminalType *ExpressDataSet::cloneIfcGasTerminalType(ExpressDataSet *expressDataSet, const IfcGasTerminalType &obj, const CopyOp &copyop)
{
    IfcGasTerminalType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcGasTerminalType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcGasTerminalType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcGasTerminalType *ExpressDataSet::cloneIfcGasTerminalType(const IfcGasTerminalType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcGasTerminalType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcGasTerminalType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcGasTerminalType  > &ExpressDataSet::getAllIfcGasTerminalType ()
{
    return m_refIfcGasTerminalTypeList;
}



IfcGeneralMaterialProperties *ExpressDataSet::getIfcGeneralMaterialProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcGeneralMaterialProperties * > (current->second.get());
    }
    else
    {
        IfcGeneralMaterialProperties *ret = static_cast< IfcGeneralMaterialProperties * > (allocateIfcGeneralMaterialProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcGeneralMaterialProperties(IfcGeneralMaterialProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcGeneralMaterialProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcGeneralMaterialProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcGeneralMaterialProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcGeneralMaterialProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcGeneralMaterialProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcGeneralMaterialProperties > ExpressDataSet::createIfcGeneralMaterialProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcGeneralMaterialProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcGeneralMaterialProperties * > (allocateIfcGeneralMaterialProperties(this, Step::Id_UNSET));
    }
}

IfcGeneralMaterialProperties *ExpressDataSet::cloneIfcGeneralMaterialProperties(ExpressDataSet *expressDataSet, const IfcGeneralMaterialProperties &obj, const CopyOp &copyop)
{
    IfcGeneralMaterialProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcGeneralMaterialProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcGeneralMaterialProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcGeneralMaterialProperties *ExpressDataSet::cloneIfcGeneralMaterialProperties(const IfcGeneralMaterialProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcGeneralMaterialProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcGeneralMaterialProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcGeneralMaterialProperties  > &ExpressDataSet::getAllIfcGeneralMaterialProperties ()
{
    return m_refIfcGeneralMaterialPropertiesList;
}



IfcGeneralProfileProperties *ExpressDataSet::getIfcGeneralProfileProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcGeneralProfileProperties * > (current->second.get());
    }
    else
    {
        IfcGeneralProfileProperties *ret = static_cast< IfcGeneralProfileProperties * > (allocateIfcGeneralProfileProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcGeneralProfileProperties(IfcGeneralProfileProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcGeneralProfileProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcGeneralProfileProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcGeneralProfileProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcGeneralProfileProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcGeneralProfileProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcGeneralProfileProperties > ExpressDataSet::createIfcGeneralProfileProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcGeneralProfileProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcGeneralProfileProperties * > (allocateIfcGeneralProfileProperties(this, Step::Id_UNSET));
    }
}

IfcGeneralProfileProperties *ExpressDataSet::cloneIfcGeneralProfileProperties(ExpressDataSet *expressDataSet, const IfcGeneralProfileProperties &obj, const CopyOp &copyop)
{
    IfcGeneralProfileProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcGeneralProfileProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcGeneralProfileProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcGeneralProfileProperties *ExpressDataSet::cloneIfcGeneralProfileProperties(const IfcGeneralProfileProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcGeneralProfileProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcGeneralProfileProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcGeneralProfileProperties  > &ExpressDataSet::getAllIfcGeneralProfileProperties ()
{
    return m_refIfcGeneralProfilePropertiesList;
}



IfcGeometricCurveSet *ExpressDataSet::getIfcGeometricCurveSet(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcGeometricCurveSet * > (current->second.get());
    }
    else
    {
        IfcGeometricCurveSet *ret = static_cast< IfcGeometricCurveSet * > (allocateIfcGeometricCurveSet(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcGeometricCurveSet(IfcGeometricCurveSet *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcGeometricCurveSet_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcGeometricCurveSet(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcGeometricCurveSet *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcGeometricCurveSet(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcGeometricCurveSet_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcGeometricCurveSet > ExpressDataSet::createIfcGeometricCurveSet(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcGeometricCurveSet(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcGeometricCurveSet * > (allocateIfcGeometricCurveSet(this, Step::Id_UNSET));
    }
}

IfcGeometricCurveSet *ExpressDataSet::cloneIfcGeometricCurveSet(ExpressDataSet *expressDataSet, const IfcGeometricCurveSet &obj, const CopyOp &copyop)
{
    IfcGeometricCurveSet *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcGeometricCurveSet(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcGeometricCurveSet_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcGeometricCurveSet *ExpressDataSet::cloneIfcGeometricCurveSet(const IfcGeometricCurveSet &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcGeometricCurveSet(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcGeometricCurveSet(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcGeometricCurveSet  > &ExpressDataSet::getAllIfcGeometricCurveSet ()
{
    return m_refIfcGeometricCurveSetList;
}



IfcGeometricRepresentationContext *ExpressDataSet::getIfcGeometricRepresentationContext(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcGeometricRepresentationContext * > (current->second.get());
    }
    else
    {
        IfcGeometricRepresentationContext *ret = static_cast< IfcGeometricRepresentationContext * > (allocateIfcGeometricRepresentationContext(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcGeometricRepresentationContext(IfcGeometricRepresentationContext *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcGeometricRepresentationContext_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcGeometricRepresentationContext(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcGeometricRepresentationContext *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcGeometricRepresentationContext(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcGeometricRepresentationContext_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcGeometricRepresentationContext > ExpressDataSet::createIfcGeometricRepresentationContext(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcGeometricRepresentationContext(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcGeometricRepresentationContext * > (allocateIfcGeometricRepresentationContext(this, Step::Id_UNSET));
    }
}

IfcGeometricRepresentationContext *ExpressDataSet::cloneIfcGeometricRepresentationContext(ExpressDataSet *expressDataSet, const IfcGeometricRepresentationContext &obj, const CopyOp &copyop)
{
    IfcGeometricRepresentationContext *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcGeometricRepresentationContext(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcGeometricRepresentationContext_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcGeometricRepresentationContext *ExpressDataSet::cloneIfcGeometricRepresentationContext(const IfcGeometricRepresentationContext &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcGeometricRepresentationContext(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcGeometricRepresentationContext(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcGeometricRepresentationContext  > &ExpressDataSet::getAllIfcGeometricRepresentationContext ()
{
    return m_refIfcGeometricRepresentationContextList;
}



IfcGeometricRepresentationItem *ExpressDataSet::getIfcGeometricRepresentationItem(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcGeometricRepresentationItem * > (current->second.get());
    }
    else
    {
        IfcGeometricRepresentationItem *ret = static_cast< IfcGeometricRepresentationItem * > (allocateIfcGeometricRepresentationItem(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcGeometricRepresentationItem(IfcGeometricRepresentationItem *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcGeometricRepresentationItem_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcGeometricRepresentationItem(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcGeometricRepresentationItem *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcGeometricRepresentationItem(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcGeometricRepresentationItem_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcGeometricRepresentationItem > ExpressDataSet::createIfcGeometricRepresentationItem(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcGeometricRepresentationItem(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcGeometricRepresentationItem * > (allocateIfcGeometricRepresentationItem(this, Step::Id_UNSET));
    }
}

IfcGeometricRepresentationItem *ExpressDataSet::cloneIfcGeometricRepresentationItem(ExpressDataSet *expressDataSet, const IfcGeometricRepresentationItem &obj, const CopyOp &copyop)
{
    IfcGeometricRepresentationItem *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcGeometricRepresentationItem(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcGeometricRepresentationItem_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcGeometricRepresentationItem *ExpressDataSet::cloneIfcGeometricRepresentationItem(const IfcGeometricRepresentationItem &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcGeometricRepresentationItem(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcGeometricRepresentationItem(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcGeometricRepresentationItem  > &ExpressDataSet::getAllIfcGeometricRepresentationItem ()
{
    return m_refIfcGeometricRepresentationItemList;
}



IfcGeometricRepresentationSubContext *ExpressDataSet::getIfcGeometricRepresentationSubContext(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcGeometricRepresentationSubContext * > (current->second.get());
    }
    else
    {
        IfcGeometricRepresentationSubContext *ret = static_cast< IfcGeometricRepresentationSubContext * > (allocateIfcGeometricRepresentationSubContext(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcGeometricRepresentationSubContext(IfcGeometricRepresentationSubContext *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcGeometricRepresentationSubContext_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcGeometricRepresentationSubContext(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcGeometricRepresentationSubContext *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcGeometricRepresentationSubContext(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcGeometricRepresentationSubContext_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcGeometricRepresentationSubContext > ExpressDataSet::createIfcGeometricRepresentationSubContext(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcGeometricRepresentationSubContext(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcGeometricRepresentationSubContext * > (allocateIfcGeometricRepresentationSubContext(this, Step::Id_UNSET));
    }
}

IfcGeometricRepresentationSubContext *ExpressDataSet::cloneIfcGeometricRepresentationSubContext(ExpressDataSet *expressDataSet, const IfcGeometricRepresentationSubContext &obj, const CopyOp &copyop)
{
    IfcGeometricRepresentationSubContext *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcGeometricRepresentationSubContext(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcGeometricRepresentationSubContext_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcGeometricRepresentationSubContext *ExpressDataSet::cloneIfcGeometricRepresentationSubContext(const IfcGeometricRepresentationSubContext &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcGeometricRepresentationSubContext(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcGeometricRepresentationSubContext(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcGeometricRepresentationSubContext  > &ExpressDataSet::getAllIfcGeometricRepresentationSubContext ()
{
    return m_refIfcGeometricRepresentationSubContextList;
}



IfcGeometricSet *ExpressDataSet::getIfcGeometricSet(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcGeometricSet * > (current->second.get());
    }
    else
    {
        IfcGeometricSet *ret = static_cast< IfcGeometricSet * > (allocateIfcGeometricSet(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcGeometricSet(IfcGeometricSet *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcGeometricSet_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcGeometricSet(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcGeometricSet *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcGeometricSet(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcGeometricSet_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcGeometricSet > ExpressDataSet::createIfcGeometricSet(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcGeometricSet(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcGeometricSet * > (allocateIfcGeometricSet(this, Step::Id_UNSET));
    }
}

IfcGeometricSet *ExpressDataSet::cloneIfcGeometricSet(ExpressDataSet *expressDataSet, const IfcGeometricSet &obj, const CopyOp &copyop)
{
    IfcGeometricSet *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcGeometricSet(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcGeometricSet_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcGeometricSet *ExpressDataSet::cloneIfcGeometricSet(const IfcGeometricSet &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcGeometricSet(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcGeometricSet(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcGeometricSet  > &ExpressDataSet::getAllIfcGeometricSet ()
{
    return m_refIfcGeometricSetList;
}



IfcGrid *ExpressDataSet::getIfcGrid(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcGrid * > (current->second.get());
    }
    else
    {
        IfcGrid *ret = static_cast< IfcGrid * > (allocateIfcGrid(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcGrid(IfcGrid *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcGrid_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcGrid(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcGrid *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcGrid(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcGrid_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcGrid > ExpressDataSet::createIfcGrid(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcGrid(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcGrid * > (allocateIfcGrid(this, Step::Id_UNSET));
    }
}

IfcGrid *ExpressDataSet::cloneIfcGrid(ExpressDataSet *expressDataSet, const IfcGrid &obj, const CopyOp &copyop)
{
    IfcGrid *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcGrid(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcGrid_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcGrid *ExpressDataSet::cloneIfcGrid(const IfcGrid &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcGrid(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcGrid(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcGrid  > &ExpressDataSet::getAllIfcGrid ()
{
    return m_refIfcGridList;
}



IfcGridAxis *ExpressDataSet::getIfcGridAxis(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcGridAxis * > (current->second.get());
    }
    else
    {
        IfcGridAxis *ret = static_cast< IfcGridAxis * > (allocateIfcGridAxis(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcGridAxis(IfcGridAxis *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcGridAxis_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcGridAxis(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcGridAxis *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcGridAxis(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcGridAxis_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcGridAxis > ExpressDataSet::createIfcGridAxis(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcGridAxis(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcGridAxis * > (allocateIfcGridAxis(this, Step::Id_UNSET));
    }
}

IfcGridAxis *ExpressDataSet::cloneIfcGridAxis(ExpressDataSet *expressDataSet, const IfcGridAxis &obj, const CopyOp &copyop)
{
    IfcGridAxis *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcGridAxis(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcGridAxis_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcGridAxis *ExpressDataSet::cloneIfcGridAxis(const IfcGridAxis &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcGridAxis(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcGridAxis(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcGridAxis  > &ExpressDataSet::getAllIfcGridAxis ()
{
    return m_refIfcGridAxisList;
}



IfcGridPlacement *ExpressDataSet::getIfcGridPlacement(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcGridPlacement * > (current->second.get());
    }
    else
    {
        IfcGridPlacement *ret = static_cast< IfcGridPlacement * > (allocateIfcGridPlacement(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcGridPlacement(IfcGridPlacement *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcGridPlacement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcGridPlacement(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcGridPlacement *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcGridPlacement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcGridPlacement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcGridPlacement > ExpressDataSet::createIfcGridPlacement(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcGridPlacement(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcGridPlacement * > (allocateIfcGridPlacement(this, Step::Id_UNSET));
    }
}

IfcGridPlacement *ExpressDataSet::cloneIfcGridPlacement(ExpressDataSet *expressDataSet, const IfcGridPlacement &obj, const CopyOp &copyop)
{
    IfcGridPlacement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcGridPlacement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcGridPlacement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcGridPlacement *ExpressDataSet::cloneIfcGridPlacement(const IfcGridPlacement &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcGridPlacement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcGridPlacement(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcGridPlacement  > &ExpressDataSet::getAllIfcGridPlacement ()
{
    return m_refIfcGridPlacementList;
}



IfcGroup *ExpressDataSet::getIfcGroup(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcGroup * > (current->second.get());
    }
    else
    {
        IfcGroup *ret = static_cast< IfcGroup * > (allocateIfcGroup(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcGroup(IfcGroup *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcGroup_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcGroup(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcGroup *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcGroup(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcGroup_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcGroup > ExpressDataSet::createIfcGroup(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcGroup(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcGroup * > (allocateIfcGroup(this, Step::Id_UNSET));
    }
}

IfcGroup *ExpressDataSet::cloneIfcGroup(ExpressDataSet *expressDataSet, const IfcGroup &obj, const CopyOp &copyop)
{
    IfcGroup *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcGroup(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcGroup_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcGroup *ExpressDataSet::cloneIfcGroup(const IfcGroup &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcGroup(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcGroup(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcGroup  > &ExpressDataSet::getAllIfcGroup ()
{
    return m_refIfcGroupList;
}



IfcHalfSpaceSolid *ExpressDataSet::getIfcHalfSpaceSolid(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcHalfSpaceSolid * > (current->second.get());
    }
    else
    {
        IfcHalfSpaceSolid *ret = static_cast< IfcHalfSpaceSolid * > (allocateIfcHalfSpaceSolid(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcHalfSpaceSolid(IfcHalfSpaceSolid *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcHalfSpaceSolid_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcHalfSpaceSolid(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcHalfSpaceSolid *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcHalfSpaceSolid(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcHalfSpaceSolid_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcHalfSpaceSolid > ExpressDataSet::createIfcHalfSpaceSolid(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcHalfSpaceSolid(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcHalfSpaceSolid * > (allocateIfcHalfSpaceSolid(this, Step::Id_UNSET));
    }
}

IfcHalfSpaceSolid *ExpressDataSet::cloneIfcHalfSpaceSolid(ExpressDataSet *expressDataSet, const IfcHalfSpaceSolid &obj, const CopyOp &copyop)
{
    IfcHalfSpaceSolid *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcHalfSpaceSolid(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcHalfSpaceSolid_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcHalfSpaceSolid *ExpressDataSet::cloneIfcHalfSpaceSolid(const IfcHalfSpaceSolid &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcHalfSpaceSolid(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcHalfSpaceSolid(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcHalfSpaceSolid  > &ExpressDataSet::getAllIfcHalfSpaceSolid ()
{
    return m_refIfcHalfSpaceSolidList;
}



IfcHeatExchangerType *ExpressDataSet::getIfcHeatExchangerType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcHeatExchangerType * > (current->second.get());
    }
    else
    {
        IfcHeatExchangerType *ret = static_cast< IfcHeatExchangerType * > (allocateIfcHeatExchangerType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcHeatExchangerType(IfcHeatExchangerType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcHeatExchangerType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcHeatExchangerType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcHeatExchangerType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcHeatExchangerType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcHeatExchangerType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcHeatExchangerType > ExpressDataSet::createIfcHeatExchangerType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcHeatExchangerType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcHeatExchangerType * > (allocateIfcHeatExchangerType(this, Step::Id_UNSET));
    }
}

IfcHeatExchangerType *ExpressDataSet::cloneIfcHeatExchangerType(ExpressDataSet *expressDataSet, const IfcHeatExchangerType &obj, const CopyOp &copyop)
{
    IfcHeatExchangerType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcHeatExchangerType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcHeatExchangerType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcHeatExchangerType *ExpressDataSet::cloneIfcHeatExchangerType(const IfcHeatExchangerType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcHeatExchangerType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcHeatExchangerType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcHeatExchangerType  > &ExpressDataSet::getAllIfcHeatExchangerType ()
{
    return m_refIfcHeatExchangerTypeList;
}



IfcHumidifierType *ExpressDataSet::getIfcHumidifierType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcHumidifierType * > (current->second.get());
    }
    else
    {
        IfcHumidifierType *ret = static_cast< IfcHumidifierType * > (allocateIfcHumidifierType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcHumidifierType(IfcHumidifierType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcHumidifierType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcHumidifierType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcHumidifierType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcHumidifierType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcHumidifierType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcHumidifierType > ExpressDataSet::createIfcHumidifierType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcHumidifierType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcHumidifierType * > (allocateIfcHumidifierType(this, Step::Id_UNSET));
    }
}

IfcHumidifierType *ExpressDataSet::cloneIfcHumidifierType(ExpressDataSet *expressDataSet, const IfcHumidifierType &obj, const CopyOp &copyop)
{
    IfcHumidifierType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcHumidifierType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcHumidifierType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcHumidifierType *ExpressDataSet::cloneIfcHumidifierType(const IfcHumidifierType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcHumidifierType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcHumidifierType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcHumidifierType  > &ExpressDataSet::getAllIfcHumidifierType ()
{
    return m_refIfcHumidifierTypeList;
}



IfcHygroscopicMaterialProperties *ExpressDataSet::getIfcHygroscopicMaterialProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcHygroscopicMaterialProperties * > (current->second.get());
    }
    else
    {
        IfcHygroscopicMaterialProperties *ret = static_cast< IfcHygroscopicMaterialProperties * > (allocateIfcHygroscopicMaterialProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcHygroscopicMaterialProperties(IfcHygroscopicMaterialProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcHygroscopicMaterialProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcHygroscopicMaterialProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcHygroscopicMaterialProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcHygroscopicMaterialProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcHygroscopicMaterialProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcHygroscopicMaterialProperties > ExpressDataSet::createIfcHygroscopicMaterialProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcHygroscopicMaterialProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcHygroscopicMaterialProperties * > (allocateIfcHygroscopicMaterialProperties(this, Step::Id_UNSET));
    }
}

IfcHygroscopicMaterialProperties *ExpressDataSet::cloneIfcHygroscopicMaterialProperties(ExpressDataSet *expressDataSet, const IfcHygroscopicMaterialProperties &obj, const CopyOp &copyop)
{
    IfcHygroscopicMaterialProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcHygroscopicMaterialProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcHygroscopicMaterialProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcHygroscopicMaterialProperties *ExpressDataSet::cloneIfcHygroscopicMaterialProperties(const IfcHygroscopicMaterialProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcHygroscopicMaterialProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcHygroscopicMaterialProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcHygroscopicMaterialProperties  > &ExpressDataSet::getAllIfcHygroscopicMaterialProperties ()
{
    return m_refIfcHygroscopicMaterialPropertiesList;
}



IfcImageTexture *ExpressDataSet::getIfcImageTexture(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcImageTexture * > (current->second.get());
    }
    else
    {
        IfcImageTexture *ret = static_cast< IfcImageTexture * > (allocateIfcImageTexture(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcImageTexture(IfcImageTexture *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcImageTexture_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcImageTexture(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcImageTexture *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcImageTexture(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcImageTexture_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcImageTexture > ExpressDataSet::createIfcImageTexture(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcImageTexture(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcImageTexture * > (allocateIfcImageTexture(this, Step::Id_UNSET));
    }
}

IfcImageTexture *ExpressDataSet::cloneIfcImageTexture(ExpressDataSet *expressDataSet, const IfcImageTexture &obj, const CopyOp &copyop)
{
    IfcImageTexture *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcImageTexture(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcImageTexture_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcImageTexture *ExpressDataSet::cloneIfcImageTexture(const IfcImageTexture &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcImageTexture(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcImageTexture(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcImageTexture  > &ExpressDataSet::getAllIfcImageTexture ()
{
    return m_refIfcImageTextureList;
}



IfcInventory *ExpressDataSet::getIfcInventory(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcInventory * > (current->second.get());
    }
    else
    {
        IfcInventory *ret = static_cast< IfcInventory * > (allocateIfcInventory(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcInventory(IfcInventory *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcInventory_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcInventory(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcInventory *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcInventory(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcInventory_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcInventory > ExpressDataSet::createIfcInventory(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcInventory(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcInventory * > (allocateIfcInventory(this, Step::Id_UNSET));
    }
}

IfcInventory *ExpressDataSet::cloneIfcInventory(ExpressDataSet *expressDataSet, const IfcInventory &obj, const CopyOp &copyop)
{
    IfcInventory *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcInventory(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcInventory_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcInventory *ExpressDataSet::cloneIfcInventory(const IfcInventory &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcInventory(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcInventory(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcInventory  > &ExpressDataSet::getAllIfcInventory ()
{
    return m_refIfcInventoryList;
}



IfcIrregularTimeSeries *ExpressDataSet::getIfcIrregularTimeSeries(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcIrregularTimeSeries * > (current->second.get());
    }
    else
    {
        IfcIrregularTimeSeries *ret = static_cast< IfcIrregularTimeSeries * > (allocateIfcIrregularTimeSeries(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcIrregularTimeSeries(IfcIrregularTimeSeries *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcIrregularTimeSeries_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcIrregularTimeSeries(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcIrregularTimeSeries *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcIrregularTimeSeries(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcIrregularTimeSeries_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcIrregularTimeSeries > ExpressDataSet::createIfcIrregularTimeSeries(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcIrregularTimeSeries(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcIrregularTimeSeries * > (allocateIfcIrregularTimeSeries(this, Step::Id_UNSET));
    }
}

IfcIrregularTimeSeries *ExpressDataSet::cloneIfcIrregularTimeSeries(ExpressDataSet *expressDataSet, const IfcIrregularTimeSeries &obj, const CopyOp &copyop)
{
    IfcIrregularTimeSeries *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcIrregularTimeSeries(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcIrregularTimeSeries_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcIrregularTimeSeries *ExpressDataSet::cloneIfcIrregularTimeSeries(const IfcIrregularTimeSeries &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcIrregularTimeSeries(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcIrregularTimeSeries(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcIrregularTimeSeries  > &ExpressDataSet::getAllIfcIrregularTimeSeries ()
{
    return m_refIfcIrregularTimeSeriesList;
}



IfcIrregularTimeSeriesValue *ExpressDataSet::getIfcIrregularTimeSeriesValue(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcIrregularTimeSeriesValue * > (current->second.get());
    }
    else
    {
        IfcIrregularTimeSeriesValue *ret = static_cast< IfcIrregularTimeSeriesValue * > (allocateIfcIrregularTimeSeriesValue(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcIrregularTimeSeriesValue(IfcIrregularTimeSeriesValue *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcIrregularTimeSeriesValue_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcIrregularTimeSeriesValue(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcIrregularTimeSeriesValue *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcIrregularTimeSeriesValue(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcIrregularTimeSeriesValue_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcIrregularTimeSeriesValue > ExpressDataSet::createIfcIrregularTimeSeriesValue(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcIrregularTimeSeriesValue(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcIrregularTimeSeriesValue * > (allocateIfcIrregularTimeSeriesValue(this, Step::Id_UNSET));
    }
}

IfcIrregularTimeSeriesValue *ExpressDataSet::cloneIfcIrregularTimeSeriesValue(ExpressDataSet *expressDataSet, const IfcIrregularTimeSeriesValue &obj, const CopyOp &copyop)
{
    IfcIrregularTimeSeriesValue *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcIrregularTimeSeriesValue(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcIrregularTimeSeriesValue_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcIrregularTimeSeriesValue *ExpressDataSet::cloneIfcIrregularTimeSeriesValue(const IfcIrregularTimeSeriesValue &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcIrregularTimeSeriesValue(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcIrregularTimeSeriesValue(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcIrregularTimeSeriesValue  > &ExpressDataSet::getAllIfcIrregularTimeSeriesValue ()
{
    return m_refIfcIrregularTimeSeriesValueList;
}



IfcIShapeProfileDef *ExpressDataSet::getIfcIShapeProfileDef(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcIShapeProfileDef * > (current->second.get());
    }
    else
    {
        IfcIShapeProfileDef *ret = static_cast< IfcIShapeProfileDef * > (allocateIfcIShapeProfileDef(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcIShapeProfileDef(IfcIShapeProfileDef *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcIShapeProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcIShapeProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcIShapeProfileDef *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcIShapeProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcIShapeProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcIShapeProfileDef > ExpressDataSet::createIfcIShapeProfileDef(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcIShapeProfileDef(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcIShapeProfileDef * > (allocateIfcIShapeProfileDef(this, Step::Id_UNSET));
    }
}

IfcIShapeProfileDef *ExpressDataSet::cloneIfcIShapeProfileDef(ExpressDataSet *expressDataSet, const IfcIShapeProfileDef &obj, const CopyOp &copyop)
{
    IfcIShapeProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcIShapeProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcIShapeProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcIShapeProfileDef *ExpressDataSet::cloneIfcIShapeProfileDef(const IfcIShapeProfileDef &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcIShapeProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcIShapeProfileDef(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcIShapeProfileDef  > &ExpressDataSet::getAllIfcIShapeProfileDef ()
{
    return m_refIfcIShapeProfileDefList;
}



IfcJunctionBoxType *ExpressDataSet::getIfcJunctionBoxType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcJunctionBoxType * > (current->second.get());
    }
    else
    {
        IfcJunctionBoxType *ret = static_cast< IfcJunctionBoxType * > (allocateIfcJunctionBoxType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcJunctionBoxType(IfcJunctionBoxType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcJunctionBoxType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcJunctionBoxType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcJunctionBoxType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcJunctionBoxType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcJunctionBoxType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcJunctionBoxType > ExpressDataSet::createIfcJunctionBoxType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcJunctionBoxType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcJunctionBoxType * > (allocateIfcJunctionBoxType(this, Step::Id_UNSET));
    }
}

IfcJunctionBoxType *ExpressDataSet::cloneIfcJunctionBoxType(ExpressDataSet *expressDataSet, const IfcJunctionBoxType &obj, const CopyOp &copyop)
{
    IfcJunctionBoxType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcJunctionBoxType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcJunctionBoxType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcJunctionBoxType *ExpressDataSet::cloneIfcJunctionBoxType(const IfcJunctionBoxType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcJunctionBoxType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcJunctionBoxType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcJunctionBoxType  > &ExpressDataSet::getAllIfcJunctionBoxType ()
{
    return m_refIfcJunctionBoxTypeList;
}



IfcLaborResource *ExpressDataSet::getIfcLaborResource(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcLaborResource * > (current->second.get());
    }
    else
    {
        IfcLaborResource *ret = static_cast< IfcLaborResource * > (allocateIfcLaborResource(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcLaborResource(IfcLaborResource *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcLaborResource_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLaborResource(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcLaborResource *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLaborResource(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLaborResource_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLaborResource > ExpressDataSet::createIfcLaborResource(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcLaborResource(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcLaborResource * > (allocateIfcLaborResource(this, Step::Id_UNSET));
    }
}

IfcLaborResource *ExpressDataSet::cloneIfcLaborResource(ExpressDataSet *expressDataSet, const IfcLaborResource &obj, const CopyOp &copyop)
{
    IfcLaborResource *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLaborResource(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLaborResource_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLaborResource *ExpressDataSet::cloneIfcLaborResource(const IfcLaborResource &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcLaborResource(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcLaborResource(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcLaborResource  > &ExpressDataSet::getAllIfcLaborResource ()
{
    return m_refIfcLaborResourceList;
}



IfcLampType *ExpressDataSet::getIfcLampType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcLampType * > (current->second.get());
    }
    else
    {
        IfcLampType *ret = static_cast< IfcLampType * > (allocateIfcLampType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcLampType(IfcLampType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcLampType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLampType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcLampType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLampType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLampType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLampType > ExpressDataSet::createIfcLampType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcLampType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcLampType * > (allocateIfcLampType(this, Step::Id_UNSET));
    }
}

IfcLampType *ExpressDataSet::cloneIfcLampType(ExpressDataSet *expressDataSet, const IfcLampType &obj, const CopyOp &copyop)
{
    IfcLampType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLampType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLampType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLampType *ExpressDataSet::cloneIfcLampType(const IfcLampType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcLampType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcLampType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcLampType  > &ExpressDataSet::getAllIfcLampType ()
{
    return m_refIfcLampTypeList;
}



IfcLibraryInformation *ExpressDataSet::getIfcLibraryInformation(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcLibraryInformation * > (current->second.get());
    }
    else
    {
        IfcLibraryInformation *ret = static_cast< IfcLibraryInformation * > (allocateIfcLibraryInformation(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcLibraryInformation(IfcLibraryInformation *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcLibraryInformation_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLibraryInformation(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcLibraryInformation *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLibraryInformation(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLibraryInformation_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLibraryInformation > ExpressDataSet::createIfcLibraryInformation(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcLibraryInformation(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcLibraryInformation * > (allocateIfcLibraryInformation(this, Step::Id_UNSET));
    }
}

IfcLibraryInformation *ExpressDataSet::cloneIfcLibraryInformation(ExpressDataSet *expressDataSet, const IfcLibraryInformation &obj, const CopyOp &copyop)
{
    IfcLibraryInformation *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLibraryInformation(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLibraryInformation_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLibraryInformation *ExpressDataSet::cloneIfcLibraryInformation(const IfcLibraryInformation &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcLibraryInformation(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcLibraryInformation(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcLibraryInformation  > &ExpressDataSet::getAllIfcLibraryInformation ()
{
    return m_refIfcLibraryInformationList;
}



IfcLibraryReference *ExpressDataSet::getIfcLibraryReference(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcLibraryReference * > (current->second.get());
    }
    else
    {
        IfcLibraryReference *ret = static_cast< IfcLibraryReference * > (allocateIfcLibraryReference(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcLibraryReference(IfcLibraryReference *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcLibraryReference_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLibraryReference(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcLibraryReference *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLibraryReference(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLibraryReference_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLibraryReference > ExpressDataSet::createIfcLibraryReference(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcLibraryReference(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcLibraryReference * > (allocateIfcLibraryReference(this, Step::Id_UNSET));
    }
}

IfcLibraryReference *ExpressDataSet::cloneIfcLibraryReference(ExpressDataSet *expressDataSet, const IfcLibraryReference &obj, const CopyOp &copyop)
{
    IfcLibraryReference *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLibraryReference(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLibraryReference_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLibraryReference *ExpressDataSet::cloneIfcLibraryReference(const IfcLibraryReference &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcLibraryReference(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcLibraryReference(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcLibraryReference  > &ExpressDataSet::getAllIfcLibraryReference ()
{
    return m_refIfcLibraryReferenceList;
}



IfcLightDistributionData *ExpressDataSet::getIfcLightDistributionData(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcLightDistributionData * > (current->second.get());
    }
    else
    {
        IfcLightDistributionData *ret = static_cast< IfcLightDistributionData * > (allocateIfcLightDistributionData(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcLightDistributionData(IfcLightDistributionData *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcLightDistributionData_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLightDistributionData(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcLightDistributionData *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLightDistributionData(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLightDistributionData_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLightDistributionData > ExpressDataSet::createIfcLightDistributionData(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcLightDistributionData(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcLightDistributionData * > (allocateIfcLightDistributionData(this, Step::Id_UNSET));
    }
}

IfcLightDistributionData *ExpressDataSet::cloneIfcLightDistributionData(ExpressDataSet *expressDataSet, const IfcLightDistributionData &obj, const CopyOp &copyop)
{
    IfcLightDistributionData *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLightDistributionData(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLightDistributionData_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLightDistributionData *ExpressDataSet::cloneIfcLightDistributionData(const IfcLightDistributionData &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcLightDistributionData(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcLightDistributionData(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcLightDistributionData  > &ExpressDataSet::getAllIfcLightDistributionData ()
{
    return m_refIfcLightDistributionDataList;
}



IfcLightFixtureType *ExpressDataSet::getIfcLightFixtureType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcLightFixtureType * > (current->second.get());
    }
    else
    {
        IfcLightFixtureType *ret = static_cast< IfcLightFixtureType * > (allocateIfcLightFixtureType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcLightFixtureType(IfcLightFixtureType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcLightFixtureType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLightFixtureType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcLightFixtureType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLightFixtureType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLightFixtureType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLightFixtureType > ExpressDataSet::createIfcLightFixtureType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcLightFixtureType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcLightFixtureType * > (allocateIfcLightFixtureType(this, Step::Id_UNSET));
    }
}

IfcLightFixtureType *ExpressDataSet::cloneIfcLightFixtureType(ExpressDataSet *expressDataSet, const IfcLightFixtureType &obj, const CopyOp &copyop)
{
    IfcLightFixtureType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLightFixtureType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLightFixtureType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLightFixtureType *ExpressDataSet::cloneIfcLightFixtureType(const IfcLightFixtureType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcLightFixtureType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcLightFixtureType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcLightFixtureType  > &ExpressDataSet::getAllIfcLightFixtureType ()
{
    return m_refIfcLightFixtureTypeList;
}



IfcLightIntensityDistribution *ExpressDataSet::getIfcLightIntensityDistribution(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcLightIntensityDistribution * > (current->second.get());
    }
    else
    {
        IfcLightIntensityDistribution *ret = static_cast< IfcLightIntensityDistribution * > (allocateIfcLightIntensityDistribution(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcLightIntensityDistribution(IfcLightIntensityDistribution *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcLightIntensityDistribution_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLightIntensityDistribution(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcLightIntensityDistribution *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLightIntensityDistribution(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLightIntensityDistribution_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLightIntensityDistribution > ExpressDataSet::createIfcLightIntensityDistribution(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcLightIntensityDistribution(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcLightIntensityDistribution * > (allocateIfcLightIntensityDistribution(this, Step::Id_UNSET));
    }
}

IfcLightIntensityDistribution *ExpressDataSet::cloneIfcLightIntensityDistribution(ExpressDataSet *expressDataSet, const IfcLightIntensityDistribution &obj, const CopyOp &copyop)
{
    IfcLightIntensityDistribution *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLightIntensityDistribution(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLightIntensityDistribution_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLightIntensityDistribution *ExpressDataSet::cloneIfcLightIntensityDistribution(const IfcLightIntensityDistribution &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcLightIntensityDistribution(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcLightIntensityDistribution(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcLightIntensityDistribution  > &ExpressDataSet::getAllIfcLightIntensityDistribution ()
{
    return m_refIfcLightIntensityDistributionList;
}



IfcLightSource *ExpressDataSet::getIfcLightSource(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcLightSource * > (current->second.get());
    }
    else
    {
        IfcLightSource *ret = static_cast< IfcLightSource * > (allocateIfcLightSource(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcLightSource(IfcLightSource *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcLightSource_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLightSource(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcLightSource *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLightSource(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLightSource_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLightSource > ExpressDataSet::createIfcLightSource(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcLightSource(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcLightSource * > (allocateIfcLightSource(this, Step::Id_UNSET));
    }
}

IfcLightSource *ExpressDataSet::cloneIfcLightSource(ExpressDataSet *expressDataSet, const IfcLightSource &obj, const CopyOp &copyop)
{
    IfcLightSource *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLightSource(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLightSource_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLightSource *ExpressDataSet::cloneIfcLightSource(const IfcLightSource &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcLightSource(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcLightSource(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcLightSource  > &ExpressDataSet::getAllIfcLightSource ()
{
    return m_refIfcLightSourceList;
}



IfcLightSourceAmbient *ExpressDataSet::getIfcLightSourceAmbient(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcLightSourceAmbient * > (current->second.get());
    }
    else
    {
        IfcLightSourceAmbient *ret = static_cast< IfcLightSourceAmbient * > (allocateIfcLightSourceAmbient(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcLightSourceAmbient(IfcLightSourceAmbient *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcLightSourceAmbient_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLightSourceAmbient(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcLightSourceAmbient *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLightSourceAmbient(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLightSourceAmbient_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLightSourceAmbient > ExpressDataSet::createIfcLightSourceAmbient(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcLightSourceAmbient(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcLightSourceAmbient * > (allocateIfcLightSourceAmbient(this, Step::Id_UNSET));
    }
}

IfcLightSourceAmbient *ExpressDataSet::cloneIfcLightSourceAmbient(ExpressDataSet *expressDataSet, const IfcLightSourceAmbient &obj, const CopyOp &copyop)
{
    IfcLightSourceAmbient *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLightSourceAmbient(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLightSourceAmbient_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLightSourceAmbient *ExpressDataSet::cloneIfcLightSourceAmbient(const IfcLightSourceAmbient &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcLightSourceAmbient(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcLightSourceAmbient(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcLightSourceAmbient  > &ExpressDataSet::getAllIfcLightSourceAmbient ()
{
    return m_refIfcLightSourceAmbientList;
}



IfcLightSourceDirectional *ExpressDataSet::getIfcLightSourceDirectional(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcLightSourceDirectional * > (current->second.get());
    }
    else
    {
        IfcLightSourceDirectional *ret = static_cast< IfcLightSourceDirectional * > (allocateIfcLightSourceDirectional(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcLightSourceDirectional(IfcLightSourceDirectional *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcLightSourceDirectional_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLightSourceDirectional(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcLightSourceDirectional *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLightSourceDirectional(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLightSourceDirectional_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLightSourceDirectional > ExpressDataSet::createIfcLightSourceDirectional(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcLightSourceDirectional(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcLightSourceDirectional * > (allocateIfcLightSourceDirectional(this, Step::Id_UNSET));
    }
}

IfcLightSourceDirectional *ExpressDataSet::cloneIfcLightSourceDirectional(ExpressDataSet *expressDataSet, const IfcLightSourceDirectional &obj, const CopyOp &copyop)
{
    IfcLightSourceDirectional *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLightSourceDirectional(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLightSourceDirectional_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLightSourceDirectional *ExpressDataSet::cloneIfcLightSourceDirectional(const IfcLightSourceDirectional &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcLightSourceDirectional(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcLightSourceDirectional(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcLightSourceDirectional  > &ExpressDataSet::getAllIfcLightSourceDirectional ()
{
    return m_refIfcLightSourceDirectionalList;
}



IfcLightSourceGoniometric *ExpressDataSet::getIfcLightSourceGoniometric(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcLightSourceGoniometric * > (current->second.get());
    }
    else
    {
        IfcLightSourceGoniometric *ret = static_cast< IfcLightSourceGoniometric * > (allocateIfcLightSourceGoniometric(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcLightSourceGoniometric(IfcLightSourceGoniometric *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcLightSourceGoniometric_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLightSourceGoniometric(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcLightSourceGoniometric *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLightSourceGoniometric(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLightSourceGoniometric_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLightSourceGoniometric > ExpressDataSet::createIfcLightSourceGoniometric(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcLightSourceGoniometric(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcLightSourceGoniometric * > (allocateIfcLightSourceGoniometric(this, Step::Id_UNSET));
    }
}

IfcLightSourceGoniometric *ExpressDataSet::cloneIfcLightSourceGoniometric(ExpressDataSet *expressDataSet, const IfcLightSourceGoniometric &obj, const CopyOp &copyop)
{
    IfcLightSourceGoniometric *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLightSourceGoniometric(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLightSourceGoniometric_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLightSourceGoniometric *ExpressDataSet::cloneIfcLightSourceGoniometric(const IfcLightSourceGoniometric &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcLightSourceGoniometric(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcLightSourceGoniometric(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcLightSourceGoniometric  > &ExpressDataSet::getAllIfcLightSourceGoniometric ()
{
    return m_refIfcLightSourceGoniometricList;
}



IfcLightSourcePositional *ExpressDataSet::getIfcLightSourcePositional(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcLightSourcePositional * > (current->second.get());
    }
    else
    {
        IfcLightSourcePositional *ret = static_cast< IfcLightSourcePositional * > (allocateIfcLightSourcePositional(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcLightSourcePositional(IfcLightSourcePositional *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcLightSourcePositional_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLightSourcePositional(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcLightSourcePositional *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLightSourcePositional(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLightSourcePositional_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLightSourcePositional > ExpressDataSet::createIfcLightSourcePositional(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcLightSourcePositional(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcLightSourcePositional * > (allocateIfcLightSourcePositional(this, Step::Id_UNSET));
    }
}

IfcLightSourcePositional *ExpressDataSet::cloneIfcLightSourcePositional(ExpressDataSet *expressDataSet, const IfcLightSourcePositional &obj, const CopyOp &copyop)
{
    IfcLightSourcePositional *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLightSourcePositional(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLightSourcePositional_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLightSourcePositional *ExpressDataSet::cloneIfcLightSourcePositional(const IfcLightSourcePositional &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcLightSourcePositional(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcLightSourcePositional(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcLightSourcePositional  > &ExpressDataSet::getAllIfcLightSourcePositional ()
{
    return m_refIfcLightSourcePositionalList;
}



IfcLightSourceSpot *ExpressDataSet::getIfcLightSourceSpot(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcLightSourceSpot * > (current->second.get());
    }
    else
    {
        IfcLightSourceSpot *ret = static_cast< IfcLightSourceSpot * > (allocateIfcLightSourceSpot(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcLightSourceSpot(IfcLightSourceSpot *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcLightSourceSpot_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLightSourceSpot(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcLightSourceSpot *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLightSourceSpot(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLightSourceSpot_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLightSourceSpot > ExpressDataSet::createIfcLightSourceSpot(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcLightSourceSpot(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcLightSourceSpot * > (allocateIfcLightSourceSpot(this, Step::Id_UNSET));
    }
}

IfcLightSourceSpot *ExpressDataSet::cloneIfcLightSourceSpot(ExpressDataSet *expressDataSet, const IfcLightSourceSpot &obj, const CopyOp &copyop)
{
    IfcLightSourceSpot *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLightSourceSpot(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLightSourceSpot_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLightSourceSpot *ExpressDataSet::cloneIfcLightSourceSpot(const IfcLightSourceSpot &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcLightSourceSpot(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcLightSourceSpot(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcLightSourceSpot  > &ExpressDataSet::getAllIfcLightSourceSpot ()
{
    return m_refIfcLightSourceSpotList;
}



IfcLine *ExpressDataSet::getIfcLine(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcLine * > (current->second.get());
    }
    else
    {
        IfcLine *ret = static_cast< IfcLine * > (allocateIfcLine(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcLine(IfcLine *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcLine_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLine(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcLine *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLine(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLine_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLine > ExpressDataSet::createIfcLine(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcLine(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcLine * > (allocateIfcLine(this, Step::Id_UNSET));
    }
}

IfcLine *ExpressDataSet::cloneIfcLine(ExpressDataSet *expressDataSet, const IfcLine &obj, const CopyOp &copyop)
{
    IfcLine *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLine(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLine_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLine *ExpressDataSet::cloneIfcLine(const IfcLine &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcLine(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcLine(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcLine  > &ExpressDataSet::getAllIfcLine ()
{
    return m_refIfcLineList;
}



IfcLinearDimension *ExpressDataSet::getIfcLinearDimension(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcLinearDimension * > (current->second.get());
    }
    else
    {
        IfcLinearDimension *ret = static_cast< IfcLinearDimension * > (allocateIfcLinearDimension(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcLinearDimension(IfcLinearDimension *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcLinearDimension_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLinearDimension(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcLinearDimension *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLinearDimension(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLinearDimension_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLinearDimension > ExpressDataSet::createIfcLinearDimension(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcLinearDimension(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcLinearDimension * > (allocateIfcLinearDimension(this, Step::Id_UNSET));
    }
}

IfcLinearDimension *ExpressDataSet::cloneIfcLinearDimension(ExpressDataSet *expressDataSet, const IfcLinearDimension &obj, const CopyOp &copyop)
{
    IfcLinearDimension *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLinearDimension(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLinearDimension_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLinearDimension *ExpressDataSet::cloneIfcLinearDimension(const IfcLinearDimension &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcLinearDimension(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcLinearDimension(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcLinearDimension  > &ExpressDataSet::getAllIfcLinearDimension ()
{
    return m_refIfcLinearDimensionList;
}



IfcLocalPlacement *ExpressDataSet::getIfcLocalPlacement(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcLocalPlacement * > (current->second.get());
    }
    else
    {
        IfcLocalPlacement *ret = static_cast< IfcLocalPlacement * > (allocateIfcLocalPlacement(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcLocalPlacement(IfcLocalPlacement *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcLocalPlacement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLocalPlacement(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcLocalPlacement *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLocalPlacement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLocalPlacement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLocalPlacement > ExpressDataSet::createIfcLocalPlacement(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcLocalPlacement(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcLocalPlacement * > (allocateIfcLocalPlacement(this, Step::Id_UNSET));
    }
}

IfcLocalPlacement *ExpressDataSet::cloneIfcLocalPlacement(ExpressDataSet *expressDataSet, const IfcLocalPlacement &obj, const CopyOp &copyop)
{
    IfcLocalPlacement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLocalPlacement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLocalPlacement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLocalPlacement *ExpressDataSet::cloneIfcLocalPlacement(const IfcLocalPlacement &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcLocalPlacement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcLocalPlacement(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcLocalPlacement  > &ExpressDataSet::getAllIfcLocalPlacement ()
{
    return m_refIfcLocalPlacementList;
}



IfcLocalTime *ExpressDataSet::getIfcLocalTime(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcLocalTime * > (current->second.get());
    }
    else
    {
        IfcLocalTime *ret = static_cast< IfcLocalTime * > (allocateIfcLocalTime(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcLocalTime(IfcLocalTime *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcLocalTime_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLocalTime(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcLocalTime *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLocalTime(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLocalTime_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLocalTime > ExpressDataSet::createIfcLocalTime(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcLocalTime(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcLocalTime * > (allocateIfcLocalTime(this, Step::Id_UNSET));
    }
}

IfcLocalTime *ExpressDataSet::cloneIfcLocalTime(ExpressDataSet *expressDataSet, const IfcLocalTime &obj, const CopyOp &copyop)
{
    IfcLocalTime *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLocalTime(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLocalTime_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLocalTime *ExpressDataSet::cloneIfcLocalTime(const IfcLocalTime &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcLocalTime(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcLocalTime(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcLocalTime  > &ExpressDataSet::getAllIfcLocalTime ()
{
    return m_refIfcLocalTimeList;
}



IfcLoop *ExpressDataSet::getIfcLoop(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcLoop * > (current->second.get());
    }
    else
    {
        IfcLoop *ret = static_cast< IfcLoop * > (allocateIfcLoop(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcLoop(IfcLoop *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcLoop_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLoop(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcLoop *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLoop(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLoop_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLoop > ExpressDataSet::createIfcLoop(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcLoop(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcLoop * > (allocateIfcLoop(this, Step::Id_UNSET));
    }
}

IfcLoop *ExpressDataSet::cloneIfcLoop(ExpressDataSet *expressDataSet, const IfcLoop &obj, const CopyOp &copyop)
{
    IfcLoop *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLoop(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLoop_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLoop *ExpressDataSet::cloneIfcLoop(const IfcLoop &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcLoop(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcLoop(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcLoop  > &ExpressDataSet::getAllIfcLoop ()
{
    return m_refIfcLoopList;
}



IfcLShapeProfileDef *ExpressDataSet::getIfcLShapeProfileDef(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcLShapeProfileDef * > (current->second.get());
    }
    else
    {
        IfcLShapeProfileDef *ret = static_cast< IfcLShapeProfileDef * > (allocateIfcLShapeProfileDef(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcLShapeProfileDef(IfcLShapeProfileDef *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcLShapeProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLShapeProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcLShapeProfileDef *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLShapeProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLShapeProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLShapeProfileDef > ExpressDataSet::createIfcLShapeProfileDef(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcLShapeProfileDef(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcLShapeProfileDef * > (allocateIfcLShapeProfileDef(this, Step::Id_UNSET));
    }
}

IfcLShapeProfileDef *ExpressDataSet::cloneIfcLShapeProfileDef(ExpressDataSet *expressDataSet, const IfcLShapeProfileDef &obj, const CopyOp &copyop)
{
    IfcLShapeProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLShapeProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLShapeProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLShapeProfileDef *ExpressDataSet::cloneIfcLShapeProfileDef(const IfcLShapeProfileDef &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcLShapeProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcLShapeProfileDef(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcLShapeProfileDef  > &ExpressDataSet::getAllIfcLShapeProfileDef ()
{
    return m_refIfcLShapeProfileDefList;
}



IfcManifoldSolidBrep *ExpressDataSet::getIfcManifoldSolidBrep(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcManifoldSolidBrep * > (current->second.get());
    }
    else
    {
        IfcManifoldSolidBrep *ret = static_cast< IfcManifoldSolidBrep * > (allocateIfcManifoldSolidBrep(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcManifoldSolidBrep(IfcManifoldSolidBrep *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcManifoldSolidBrep_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcManifoldSolidBrep(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcManifoldSolidBrep *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcManifoldSolidBrep(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcManifoldSolidBrep_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcManifoldSolidBrep > ExpressDataSet::createIfcManifoldSolidBrep(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcManifoldSolidBrep(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcManifoldSolidBrep * > (allocateIfcManifoldSolidBrep(this, Step::Id_UNSET));
    }
}

IfcManifoldSolidBrep *ExpressDataSet::cloneIfcManifoldSolidBrep(ExpressDataSet *expressDataSet, const IfcManifoldSolidBrep &obj, const CopyOp &copyop)
{
    IfcManifoldSolidBrep *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcManifoldSolidBrep(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcManifoldSolidBrep_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcManifoldSolidBrep *ExpressDataSet::cloneIfcManifoldSolidBrep(const IfcManifoldSolidBrep &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcManifoldSolidBrep(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcManifoldSolidBrep(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcManifoldSolidBrep  > &ExpressDataSet::getAllIfcManifoldSolidBrep ()
{
    return m_refIfcManifoldSolidBrepList;
}



IfcMappedItem *ExpressDataSet::getIfcMappedItem(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcMappedItem * > (current->second.get());
    }
    else
    {
        IfcMappedItem *ret = static_cast< IfcMappedItem * > (allocateIfcMappedItem(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcMappedItem(IfcMappedItem *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcMappedItem_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMappedItem(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcMappedItem *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMappedItem(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMappedItem_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMappedItem > ExpressDataSet::createIfcMappedItem(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcMappedItem(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcMappedItem * > (allocateIfcMappedItem(this, Step::Id_UNSET));
    }
}

IfcMappedItem *ExpressDataSet::cloneIfcMappedItem(ExpressDataSet *expressDataSet, const IfcMappedItem &obj, const CopyOp &copyop)
{
    IfcMappedItem *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMappedItem(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMappedItem_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMappedItem *ExpressDataSet::cloneIfcMappedItem(const IfcMappedItem &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcMappedItem(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcMappedItem(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcMappedItem  > &ExpressDataSet::getAllIfcMappedItem ()
{
    return m_refIfcMappedItemList;
}



IfcMaterial *ExpressDataSet::getIfcMaterial(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcMaterial * > (current->second.get());
    }
    else
    {
        IfcMaterial *ret = static_cast< IfcMaterial * > (allocateIfcMaterial(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcMaterial(IfcMaterial *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcMaterial_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMaterial(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcMaterial *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMaterial(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMaterial_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMaterial > ExpressDataSet::createIfcMaterial(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcMaterial(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcMaterial * > (allocateIfcMaterial(this, Step::Id_UNSET));
    }
}

IfcMaterial *ExpressDataSet::cloneIfcMaterial(ExpressDataSet *expressDataSet, const IfcMaterial &obj, const CopyOp &copyop)
{
    IfcMaterial *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMaterial(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMaterial_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMaterial *ExpressDataSet::cloneIfcMaterial(const IfcMaterial &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcMaterial(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcMaterial(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcMaterial  > &ExpressDataSet::getAllIfcMaterial ()
{
    return m_refIfcMaterialList;
}



IfcMaterialClassificationRelationship *ExpressDataSet::getIfcMaterialClassificationRelationship(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcMaterialClassificationRelationship * > (current->second.get());
    }
    else
    {
        IfcMaterialClassificationRelationship *ret = static_cast< IfcMaterialClassificationRelationship * > (allocateIfcMaterialClassificationRelationship(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcMaterialClassificationRelationship(IfcMaterialClassificationRelationship *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcMaterialClassificationRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMaterialClassificationRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcMaterialClassificationRelationship *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMaterialClassificationRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMaterialClassificationRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMaterialClassificationRelationship > ExpressDataSet::createIfcMaterialClassificationRelationship(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcMaterialClassificationRelationship(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcMaterialClassificationRelationship * > (allocateIfcMaterialClassificationRelationship(this, Step::Id_UNSET));
    }
}

IfcMaterialClassificationRelationship *ExpressDataSet::cloneIfcMaterialClassificationRelationship(ExpressDataSet *expressDataSet, const IfcMaterialClassificationRelationship &obj, const CopyOp &copyop)
{
    IfcMaterialClassificationRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMaterialClassificationRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMaterialClassificationRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMaterialClassificationRelationship *ExpressDataSet::cloneIfcMaterialClassificationRelationship(const IfcMaterialClassificationRelationship &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcMaterialClassificationRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcMaterialClassificationRelationship(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcMaterialClassificationRelationship  > &ExpressDataSet::getAllIfcMaterialClassificationRelationship ()
{
    return m_refIfcMaterialClassificationRelationshipList;
}



IfcMaterialDefinitionRepresentation *ExpressDataSet::getIfcMaterialDefinitionRepresentation(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcMaterialDefinitionRepresentation * > (current->second.get());
    }
    else
    {
        IfcMaterialDefinitionRepresentation *ret = static_cast< IfcMaterialDefinitionRepresentation * > (allocateIfcMaterialDefinitionRepresentation(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcMaterialDefinitionRepresentation(IfcMaterialDefinitionRepresentation *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcMaterialDefinitionRepresentation_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMaterialDefinitionRepresentation(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcMaterialDefinitionRepresentation *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMaterialDefinitionRepresentation(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMaterialDefinitionRepresentation_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMaterialDefinitionRepresentation > ExpressDataSet::createIfcMaterialDefinitionRepresentation(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcMaterialDefinitionRepresentation(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcMaterialDefinitionRepresentation * > (allocateIfcMaterialDefinitionRepresentation(this, Step::Id_UNSET));
    }
}

IfcMaterialDefinitionRepresentation *ExpressDataSet::cloneIfcMaterialDefinitionRepresentation(ExpressDataSet *expressDataSet, const IfcMaterialDefinitionRepresentation &obj, const CopyOp &copyop)
{
    IfcMaterialDefinitionRepresentation *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMaterialDefinitionRepresentation(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMaterialDefinitionRepresentation_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMaterialDefinitionRepresentation *ExpressDataSet::cloneIfcMaterialDefinitionRepresentation(const IfcMaterialDefinitionRepresentation &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcMaterialDefinitionRepresentation(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcMaterialDefinitionRepresentation(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcMaterialDefinitionRepresentation  > &ExpressDataSet::getAllIfcMaterialDefinitionRepresentation ()
{
    return m_refIfcMaterialDefinitionRepresentationList;
}



IfcMaterialLayer *ExpressDataSet::getIfcMaterialLayer(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcMaterialLayer * > (current->second.get());
    }
    else
    {
        IfcMaterialLayer *ret = static_cast< IfcMaterialLayer * > (allocateIfcMaterialLayer(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcMaterialLayer(IfcMaterialLayer *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcMaterialLayer_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMaterialLayer(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcMaterialLayer *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMaterialLayer(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMaterialLayer_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMaterialLayer > ExpressDataSet::createIfcMaterialLayer(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcMaterialLayer(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcMaterialLayer * > (allocateIfcMaterialLayer(this, Step::Id_UNSET));
    }
}

IfcMaterialLayer *ExpressDataSet::cloneIfcMaterialLayer(ExpressDataSet *expressDataSet, const IfcMaterialLayer &obj, const CopyOp &copyop)
{
    IfcMaterialLayer *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMaterialLayer(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMaterialLayer_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMaterialLayer *ExpressDataSet::cloneIfcMaterialLayer(const IfcMaterialLayer &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcMaterialLayer(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcMaterialLayer(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcMaterialLayer  > &ExpressDataSet::getAllIfcMaterialLayer ()
{
    return m_refIfcMaterialLayerList;
}



IfcMaterialLayerSet *ExpressDataSet::getIfcMaterialLayerSet(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcMaterialLayerSet * > (current->second.get());
    }
    else
    {
        IfcMaterialLayerSet *ret = static_cast< IfcMaterialLayerSet * > (allocateIfcMaterialLayerSet(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcMaterialLayerSet(IfcMaterialLayerSet *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcMaterialLayerSet_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMaterialLayerSet(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcMaterialLayerSet *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMaterialLayerSet(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMaterialLayerSet_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMaterialLayerSet > ExpressDataSet::createIfcMaterialLayerSet(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcMaterialLayerSet(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcMaterialLayerSet * > (allocateIfcMaterialLayerSet(this, Step::Id_UNSET));
    }
}

IfcMaterialLayerSet *ExpressDataSet::cloneIfcMaterialLayerSet(ExpressDataSet *expressDataSet, const IfcMaterialLayerSet &obj, const CopyOp &copyop)
{
    IfcMaterialLayerSet *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMaterialLayerSet(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMaterialLayerSet_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMaterialLayerSet *ExpressDataSet::cloneIfcMaterialLayerSet(const IfcMaterialLayerSet &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcMaterialLayerSet(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcMaterialLayerSet(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcMaterialLayerSet  > &ExpressDataSet::getAllIfcMaterialLayerSet ()
{
    return m_refIfcMaterialLayerSetList;
}



IfcMaterialLayerSetUsage *ExpressDataSet::getIfcMaterialLayerSetUsage(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcMaterialLayerSetUsage * > (current->second.get());
    }
    else
    {
        IfcMaterialLayerSetUsage *ret = static_cast< IfcMaterialLayerSetUsage * > (allocateIfcMaterialLayerSetUsage(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcMaterialLayerSetUsage(IfcMaterialLayerSetUsage *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcMaterialLayerSetUsage_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMaterialLayerSetUsage(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcMaterialLayerSetUsage *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMaterialLayerSetUsage(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMaterialLayerSetUsage_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMaterialLayerSetUsage > ExpressDataSet::createIfcMaterialLayerSetUsage(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcMaterialLayerSetUsage(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcMaterialLayerSetUsage * > (allocateIfcMaterialLayerSetUsage(this, Step::Id_UNSET));
    }
}

IfcMaterialLayerSetUsage *ExpressDataSet::cloneIfcMaterialLayerSetUsage(ExpressDataSet *expressDataSet, const IfcMaterialLayerSetUsage &obj, const CopyOp &copyop)
{
    IfcMaterialLayerSetUsage *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMaterialLayerSetUsage(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMaterialLayerSetUsage_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMaterialLayerSetUsage *ExpressDataSet::cloneIfcMaterialLayerSetUsage(const IfcMaterialLayerSetUsage &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcMaterialLayerSetUsage(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcMaterialLayerSetUsage(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcMaterialLayerSetUsage  > &ExpressDataSet::getAllIfcMaterialLayerSetUsage ()
{
    return m_refIfcMaterialLayerSetUsageList;
}



IfcMaterialList *ExpressDataSet::getIfcMaterialList(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcMaterialList * > (current->second.get());
    }
    else
    {
        IfcMaterialList *ret = static_cast< IfcMaterialList * > (allocateIfcMaterialList(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcMaterialList(IfcMaterialList *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcMaterialList_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMaterialList(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcMaterialList *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMaterialList(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMaterialList_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMaterialList > ExpressDataSet::createIfcMaterialList(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcMaterialList(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcMaterialList * > (allocateIfcMaterialList(this, Step::Id_UNSET));
    }
}

IfcMaterialList *ExpressDataSet::cloneIfcMaterialList(ExpressDataSet *expressDataSet, const IfcMaterialList &obj, const CopyOp &copyop)
{
    IfcMaterialList *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMaterialList(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMaterialList_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMaterialList *ExpressDataSet::cloneIfcMaterialList(const IfcMaterialList &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcMaterialList(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcMaterialList(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcMaterialList  > &ExpressDataSet::getAllIfcMaterialList ()
{
    return m_refIfcMaterialListList;
}



IfcMaterialProperties *ExpressDataSet::getIfcMaterialProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcMaterialProperties * > (current->second.get());
    }
    else
    {
        IfcMaterialProperties *ret = static_cast< IfcMaterialProperties * > (allocateIfcMaterialProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcMaterialProperties(IfcMaterialProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcMaterialProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMaterialProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcMaterialProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMaterialProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMaterialProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMaterialProperties > ExpressDataSet::createIfcMaterialProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcMaterialProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcMaterialProperties * > (allocateIfcMaterialProperties(this, Step::Id_UNSET));
    }
}

IfcMaterialProperties *ExpressDataSet::cloneIfcMaterialProperties(ExpressDataSet *expressDataSet, const IfcMaterialProperties &obj, const CopyOp &copyop)
{
    IfcMaterialProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMaterialProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMaterialProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMaterialProperties *ExpressDataSet::cloneIfcMaterialProperties(const IfcMaterialProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcMaterialProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcMaterialProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcMaterialProperties  > &ExpressDataSet::getAllIfcMaterialProperties ()
{
    return m_refIfcMaterialPropertiesList;
}



IfcMeasureWithUnit *ExpressDataSet::getIfcMeasureWithUnit(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcMeasureWithUnit * > (current->second.get());
    }
    else
    {
        IfcMeasureWithUnit *ret = static_cast< IfcMeasureWithUnit * > (allocateIfcMeasureWithUnit(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcMeasureWithUnit(IfcMeasureWithUnit *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcMeasureWithUnit_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMeasureWithUnit(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcMeasureWithUnit *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMeasureWithUnit(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMeasureWithUnit_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMeasureWithUnit > ExpressDataSet::createIfcMeasureWithUnit(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcMeasureWithUnit(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcMeasureWithUnit * > (allocateIfcMeasureWithUnit(this, Step::Id_UNSET));
    }
}

IfcMeasureWithUnit *ExpressDataSet::cloneIfcMeasureWithUnit(ExpressDataSet *expressDataSet, const IfcMeasureWithUnit &obj, const CopyOp &copyop)
{
    IfcMeasureWithUnit *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMeasureWithUnit(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMeasureWithUnit_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMeasureWithUnit *ExpressDataSet::cloneIfcMeasureWithUnit(const IfcMeasureWithUnit &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcMeasureWithUnit(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcMeasureWithUnit(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcMeasureWithUnit  > &ExpressDataSet::getAllIfcMeasureWithUnit ()
{
    return m_refIfcMeasureWithUnitList;
}



IfcMechanicalConcreteMaterialProperties *ExpressDataSet::getIfcMechanicalConcreteMaterialProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcMechanicalConcreteMaterialProperties * > (current->second.get());
    }
    else
    {
        IfcMechanicalConcreteMaterialProperties *ret = static_cast< IfcMechanicalConcreteMaterialProperties * > (allocateIfcMechanicalConcreteMaterialProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcMechanicalConcreteMaterialProperties(IfcMechanicalConcreteMaterialProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcMechanicalConcreteMaterialProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMechanicalConcreteMaterialProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcMechanicalConcreteMaterialProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMechanicalConcreteMaterialProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMechanicalConcreteMaterialProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMechanicalConcreteMaterialProperties > ExpressDataSet::createIfcMechanicalConcreteMaterialProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcMechanicalConcreteMaterialProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcMechanicalConcreteMaterialProperties * > (allocateIfcMechanicalConcreteMaterialProperties(this, Step::Id_UNSET));
    }
}

IfcMechanicalConcreteMaterialProperties *ExpressDataSet::cloneIfcMechanicalConcreteMaterialProperties(ExpressDataSet *expressDataSet, const IfcMechanicalConcreteMaterialProperties &obj, const CopyOp &copyop)
{
    IfcMechanicalConcreteMaterialProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMechanicalConcreteMaterialProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMechanicalConcreteMaterialProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMechanicalConcreteMaterialProperties *ExpressDataSet::cloneIfcMechanicalConcreteMaterialProperties(const IfcMechanicalConcreteMaterialProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcMechanicalConcreteMaterialProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcMechanicalConcreteMaterialProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcMechanicalConcreteMaterialProperties  > &ExpressDataSet::getAllIfcMechanicalConcreteMaterialProperties ()
{
    return m_refIfcMechanicalConcreteMaterialPropertiesList;
}



IfcMechanicalFastener *ExpressDataSet::getIfcMechanicalFastener(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcMechanicalFastener * > (current->second.get());
    }
    else
    {
        IfcMechanicalFastener *ret = static_cast< IfcMechanicalFastener * > (allocateIfcMechanicalFastener(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcMechanicalFastener(IfcMechanicalFastener *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcMechanicalFastener_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMechanicalFastener(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcMechanicalFastener *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMechanicalFastener(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMechanicalFastener_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMechanicalFastener > ExpressDataSet::createIfcMechanicalFastener(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcMechanicalFastener(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcMechanicalFastener * > (allocateIfcMechanicalFastener(this, Step::Id_UNSET));
    }
}

IfcMechanicalFastener *ExpressDataSet::cloneIfcMechanicalFastener(ExpressDataSet *expressDataSet, const IfcMechanicalFastener &obj, const CopyOp &copyop)
{
    IfcMechanicalFastener *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMechanicalFastener(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMechanicalFastener_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMechanicalFastener *ExpressDataSet::cloneIfcMechanicalFastener(const IfcMechanicalFastener &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcMechanicalFastener(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcMechanicalFastener(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcMechanicalFastener  > &ExpressDataSet::getAllIfcMechanicalFastener ()
{
    return m_refIfcMechanicalFastenerList;
}



IfcMechanicalFastenerType *ExpressDataSet::getIfcMechanicalFastenerType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcMechanicalFastenerType * > (current->second.get());
    }
    else
    {
        IfcMechanicalFastenerType *ret = static_cast< IfcMechanicalFastenerType * > (allocateIfcMechanicalFastenerType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcMechanicalFastenerType(IfcMechanicalFastenerType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcMechanicalFastenerType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMechanicalFastenerType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcMechanicalFastenerType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMechanicalFastenerType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMechanicalFastenerType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMechanicalFastenerType > ExpressDataSet::createIfcMechanicalFastenerType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcMechanicalFastenerType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcMechanicalFastenerType * > (allocateIfcMechanicalFastenerType(this, Step::Id_UNSET));
    }
}

IfcMechanicalFastenerType *ExpressDataSet::cloneIfcMechanicalFastenerType(ExpressDataSet *expressDataSet, const IfcMechanicalFastenerType &obj, const CopyOp &copyop)
{
    IfcMechanicalFastenerType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMechanicalFastenerType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMechanicalFastenerType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMechanicalFastenerType *ExpressDataSet::cloneIfcMechanicalFastenerType(const IfcMechanicalFastenerType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcMechanicalFastenerType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcMechanicalFastenerType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcMechanicalFastenerType  > &ExpressDataSet::getAllIfcMechanicalFastenerType ()
{
    return m_refIfcMechanicalFastenerTypeList;
}



IfcMechanicalMaterialProperties *ExpressDataSet::getIfcMechanicalMaterialProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcMechanicalMaterialProperties * > (current->second.get());
    }
    else
    {
        IfcMechanicalMaterialProperties *ret = static_cast< IfcMechanicalMaterialProperties * > (allocateIfcMechanicalMaterialProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcMechanicalMaterialProperties(IfcMechanicalMaterialProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcMechanicalMaterialProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMechanicalMaterialProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcMechanicalMaterialProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMechanicalMaterialProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMechanicalMaterialProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMechanicalMaterialProperties > ExpressDataSet::createIfcMechanicalMaterialProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcMechanicalMaterialProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcMechanicalMaterialProperties * > (allocateIfcMechanicalMaterialProperties(this, Step::Id_UNSET));
    }
}

IfcMechanicalMaterialProperties *ExpressDataSet::cloneIfcMechanicalMaterialProperties(ExpressDataSet *expressDataSet, const IfcMechanicalMaterialProperties &obj, const CopyOp &copyop)
{
    IfcMechanicalMaterialProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMechanicalMaterialProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMechanicalMaterialProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMechanicalMaterialProperties *ExpressDataSet::cloneIfcMechanicalMaterialProperties(const IfcMechanicalMaterialProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcMechanicalMaterialProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcMechanicalMaterialProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcMechanicalMaterialProperties  > &ExpressDataSet::getAllIfcMechanicalMaterialProperties ()
{
    return m_refIfcMechanicalMaterialPropertiesList;
}



IfcMechanicalSteelMaterialProperties *ExpressDataSet::getIfcMechanicalSteelMaterialProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcMechanicalSteelMaterialProperties * > (current->second.get());
    }
    else
    {
        IfcMechanicalSteelMaterialProperties *ret = static_cast< IfcMechanicalSteelMaterialProperties * > (allocateIfcMechanicalSteelMaterialProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcMechanicalSteelMaterialProperties(IfcMechanicalSteelMaterialProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcMechanicalSteelMaterialProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMechanicalSteelMaterialProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcMechanicalSteelMaterialProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMechanicalSteelMaterialProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMechanicalSteelMaterialProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMechanicalSteelMaterialProperties > ExpressDataSet::createIfcMechanicalSteelMaterialProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcMechanicalSteelMaterialProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcMechanicalSteelMaterialProperties * > (allocateIfcMechanicalSteelMaterialProperties(this, Step::Id_UNSET));
    }
}

IfcMechanicalSteelMaterialProperties *ExpressDataSet::cloneIfcMechanicalSteelMaterialProperties(ExpressDataSet *expressDataSet, const IfcMechanicalSteelMaterialProperties &obj, const CopyOp &copyop)
{
    IfcMechanicalSteelMaterialProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMechanicalSteelMaterialProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMechanicalSteelMaterialProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMechanicalSteelMaterialProperties *ExpressDataSet::cloneIfcMechanicalSteelMaterialProperties(const IfcMechanicalSteelMaterialProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcMechanicalSteelMaterialProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcMechanicalSteelMaterialProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcMechanicalSteelMaterialProperties  > &ExpressDataSet::getAllIfcMechanicalSteelMaterialProperties ()
{
    return m_refIfcMechanicalSteelMaterialPropertiesList;
}



IfcMember *ExpressDataSet::getIfcMember(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcMember * > (current->second.get());
    }
    else
    {
        IfcMember *ret = static_cast< IfcMember * > (allocateIfcMember(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcMember(IfcMember *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcMember_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMember(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcMember *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMember(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMember_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMember > ExpressDataSet::createIfcMember(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcMember(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcMember * > (allocateIfcMember(this, Step::Id_UNSET));
    }
}

IfcMember *ExpressDataSet::cloneIfcMember(ExpressDataSet *expressDataSet, const IfcMember &obj, const CopyOp &copyop)
{
    IfcMember *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMember(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMember_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMember *ExpressDataSet::cloneIfcMember(const IfcMember &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcMember(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcMember(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcMember  > &ExpressDataSet::getAllIfcMember ()
{
    return m_refIfcMemberList;
}



IfcMemberType *ExpressDataSet::getIfcMemberType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcMemberType * > (current->second.get());
    }
    else
    {
        IfcMemberType *ret = static_cast< IfcMemberType * > (allocateIfcMemberType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcMemberType(IfcMemberType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcMemberType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMemberType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcMemberType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMemberType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMemberType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMemberType > ExpressDataSet::createIfcMemberType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcMemberType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcMemberType * > (allocateIfcMemberType(this, Step::Id_UNSET));
    }
}

IfcMemberType *ExpressDataSet::cloneIfcMemberType(ExpressDataSet *expressDataSet, const IfcMemberType &obj, const CopyOp &copyop)
{
    IfcMemberType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMemberType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMemberType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMemberType *ExpressDataSet::cloneIfcMemberType(const IfcMemberType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcMemberType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcMemberType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcMemberType  > &ExpressDataSet::getAllIfcMemberType ()
{
    return m_refIfcMemberTypeList;
}



IfcMetric *ExpressDataSet::getIfcMetric(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcMetric * > (current->second.get());
    }
    else
    {
        IfcMetric *ret = static_cast< IfcMetric * > (allocateIfcMetric(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcMetric(IfcMetric *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcMetric_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMetric(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcMetric *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMetric(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMetric_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMetric > ExpressDataSet::createIfcMetric(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcMetric(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcMetric * > (allocateIfcMetric(this, Step::Id_UNSET));
    }
}

IfcMetric *ExpressDataSet::cloneIfcMetric(ExpressDataSet *expressDataSet, const IfcMetric &obj, const CopyOp &copyop)
{
    IfcMetric *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMetric(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMetric_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMetric *ExpressDataSet::cloneIfcMetric(const IfcMetric &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcMetric(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcMetric(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcMetric  > &ExpressDataSet::getAllIfcMetric ()
{
    return m_refIfcMetricList;
}



IfcMonetaryUnit *ExpressDataSet::getIfcMonetaryUnit(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcMonetaryUnit * > (current->second.get());
    }
    else
    {
        IfcMonetaryUnit *ret = static_cast< IfcMonetaryUnit * > (allocateIfcMonetaryUnit(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcMonetaryUnit(IfcMonetaryUnit *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcMonetaryUnit_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMonetaryUnit(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcMonetaryUnit *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMonetaryUnit(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMonetaryUnit_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMonetaryUnit > ExpressDataSet::createIfcMonetaryUnit(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcMonetaryUnit(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcMonetaryUnit * > (allocateIfcMonetaryUnit(this, Step::Id_UNSET));
    }
}

IfcMonetaryUnit *ExpressDataSet::cloneIfcMonetaryUnit(ExpressDataSet *expressDataSet, const IfcMonetaryUnit &obj, const CopyOp &copyop)
{
    IfcMonetaryUnit *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMonetaryUnit(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMonetaryUnit_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMonetaryUnit *ExpressDataSet::cloneIfcMonetaryUnit(const IfcMonetaryUnit &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcMonetaryUnit(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcMonetaryUnit(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcMonetaryUnit  > &ExpressDataSet::getAllIfcMonetaryUnit ()
{
    return m_refIfcMonetaryUnitList;
}



IfcMotorConnectionType *ExpressDataSet::getIfcMotorConnectionType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcMotorConnectionType * > (current->second.get());
    }
    else
    {
        IfcMotorConnectionType *ret = static_cast< IfcMotorConnectionType * > (allocateIfcMotorConnectionType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcMotorConnectionType(IfcMotorConnectionType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcMotorConnectionType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMotorConnectionType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcMotorConnectionType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMotorConnectionType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMotorConnectionType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMotorConnectionType > ExpressDataSet::createIfcMotorConnectionType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcMotorConnectionType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcMotorConnectionType * > (allocateIfcMotorConnectionType(this, Step::Id_UNSET));
    }
}

IfcMotorConnectionType *ExpressDataSet::cloneIfcMotorConnectionType(ExpressDataSet *expressDataSet, const IfcMotorConnectionType &obj, const CopyOp &copyop)
{
    IfcMotorConnectionType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMotorConnectionType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMotorConnectionType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMotorConnectionType *ExpressDataSet::cloneIfcMotorConnectionType(const IfcMotorConnectionType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcMotorConnectionType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcMotorConnectionType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcMotorConnectionType  > &ExpressDataSet::getAllIfcMotorConnectionType ()
{
    return m_refIfcMotorConnectionTypeList;
}



IfcMove *ExpressDataSet::getIfcMove(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcMove * > (current->second.get());
    }
    else
    {
        IfcMove *ret = static_cast< IfcMove * > (allocateIfcMove(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcMove(IfcMove *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcMove_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMove(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcMove *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMove(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMove_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMove > ExpressDataSet::createIfcMove(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcMove(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcMove * > (allocateIfcMove(this, Step::Id_UNSET));
    }
}

IfcMove *ExpressDataSet::cloneIfcMove(ExpressDataSet *expressDataSet, const IfcMove &obj, const CopyOp &copyop)
{
    IfcMove *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMove(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMove_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMove *ExpressDataSet::cloneIfcMove(const IfcMove &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcMove(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcMove(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcMove  > &ExpressDataSet::getAllIfcMove ()
{
    return m_refIfcMoveList;
}



IfcNamedUnit *ExpressDataSet::getIfcNamedUnit(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcNamedUnit * > (current->second.get());
    }
    else
    {
        IfcNamedUnit *ret = static_cast< IfcNamedUnit * > (allocateIfcNamedUnit(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcNamedUnit(IfcNamedUnit *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcNamedUnit_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcNamedUnit(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcNamedUnit *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcNamedUnit(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcNamedUnit_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcNamedUnit > ExpressDataSet::createIfcNamedUnit(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcNamedUnit(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcNamedUnit * > (allocateIfcNamedUnit(this, Step::Id_UNSET));
    }
}

IfcNamedUnit *ExpressDataSet::cloneIfcNamedUnit(ExpressDataSet *expressDataSet, const IfcNamedUnit &obj, const CopyOp &copyop)
{
    IfcNamedUnit *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcNamedUnit(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcNamedUnit_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcNamedUnit *ExpressDataSet::cloneIfcNamedUnit(const IfcNamedUnit &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcNamedUnit(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcNamedUnit(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcNamedUnit  > &ExpressDataSet::getAllIfcNamedUnit ()
{
    return m_refIfcNamedUnitList;
}



IfcObject *ExpressDataSet::getIfcObject(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcObject * > (current->second.get());
    }
    else
    {
        IfcObject *ret = static_cast< IfcObject * > (allocateIfcObject(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcObject(IfcObject *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcObject_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcObject(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcObject *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcObject(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcObject_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcObject > ExpressDataSet::createIfcObject(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcObject(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcObject * > (allocateIfcObject(this, Step::Id_UNSET));
    }
}

IfcObject *ExpressDataSet::cloneIfcObject(ExpressDataSet *expressDataSet, const IfcObject &obj, const CopyOp &copyop)
{
    IfcObject *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcObject(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcObject_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcObject *ExpressDataSet::cloneIfcObject(const IfcObject &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcObject(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcObject(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcObject  > &ExpressDataSet::getAllIfcObject ()
{
    return m_refIfcObjectList;
}



IfcObjectDefinition *ExpressDataSet::getIfcObjectDefinition(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcObjectDefinition * > (current->second.get());
    }
    else
    {
        IfcObjectDefinition *ret = static_cast< IfcObjectDefinition * > (allocateIfcObjectDefinition(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcObjectDefinition(IfcObjectDefinition *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcObjectDefinition_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcObjectDefinition(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcObjectDefinition *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcObjectDefinition(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcObjectDefinition_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcObjectDefinition > ExpressDataSet::createIfcObjectDefinition(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcObjectDefinition(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcObjectDefinition * > (allocateIfcObjectDefinition(this, Step::Id_UNSET));
    }
}

IfcObjectDefinition *ExpressDataSet::cloneIfcObjectDefinition(ExpressDataSet *expressDataSet, const IfcObjectDefinition &obj, const CopyOp &copyop)
{
    IfcObjectDefinition *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcObjectDefinition(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcObjectDefinition_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcObjectDefinition *ExpressDataSet::cloneIfcObjectDefinition(const IfcObjectDefinition &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcObjectDefinition(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcObjectDefinition(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcObjectDefinition  > &ExpressDataSet::getAllIfcObjectDefinition ()
{
    return m_refIfcObjectDefinitionList;
}



IfcObjective *ExpressDataSet::getIfcObjective(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcObjective * > (current->second.get());
    }
    else
    {
        IfcObjective *ret = static_cast< IfcObjective * > (allocateIfcObjective(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcObjective(IfcObjective *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcObjective_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcObjective(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcObjective *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcObjective(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcObjective_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcObjective > ExpressDataSet::createIfcObjective(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcObjective(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcObjective * > (allocateIfcObjective(this, Step::Id_UNSET));
    }
}

IfcObjective *ExpressDataSet::cloneIfcObjective(ExpressDataSet *expressDataSet, const IfcObjective &obj, const CopyOp &copyop)
{
    IfcObjective *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcObjective(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcObjective_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcObjective *ExpressDataSet::cloneIfcObjective(const IfcObjective &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcObjective(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcObjective(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcObjective  > &ExpressDataSet::getAllIfcObjective ()
{
    return m_refIfcObjectiveList;
}



IfcObjectPlacement *ExpressDataSet::getIfcObjectPlacement(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcObjectPlacement * > (current->second.get());
    }
    else
    {
        IfcObjectPlacement *ret = static_cast< IfcObjectPlacement * > (allocateIfcObjectPlacement(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcObjectPlacement(IfcObjectPlacement *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcObjectPlacement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcObjectPlacement(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcObjectPlacement *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcObjectPlacement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcObjectPlacement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcObjectPlacement > ExpressDataSet::createIfcObjectPlacement(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcObjectPlacement(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcObjectPlacement * > (allocateIfcObjectPlacement(this, Step::Id_UNSET));
    }
}

IfcObjectPlacement *ExpressDataSet::cloneIfcObjectPlacement(ExpressDataSet *expressDataSet, const IfcObjectPlacement &obj, const CopyOp &copyop)
{
    IfcObjectPlacement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcObjectPlacement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcObjectPlacement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcObjectPlacement *ExpressDataSet::cloneIfcObjectPlacement(const IfcObjectPlacement &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcObjectPlacement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcObjectPlacement(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcObjectPlacement  > &ExpressDataSet::getAllIfcObjectPlacement ()
{
    return m_refIfcObjectPlacementList;
}



IfcOccupant *ExpressDataSet::getIfcOccupant(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcOccupant * > (current->second.get());
    }
    else
    {
        IfcOccupant *ret = static_cast< IfcOccupant * > (allocateIfcOccupant(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcOccupant(IfcOccupant *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcOccupant_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcOccupant(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcOccupant *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcOccupant(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcOccupant_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcOccupant > ExpressDataSet::createIfcOccupant(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcOccupant(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcOccupant * > (allocateIfcOccupant(this, Step::Id_UNSET));
    }
}

IfcOccupant *ExpressDataSet::cloneIfcOccupant(ExpressDataSet *expressDataSet, const IfcOccupant &obj, const CopyOp &copyop)
{
    IfcOccupant *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcOccupant(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcOccupant_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcOccupant *ExpressDataSet::cloneIfcOccupant(const IfcOccupant &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcOccupant(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcOccupant(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcOccupant  > &ExpressDataSet::getAllIfcOccupant ()
{
    return m_refIfcOccupantList;
}



IfcOffsetCurve2D *ExpressDataSet::getIfcOffsetCurve2D(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcOffsetCurve2D * > (current->second.get());
    }
    else
    {
        IfcOffsetCurve2D *ret = static_cast< IfcOffsetCurve2D * > (allocateIfcOffsetCurve2D(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcOffsetCurve2D(IfcOffsetCurve2D *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcOffsetCurve2D_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcOffsetCurve2D(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcOffsetCurve2D *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcOffsetCurve2D(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcOffsetCurve2D_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcOffsetCurve2D > ExpressDataSet::createIfcOffsetCurve2D(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcOffsetCurve2D(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcOffsetCurve2D * > (allocateIfcOffsetCurve2D(this, Step::Id_UNSET));
    }
}

IfcOffsetCurve2D *ExpressDataSet::cloneIfcOffsetCurve2D(ExpressDataSet *expressDataSet, const IfcOffsetCurve2D &obj, const CopyOp &copyop)
{
    IfcOffsetCurve2D *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcOffsetCurve2D(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcOffsetCurve2D_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcOffsetCurve2D *ExpressDataSet::cloneIfcOffsetCurve2D(const IfcOffsetCurve2D &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcOffsetCurve2D(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcOffsetCurve2D(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcOffsetCurve2D  > &ExpressDataSet::getAllIfcOffsetCurve2D ()
{
    return m_refIfcOffsetCurve2DList;
}



IfcOffsetCurve3D *ExpressDataSet::getIfcOffsetCurve3D(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcOffsetCurve3D * > (current->second.get());
    }
    else
    {
        IfcOffsetCurve3D *ret = static_cast< IfcOffsetCurve3D * > (allocateIfcOffsetCurve3D(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcOffsetCurve3D(IfcOffsetCurve3D *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcOffsetCurve3D_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcOffsetCurve3D(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcOffsetCurve3D *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcOffsetCurve3D(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcOffsetCurve3D_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcOffsetCurve3D > ExpressDataSet::createIfcOffsetCurve3D(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcOffsetCurve3D(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcOffsetCurve3D * > (allocateIfcOffsetCurve3D(this, Step::Id_UNSET));
    }
}

IfcOffsetCurve3D *ExpressDataSet::cloneIfcOffsetCurve3D(ExpressDataSet *expressDataSet, const IfcOffsetCurve3D &obj, const CopyOp &copyop)
{
    IfcOffsetCurve3D *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcOffsetCurve3D(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcOffsetCurve3D_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcOffsetCurve3D *ExpressDataSet::cloneIfcOffsetCurve3D(const IfcOffsetCurve3D &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcOffsetCurve3D(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcOffsetCurve3D(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcOffsetCurve3D  > &ExpressDataSet::getAllIfcOffsetCurve3D ()
{
    return m_refIfcOffsetCurve3DList;
}



IfcOneDirectionRepeatFactor *ExpressDataSet::getIfcOneDirectionRepeatFactor(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcOneDirectionRepeatFactor * > (current->second.get());
    }
    else
    {
        IfcOneDirectionRepeatFactor *ret = static_cast< IfcOneDirectionRepeatFactor * > (allocateIfcOneDirectionRepeatFactor(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcOneDirectionRepeatFactor(IfcOneDirectionRepeatFactor *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcOneDirectionRepeatFactor_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcOneDirectionRepeatFactor(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcOneDirectionRepeatFactor *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcOneDirectionRepeatFactor(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcOneDirectionRepeatFactor_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcOneDirectionRepeatFactor > ExpressDataSet::createIfcOneDirectionRepeatFactor(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcOneDirectionRepeatFactor(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcOneDirectionRepeatFactor * > (allocateIfcOneDirectionRepeatFactor(this, Step::Id_UNSET));
    }
}

IfcOneDirectionRepeatFactor *ExpressDataSet::cloneIfcOneDirectionRepeatFactor(ExpressDataSet *expressDataSet, const IfcOneDirectionRepeatFactor &obj, const CopyOp &copyop)
{
    IfcOneDirectionRepeatFactor *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcOneDirectionRepeatFactor(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcOneDirectionRepeatFactor_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcOneDirectionRepeatFactor *ExpressDataSet::cloneIfcOneDirectionRepeatFactor(const IfcOneDirectionRepeatFactor &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcOneDirectionRepeatFactor(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcOneDirectionRepeatFactor(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcOneDirectionRepeatFactor  > &ExpressDataSet::getAllIfcOneDirectionRepeatFactor ()
{
    return m_refIfcOneDirectionRepeatFactorList;
}



IfcOpeningElement *ExpressDataSet::getIfcOpeningElement(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcOpeningElement * > (current->second.get());
    }
    else
    {
        IfcOpeningElement *ret = static_cast< IfcOpeningElement * > (allocateIfcOpeningElement(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcOpeningElement(IfcOpeningElement *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcOpeningElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcOpeningElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcOpeningElement *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcOpeningElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcOpeningElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcOpeningElement > ExpressDataSet::createIfcOpeningElement(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcOpeningElement(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcOpeningElement * > (allocateIfcOpeningElement(this, Step::Id_UNSET));
    }
}

IfcOpeningElement *ExpressDataSet::cloneIfcOpeningElement(ExpressDataSet *expressDataSet, const IfcOpeningElement &obj, const CopyOp &copyop)
{
    IfcOpeningElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcOpeningElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcOpeningElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcOpeningElement *ExpressDataSet::cloneIfcOpeningElement(const IfcOpeningElement &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcOpeningElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcOpeningElement(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcOpeningElement  > &ExpressDataSet::getAllIfcOpeningElement ()
{
    return m_refIfcOpeningElementList;
}



IfcOpenShell *ExpressDataSet::getIfcOpenShell(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcOpenShell * > (current->second.get());
    }
    else
    {
        IfcOpenShell *ret = static_cast< IfcOpenShell * > (allocateIfcOpenShell(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcOpenShell(IfcOpenShell *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcOpenShell_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcOpenShell(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcOpenShell *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcOpenShell(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcOpenShell_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcOpenShell > ExpressDataSet::createIfcOpenShell(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcOpenShell(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcOpenShell * > (allocateIfcOpenShell(this, Step::Id_UNSET));
    }
}

IfcOpenShell *ExpressDataSet::cloneIfcOpenShell(ExpressDataSet *expressDataSet, const IfcOpenShell &obj, const CopyOp &copyop)
{
    IfcOpenShell *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcOpenShell(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcOpenShell_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcOpenShell *ExpressDataSet::cloneIfcOpenShell(const IfcOpenShell &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcOpenShell(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcOpenShell(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcOpenShell  > &ExpressDataSet::getAllIfcOpenShell ()
{
    return m_refIfcOpenShellList;
}



IfcOpticalMaterialProperties *ExpressDataSet::getIfcOpticalMaterialProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcOpticalMaterialProperties * > (current->second.get());
    }
    else
    {
        IfcOpticalMaterialProperties *ret = static_cast< IfcOpticalMaterialProperties * > (allocateIfcOpticalMaterialProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcOpticalMaterialProperties(IfcOpticalMaterialProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcOpticalMaterialProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcOpticalMaterialProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcOpticalMaterialProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcOpticalMaterialProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcOpticalMaterialProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcOpticalMaterialProperties > ExpressDataSet::createIfcOpticalMaterialProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcOpticalMaterialProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcOpticalMaterialProperties * > (allocateIfcOpticalMaterialProperties(this, Step::Id_UNSET));
    }
}

IfcOpticalMaterialProperties *ExpressDataSet::cloneIfcOpticalMaterialProperties(ExpressDataSet *expressDataSet, const IfcOpticalMaterialProperties &obj, const CopyOp &copyop)
{
    IfcOpticalMaterialProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcOpticalMaterialProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcOpticalMaterialProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcOpticalMaterialProperties *ExpressDataSet::cloneIfcOpticalMaterialProperties(const IfcOpticalMaterialProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcOpticalMaterialProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcOpticalMaterialProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcOpticalMaterialProperties  > &ExpressDataSet::getAllIfcOpticalMaterialProperties ()
{
    return m_refIfcOpticalMaterialPropertiesList;
}



IfcOrderAction *ExpressDataSet::getIfcOrderAction(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcOrderAction * > (current->second.get());
    }
    else
    {
        IfcOrderAction *ret = static_cast< IfcOrderAction * > (allocateIfcOrderAction(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcOrderAction(IfcOrderAction *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcOrderAction_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcOrderAction(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcOrderAction *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcOrderAction(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcOrderAction_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcOrderAction > ExpressDataSet::createIfcOrderAction(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcOrderAction(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcOrderAction * > (allocateIfcOrderAction(this, Step::Id_UNSET));
    }
}

IfcOrderAction *ExpressDataSet::cloneIfcOrderAction(ExpressDataSet *expressDataSet, const IfcOrderAction &obj, const CopyOp &copyop)
{
    IfcOrderAction *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcOrderAction(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcOrderAction_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcOrderAction *ExpressDataSet::cloneIfcOrderAction(const IfcOrderAction &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcOrderAction(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcOrderAction(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcOrderAction  > &ExpressDataSet::getAllIfcOrderAction ()
{
    return m_refIfcOrderActionList;
}



IfcOrganization *ExpressDataSet::getIfcOrganization(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcOrganization * > (current->second.get());
    }
    else
    {
        IfcOrganization *ret = static_cast< IfcOrganization * > (allocateIfcOrganization(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcOrganization(IfcOrganization *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcOrganization_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcOrganization(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcOrganization *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcOrganization(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcOrganization_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcOrganization > ExpressDataSet::createIfcOrganization(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcOrganization(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcOrganization * > (allocateIfcOrganization(this, Step::Id_UNSET));
    }
}

IfcOrganization *ExpressDataSet::cloneIfcOrganization(ExpressDataSet *expressDataSet, const IfcOrganization &obj, const CopyOp &copyop)
{
    IfcOrganization *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcOrganization(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcOrganization_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcOrganization *ExpressDataSet::cloneIfcOrganization(const IfcOrganization &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcOrganization(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcOrganization(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcOrganization  > &ExpressDataSet::getAllIfcOrganization ()
{
    return m_refIfcOrganizationList;
}



IfcOrganizationRelationship *ExpressDataSet::getIfcOrganizationRelationship(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcOrganizationRelationship * > (current->second.get());
    }
    else
    {
        IfcOrganizationRelationship *ret = static_cast< IfcOrganizationRelationship * > (allocateIfcOrganizationRelationship(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcOrganizationRelationship(IfcOrganizationRelationship *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcOrganizationRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcOrganizationRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcOrganizationRelationship *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcOrganizationRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcOrganizationRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcOrganizationRelationship > ExpressDataSet::createIfcOrganizationRelationship(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcOrganizationRelationship(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcOrganizationRelationship * > (allocateIfcOrganizationRelationship(this, Step::Id_UNSET));
    }
}

IfcOrganizationRelationship *ExpressDataSet::cloneIfcOrganizationRelationship(ExpressDataSet *expressDataSet, const IfcOrganizationRelationship &obj, const CopyOp &copyop)
{
    IfcOrganizationRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcOrganizationRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcOrganizationRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcOrganizationRelationship *ExpressDataSet::cloneIfcOrganizationRelationship(const IfcOrganizationRelationship &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcOrganizationRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcOrganizationRelationship(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcOrganizationRelationship  > &ExpressDataSet::getAllIfcOrganizationRelationship ()
{
    return m_refIfcOrganizationRelationshipList;
}



IfcOrientedEdge *ExpressDataSet::getIfcOrientedEdge(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcOrientedEdge * > (current->second.get());
    }
    else
    {
        IfcOrientedEdge *ret = static_cast< IfcOrientedEdge * > (allocateIfcOrientedEdge(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcOrientedEdge(IfcOrientedEdge *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcOrientedEdge_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcOrientedEdge(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcOrientedEdge *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcOrientedEdge(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcOrientedEdge_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcOrientedEdge > ExpressDataSet::createIfcOrientedEdge(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcOrientedEdge(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcOrientedEdge * > (allocateIfcOrientedEdge(this, Step::Id_UNSET));
    }
}

IfcOrientedEdge *ExpressDataSet::cloneIfcOrientedEdge(ExpressDataSet *expressDataSet, const IfcOrientedEdge &obj, const CopyOp &copyop)
{
    IfcOrientedEdge *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcOrientedEdge(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcOrientedEdge_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcOrientedEdge *ExpressDataSet::cloneIfcOrientedEdge(const IfcOrientedEdge &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcOrientedEdge(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcOrientedEdge(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcOrientedEdge  > &ExpressDataSet::getAllIfcOrientedEdge ()
{
    return m_refIfcOrientedEdgeList;
}



IfcOutletType *ExpressDataSet::getIfcOutletType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcOutletType * > (current->second.get());
    }
    else
    {
        IfcOutletType *ret = static_cast< IfcOutletType * > (allocateIfcOutletType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcOutletType(IfcOutletType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcOutletType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcOutletType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcOutletType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcOutletType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcOutletType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcOutletType > ExpressDataSet::createIfcOutletType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcOutletType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcOutletType * > (allocateIfcOutletType(this, Step::Id_UNSET));
    }
}

IfcOutletType *ExpressDataSet::cloneIfcOutletType(ExpressDataSet *expressDataSet, const IfcOutletType &obj, const CopyOp &copyop)
{
    IfcOutletType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcOutletType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcOutletType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcOutletType *ExpressDataSet::cloneIfcOutletType(const IfcOutletType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcOutletType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcOutletType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcOutletType  > &ExpressDataSet::getAllIfcOutletType ()
{
    return m_refIfcOutletTypeList;
}



IfcOwnerHistory *ExpressDataSet::getIfcOwnerHistory(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcOwnerHistory * > (current->second.get());
    }
    else
    {
        IfcOwnerHistory *ret = static_cast< IfcOwnerHistory * > (allocateIfcOwnerHistory(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcOwnerHistory(IfcOwnerHistory *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcOwnerHistory_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcOwnerHistory(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcOwnerHistory *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcOwnerHistory(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcOwnerHistory_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcOwnerHistory > ExpressDataSet::createIfcOwnerHistory(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcOwnerHistory(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcOwnerHistory * > (allocateIfcOwnerHistory(this, Step::Id_UNSET));
    }
}

IfcOwnerHistory *ExpressDataSet::cloneIfcOwnerHistory(ExpressDataSet *expressDataSet, const IfcOwnerHistory &obj, const CopyOp &copyop)
{
    IfcOwnerHistory *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcOwnerHistory(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcOwnerHistory_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcOwnerHistory *ExpressDataSet::cloneIfcOwnerHistory(const IfcOwnerHistory &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcOwnerHistory(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcOwnerHistory(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcOwnerHistory  > &ExpressDataSet::getAllIfcOwnerHistory ()
{
    return m_refIfcOwnerHistoryList;
}



IfcParameterizedProfileDef *ExpressDataSet::getIfcParameterizedProfileDef(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcParameterizedProfileDef * > (current->second.get());
    }
    else
    {
        IfcParameterizedProfileDef *ret = static_cast< IfcParameterizedProfileDef * > (allocateIfcParameterizedProfileDef(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcParameterizedProfileDef(IfcParameterizedProfileDef *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcParameterizedProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcParameterizedProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcParameterizedProfileDef *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcParameterizedProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcParameterizedProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcParameterizedProfileDef > ExpressDataSet::createIfcParameterizedProfileDef(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcParameterizedProfileDef(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcParameterizedProfileDef * > (allocateIfcParameterizedProfileDef(this, Step::Id_UNSET));
    }
}

IfcParameterizedProfileDef *ExpressDataSet::cloneIfcParameterizedProfileDef(ExpressDataSet *expressDataSet, const IfcParameterizedProfileDef &obj, const CopyOp &copyop)
{
    IfcParameterizedProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcParameterizedProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcParameterizedProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcParameterizedProfileDef *ExpressDataSet::cloneIfcParameterizedProfileDef(const IfcParameterizedProfileDef &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcParameterizedProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcParameterizedProfileDef(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcParameterizedProfileDef  > &ExpressDataSet::getAllIfcParameterizedProfileDef ()
{
    return m_refIfcParameterizedProfileDefList;
}



IfcPath *ExpressDataSet::getIfcPath(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPath * > (current->second.get());
    }
    else
    {
        IfcPath *ret = static_cast< IfcPath * > (allocateIfcPath(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPath(IfcPath *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPath_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPath(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPath *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPath(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPath_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPath > ExpressDataSet::createIfcPath(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPath(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPath * > (allocateIfcPath(this, Step::Id_UNSET));
    }
}

IfcPath *ExpressDataSet::cloneIfcPath(ExpressDataSet *expressDataSet, const IfcPath &obj, const CopyOp &copyop)
{
    IfcPath *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPath(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPath_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPath *ExpressDataSet::cloneIfcPath(const IfcPath &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPath(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPath(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPath  > &ExpressDataSet::getAllIfcPath ()
{
    return m_refIfcPathList;
}



IfcPerformanceHistory *ExpressDataSet::getIfcPerformanceHistory(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPerformanceHistory * > (current->second.get());
    }
    else
    {
        IfcPerformanceHistory *ret = static_cast< IfcPerformanceHistory * > (allocateIfcPerformanceHistory(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPerformanceHistory(IfcPerformanceHistory *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPerformanceHistory_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPerformanceHistory(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPerformanceHistory *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPerformanceHistory(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPerformanceHistory_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPerformanceHistory > ExpressDataSet::createIfcPerformanceHistory(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPerformanceHistory(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPerformanceHistory * > (allocateIfcPerformanceHistory(this, Step::Id_UNSET));
    }
}

IfcPerformanceHistory *ExpressDataSet::cloneIfcPerformanceHistory(ExpressDataSet *expressDataSet, const IfcPerformanceHistory &obj, const CopyOp &copyop)
{
    IfcPerformanceHistory *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPerformanceHistory(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPerformanceHistory_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPerformanceHistory *ExpressDataSet::cloneIfcPerformanceHistory(const IfcPerformanceHistory &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPerformanceHistory(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPerformanceHistory(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPerformanceHistory  > &ExpressDataSet::getAllIfcPerformanceHistory ()
{
    return m_refIfcPerformanceHistoryList;
}



IfcPermeableCoveringProperties *ExpressDataSet::getIfcPermeableCoveringProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPermeableCoveringProperties * > (current->second.get());
    }
    else
    {
        IfcPermeableCoveringProperties *ret = static_cast< IfcPermeableCoveringProperties * > (allocateIfcPermeableCoveringProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPermeableCoveringProperties(IfcPermeableCoveringProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPermeableCoveringProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPermeableCoveringProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPermeableCoveringProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPermeableCoveringProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPermeableCoveringProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPermeableCoveringProperties > ExpressDataSet::createIfcPermeableCoveringProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPermeableCoveringProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPermeableCoveringProperties * > (allocateIfcPermeableCoveringProperties(this, Step::Id_UNSET));
    }
}

IfcPermeableCoveringProperties *ExpressDataSet::cloneIfcPermeableCoveringProperties(ExpressDataSet *expressDataSet, const IfcPermeableCoveringProperties &obj, const CopyOp &copyop)
{
    IfcPermeableCoveringProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPermeableCoveringProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPermeableCoveringProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPermeableCoveringProperties *ExpressDataSet::cloneIfcPermeableCoveringProperties(const IfcPermeableCoveringProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPermeableCoveringProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPermeableCoveringProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPermeableCoveringProperties  > &ExpressDataSet::getAllIfcPermeableCoveringProperties ()
{
    return m_refIfcPermeableCoveringPropertiesList;
}



IfcPermit *ExpressDataSet::getIfcPermit(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPermit * > (current->second.get());
    }
    else
    {
        IfcPermit *ret = static_cast< IfcPermit * > (allocateIfcPermit(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPermit(IfcPermit *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPermit_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPermit(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPermit *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPermit(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPermit_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPermit > ExpressDataSet::createIfcPermit(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPermit(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPermit * > (allocateIfcPermit(this, Step::Id_UNSET));
    }
}

IfcPermit *ExpressDataSet::cloneIfcPermit(ExpressDataSet *expressDataSet, const IfcPermit &obj, const CopyOp &copyop)
{
    IfcPermit *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPermit(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPermit_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPermit *ExpressDataSet::cloneIfcPermit(const IfcPermit &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPermit(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPermit(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPermit  > &ExpressDataSet::getAllIfcPermit ()
{
    return m_refIfcPermitList;
}



IfcPerson *ExpressDataSet::getIfcPerson(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPerson * > (current->second.get());
    }
    else
    {
        IfcPerson *ret = static_cast< IfcPerson * > (allocateIfcPerson(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPerson(IfcPerson *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPerson_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPerson(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPerson *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPerson(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPerson_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPerson > ExpressDataSet::createIfcPerson(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPerson(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPerson * > (allocateIfcPerson(this, Step::Id_UNSET));
    }
}

IfcPerson *ExpressDataSet::cloneIfcPerson(ExpressDataSet *expressDataSet, const IfcPerson &obj, const CopyOp &copyop)
{
    IfcPerson *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPerson(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPerson_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPerson *ExpressDataSet::cloneIfcPerson(const IfcPerson &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPerson(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPerson(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPerson  > &ExpressDataSet::getAllIfcPerson ()
{
    return m_refIfcPersonList;
}



IfcPersonAndOrganization *ExpressDataSet::getIfcPersonAndOrganization(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPersonAndOrganization * > (current->second.get());
    }
    else
    {
        IfcPersonAndOrganization *ret = static_cast< IfcPersonAndOrganization * > (allocateIfcPersonAndOrganization(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPersonAndOrganization(IfcPersonAndOrganization *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPersonAndOrganization_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPersonAndOrganization(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPersonAndOrganization *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPersonAndOrganization(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPersonAndOrganization_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPersonAndOrganization > ExpressDataSet::createIfcPersonAndOrganization(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPersonAndOrganization(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPersonAndOrganization * > (allocateIfcPersonAndOrganization(this, Step::Id_UNSET));
    }
}

IfcPersonAndOrganization *ExpressDataSet::cloneIfcPersonAndOrganization(ExpressDataSet *expressDataSet, const IfcPersonAndOrganization &obj, const CopyOp &copyop)
{
    IfcPersonAndOrganization *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPersonAndOrganization(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPersonAndOrganization_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPersonAndOrganization *ExpressDataSet::cloneIfcPersonAndOrganization(const IfcPersonAndOrganization &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPersonAndOrganization(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPersonAndOrganization(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPersonAndOrganization  > &ExpressDataSet::getAllIfcPersonAndOrganization ()
{
    return m_refIfcPersonAndOrganizationList;
}



IfcPhysicalComplexQuantity *ExpressDataSet::getIfcPhysicalComplexQuantity(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPhysicalComplexQuantity * > (current->second.get());
    }
    else
    {
        IfcPhysicalComplexQuantity *ret = static_cast< IfcPhysicalComplexQuantity * > (allocateIfcPhysicalComplexQuantity(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPhysicalComplexQuantity(IfcPhysicalComplexQuantity *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPhysicalComplexQuantity_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPhysicalComplexQuantity(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPhysicalComplexQuantity *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPhysicalComplexQuantity(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPhysicalComplexQuantity_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPhysicalComplexQuantity > ExpressDataSet::createIfcPhysicalComplexQuantity(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPhysicalComplexQuantity(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPhysicalComplexQuantity * > (allocateIfcPhysicalComplexQuantity(this, Step::Id_UNSET));
    }
}

IfcPhysicalComplexQuantity *ExpressDataSet::cloneIfcPhysicalComplexQuantity(ExpressDataSet *expressDataSet, const IfcPhysicalComplexQuantity &obj, const CopyOp &copyop)
{
    IfcPhysicalComplexQuantity *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPhysicalComplexQuantity(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPhysicalComplexQuantity_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPhysicalComplexQuantity *ExpressDataSet::cloneIfcPhysicalComplexQuantity(const IfcPhysicalComplexQuantity &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPhysicalComplexQuantity(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPhysicalComplexQuantity(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPhysicalComplexQuantity  > &ExpressDataSet::getAllIfcPhysicalComplexQuantity ()
{
    return m_refIfcPhysicalComplexQuantityList;
}



IfcPhysicalQuantity *ExpressDataSet::getIfcPhysicalQuantity(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPhysicalQuantity * > (current->second.get());
    }
    else
    {
        IfcPhysicalQuantity *ret = static_cast< IfcPhysicalQuantity * > (allocateIfcPhysicalQuantity(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPhysicalQuantity(IfcPhysicalQuantity *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPhysicalQuantity_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPhysicalQuantity(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPhysicalQuantity *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPhysicalQuantity(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPhysicalQuantity_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPhysicalQuantity > ExpressDataSet::createIfcPhysicalQuantity(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPhysicalQuantity(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPhysicalQuantity * > (allocateIfcPhysicalQuantity(this, Step::Id_UNSET));
    }
}

IfcPhysicalQuantity *ExpressDataSet::cloneIfcPhysicalQuantity(ExpressDataSet *expressDataSet, const IfcPhysicalQuantity &obj, const CopyOp &copyop)
{
    IfcPhysicalQuantity *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPhysicalQuantity(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPhysicalQuantity_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPhysicalQuantity *ExpressDataSet::cloneIfcPhysicalQuantity(const IfcPhysicalQuantity &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPhysicalQuantity(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPhysicalQuantity(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPhysicalQuantity  > &ExpressDataSet::getAllIfcPhysicalQuantity ()
{
    return m_refIfcPhysicalQuantityList;
}



IfcPhysicalSimpleQuantity *ExpressDataSet::getIfcPhysicalSimpleQuantity(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPhysicalSimpleQuantity * > (current->second.get());
    }
    else
    {
        IfcPhysicalSimpleQuantity *ret = static_cast< IfcPhysicalSimpleQuantity * > (allocateIfcPhysicalSimpleQuantity(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPhysicalSimpleQuantity(IfcPhysicalSimpleQuantity *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPhysicalSimpleQuantity_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPhysicalSimpleQuantity(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPhysicalSimpleQuantity *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPhysicalSimpleQuantity(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPhysicalSimpleQuantity_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPhysicalSimpleQuantity > ExpressDataSet::createIfcPhysicalSimpleQuantity(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPhysicalSimpleQuantity(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPhysicalSimpleQuantity * > (allocateIfcPhysicalSimpleQuantity(this, Step::Id_UNSET));
    }
}

IfcPhysicalSimpleQuantity *ExpressDataSet::cloneIfcPhysicalSimpleQuantity(ExpressDataSet *expressDataSet, const IfcPhysicalSimpleQuantity &obj, const CopyOp &copyop)
{
    IfcPhysicalSimpleQuantity *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPhysicalSimpleQuantity(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPhysicalSimpleQuantity_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPhysicalSimpleQuantity *ExpressDataSet::cloneIfcPhysicalSimpleQuantity(const IfcPhysicalSimpleQuantity &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPhysicalSimpleQuantity(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPhysicalSimpleQuantity(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPhysicalSimpleQuantity  > &ExpressDataSet::getAllIfcPhysicalSimpleQuantity ()
{
    return m_refIfcPhysicalSimpleQuantityList;
}



IfcPile *ExpressDataSet::getIfcPile(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPile * > (current->second.get());
    }
    else
    {
        IfcPile *ret = static_cast< IfcPile * > (allocateIfcPile(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPile(IfcPile *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPile_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPile(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPile *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPile(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPile_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPile > ExpressDataSet::createIfcPile(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPile(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPile * > (allocateIfcPile(this, Step::Id_UNSET));
    }
}

IfcPile *ExpressDataSet::cloneIfcPile(ExpressDataSet *expressDataSet, const IfcPile &obj, const CopyOp &copyop)
{
    IfcPile *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPile(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPile_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPile *ExpressDataSet::cloneIfcPile(const IfcPile &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPile(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPile(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPile  > &ExpressDataSet::getAllIfcPile ()
{
    return m_refIfcPileList;
}



IfcPipeFittingType *ExpressDataSet::getIfcPipeFittingType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPipeFittingType * > (current->second.get());
    }
    else
    {
        IfcPipeFittingType *ret = static_cast< IfcPipeFittingType * > (allocateIfcPipeFittingType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPipeFittingType(IfcPipeFittingType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPipeFittingType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPipeFittingType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPipeFittingType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPipeFittingType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPipeFittingType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPipeFittingType > ExpressDataSet::createIfcPipeFittingType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPipeFittingType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPipeFittingType * > (allocateIfcPipeFittingType(this, Step::Id_UNSET));
    }
}

IfcPipeFittingType *ExpressDataSet::cloneIfcPipeFittingType(ExpressDataSet *expressDataSet, const IfcPipeFittingType &obj, const CopyOp &copyop)
{
    IfcPipeFittingType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPipeFittingType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPipeFittingType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPipeFittingType *ExpressDataSet::cloneIfcPipeFittingType(const IfcPipeFittingType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPipeFittingType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPipeFittingType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPipeFittingType  > &ExpressDataSet::getAllIfcPipeFittingType ()
{
    return m_refIfcPipeFittingTypeList;
}



IfcPipeSegmentType *ExpressDataSet::getIfcPipeSegmentType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPipeSegmentType * > (current->second.get());
    }
    else
    {
        IfcPipeSegmentType *ret = static_cast< IfcPipeSegmentType * > (allocateIfcPipeSegmentType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPipeSegmentType(IfcPipeSegmentType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPipeSegmentType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPipeSegmentType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPipeSegmentType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPipeSegmentType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPipeSegmentType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPipeSegmentType > ExpressDataSet::createIfcPipeSegmentType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPipeSegmentType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPipeSegmentType * > (allocateIfcPipeSegmentType(this, Step::Id_UNSET));
    }
}

IfcPipeSegmentType *ExpressDataSet::cloneIfcPipeSegmentType(ExpressDataSet *expressDataSet, const IfcPipeSegmentType &obj, const CopyOp &copyop)
{
    IfcPipeSegmentType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPipeSegmentType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPipeSegmentType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPipeSegmentType *ExpressDataSet::cloneIfcPipeSegmentType(const IfcPipeSegmentType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPipeSegmentType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPipeSegmentType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPipeSegmentType  > &ExpressDataSet::getAllIfcPipeSegmentType ()
{
    return m_refIfcPipeSegmentTypeList;
}



IfcPixelTexture *ExpressDataSet::getIfcPixelTexture(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPixelTexture * > (current->second.get());
    }
    else
    {
        IfcPixelTexture *ret = static_cast< IfcPixelTexture * > (allocateIfcPixelTexture(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPixelTexture(IfcPixelTexture *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPixelTexture_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPixelTexture(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPixelTexture *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPixelTexture(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPixelTexture_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPixelTexture > ExpressDataSet::createIfcPixelTexture(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPixelTexture(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPixelTexture * > (allocateIfcPixelTexture(this, Step::Id_UNSET));
    }
}

IfcPixelTexture *ExpressDataSet::cloneIfcPixelTexture(ExpressDataSet *expressDataSet, const IfcPixelTexture &obj, const CopyOp &copyop)
{
    IfcPixelTexture *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPixelTexture(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPixelTexture_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPixelTexture *ExpressDataSet::cloneIfcPixelTexture(const IfcPixelTexture &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPixelTexture(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPixelTexture(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPixelTexture  > &ExpressDataSet::getAllIfcPixelTexture ()
{
    return m_refIfcPixelTextureList;
}



IfcPlacement *ExpressDataSet::getIfcPlacement(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPlacement * > (current->second.get());
    }
    else
    {
        IfcPlacement *ret = static_cast< IfcPlacement * > (allocateIfcPlacement(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPlacement(IfcPlacement *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPlacement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPlacement(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPlacement *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPlacement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPlacement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPlacement > ExpressDataSet::createIfcPlacement(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPlacement(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPlacement * > (allocateIfcPlacement(this, Step::Id_UNSET));
    }
}

IfcPlacement *ExpressDataSet::cloneIfcPlacement(ExpressDataSet *expressDataSet, const IfcPlacement &obj, const CopyOp &copyop)
{
    IfcPlacement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPlacement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPlacement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPlacement *ExpressDataSet::cloneIfcPlacement(const IfcPlacement &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPlacement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPlacement(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPlacement  > &ExpressDataSet::getAllIfcPlacement ()
{
    return m_refIfcPlacementList;
}



IfcPlanarBox *ExpressDataSet::getIfcPlanarBox(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPlanarBox * > (current->second.get());
    }
    else
    {
        IfcPlanarBox *ret = static_cast< IfcPlanarBox * > (allocateIfcPlanarBox(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPlanarBox(IfcPlanarBox *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPlanarBox_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPlanarBox(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPlanarBox *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPlanarBox(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPlanarBox_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPlanarBox > ExpressDataSet::createIfcPlanarBox(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPlanarBox(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPlanarBox * > (allocateIfcPlanarBox(this, Step::Id_UNSET));
    }
}

IfcPlanarBox *ExpressDataSet::cloneIfcPlanarBox(ExpressDataSet *expressDataSet, const IfcPlanarBox &obj, const CopyOp &copyop)
{
    IfcPlanarBox *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPlanarBox(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPlanarBox_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPlanarBox *ExpressDataSet::cloneIfcPlanarBox(const IfcPlanarBox &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPlanarBox(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPlanarBox(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPlanarBox  > &ExpressDataSet::getAllIfcPlanarBox ()
{
    return m_refIfcPlanarBoxList;
}



IfcPlanarExtent *ExpressDataSet::getIfcPlanarExtent(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPlanarExtent * > (current->second.get());
    }
    else
    {
        IfcPlanarExtent *ret = static_cast< IfcPlanarExtent * > (allocateIfcPlanarExtent(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPlanarExtent(IfcPlanarExtent *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPlanarExtent_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPlanarExtent(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPlanarExtent *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPlanarExtent(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPlanarExtent_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPlanarExtent > ExpressDataSet::createIfcPlanarExtent(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPlanarExtent(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPlanarExtent * > (allocateIfcPlanarExtent(this, Step::Id_UNSET));
    }
}

IfcPlanarExtent *ExpressDataSet::cloneIfcPlanarExtent(ExpressDataSet *expressDataSet, const IfcPlanarExtent &obj, const CopyOp &copyop)
{
    IfcPlanarExtent *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPlanarExtent(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPlanarExtent_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPlanarExtent *ExpressDataSet::cloneIfcPlanarExtent(const IfcPlanarExtent &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPlanarExtent(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPlanarExtent(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPlanarExtent  > &ExpressDataSet::getAllIfcPlanarExtent ()
{
    return m_refIfcPlanarExtentList;
}



IfcPlane *ExpressDataSet::getIfcPlane(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPlane * > (current->second.get());
    }
    else
    {
        IfcPlane *ret = static_cast< IfcPlane * > (allocateIfcPlane(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPlane(IfcPlane *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPlane_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPlane(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPlane *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPlane(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPlane_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPlane > ExpressDataSet::createIfcPlane(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPlane(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPlane * > (allocateIfcPlane(this, Step::Id_UNSET));
    }
}

IfcPlane *ExpressDataSet::cloneIfcPlane(ExpressDataSet *expressDataSet, const IfcPlane &obj, const CopyOp &copyop)
{
    IfcPlane *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPlane(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPlane_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPlane *ExpressDataSet::cloneIfcPlane(const IfcPlane &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPlane(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPlane(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPlane  > &ExpressDataSet::getAllIfcPlane ()
{
    return m_refIfcPlaneList;
}



IfcPlate *ExpressDataSet::getIfcPlate(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPlate * > (current->second.get());
    }
    else
    {
        IfcPlate *ret = static_cast< IfcPlate * > (allocateIfcPlate(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPlate(IfcPlate *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPlate_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPlate(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPlate *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPlate(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPlate_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPlate > ExpressDataSet::createIfcPlate(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPlate(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPlate * > (allocateIfcPlate(this, Step::Id_UNSET));
    }
}

IfcPlate *ExpressDataSet::cloneIfcPlate(ExpressDataSet *expressDataSet, const IfcPlate &obj, const CopyOp &copyop)
{
    IfcPlate *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPlate(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPlate_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPlate *ExpressDataSet::cloneIfcPlate(const IfcPlate &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPlate(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPlate(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPlate  > &ExpressDataSet::getAllIfcPlate ()
{
    return m_refIfcPlateList;
}



IfcPlateType *ExpressDataSet::getIfcPlateType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPlateType * > (current->second.get());
    }
    else
    {
        IfcPlateType *ret = static_cast< IfcPlateType * > (allocateIfcPlateType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPlateType(IfcPlateType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPlateType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPlateType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPlateType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPlateType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPlateType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPlateType > ExpressDataSet::createIfcPlateType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPlateType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPlateType * > (allocateIfcPlateType(this, Step::Id_UNSET));
    }
}

IfcPlateType *ExpressDataSet::cloneIfcPlateType(ExpressDataSet *expressDataSet, const IfcPlateType &obj, const CopyOp &copyop)
{
    IfcPlateType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPlateType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPlateType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPlateType *ExpressDataSet::cloneIfcPlateType(const IfcPlateType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPlateType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPlateType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPlateType  > &ExpressDataSet::getAllIfcPlateType ()
{
    return m_refIfcPlateTypeList;
}



IfcPoint *ExpressDataSet::getIfcPoint(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPoint * > (current->second.get());
    }
    else
    {
        IfcPoint *ret = static_cast< IfcPoint * > (allocateIfcPoint(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPoint(IfcPoint *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPoint_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPoint(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPoint *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPoint(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPoint_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPoint > ExpressDataSet::createIfcPoint(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPoint(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPoint * > (allocateIfcPoint(this, Step::Id_UNSET));
    }
}

IfcPoint *ExpressDataSet::cloneIfcPoint(ExpressDataSet *expressDataSet, const IfcPoint &obj, const CopyOp &copyop)
{
    IfcPoint *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPoint(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPoint_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPoint *ExpressDataSet::cloneIfcPoint(const IfcPoint &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPoint(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPoint(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPoint  > &ExpressDataSet::getAllIfcPoint ()
{
    return m_refIfcPointList;
}



IfcPointOnCurve *ExpressDataSet::getIfcPointOnCurve(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPointOnCurve * > (current->second.get());
    }
    else
    {
        IfcPointOnCurve *ret = static_cast< IfcPointOnCurve * > (allocateIfcPointOnCurve(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPointOnCurve(IfcPointOnCurve *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPointOnCurve_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPointOnCurve(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPointOnCurve *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPointOnCurve(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPointOnCurve_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPointOnCurve > ExpressDataSet::createIfcPointOnCurve(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPointOnCurve(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPointOnCurve * > (allocateIfcPointOnCurve(this, Step::Id_UNSET));
    }
}

IfcPointOnCurve *ExpressDataSet::cloneIfcPointOnCurve(ExpressDataSet *expressDataSet, const IfcPointOnCurve &obj, const CopyOp &copyop)
{
    IfcPointOnCurve *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPointOnCurve(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPointOnCurve_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPointOnCurve *ExpressDataSet::cloneIfcPointOnCurve(const IfcPointOnCurve &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPointOnCurve(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPointOnCurve(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPointOnCurve  > &ExpressDataSet::getAllIfcPointOnCurve ()
{
    return m_refIfcPointOnCurveList;
}



IfcPointOnSurface *ExpressDataSet::getIfcPointOnSurface(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPointOnSurface * > (current->second.get());
    }
    else
    {
        IfcPointOnSurface *ret = static_cast< IfcPointOnSurface * > (allocateIfcPointOnSurface(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPointOnSurface(IfcPointOnSurface *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPointOnSurface_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPointOnSurface(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPointOnSurface *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPointOnSurface(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPointOnSurface_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPointOnSurface > ExpressDataSet::createIfcPointOnSurface(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPointOnSurface(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPointOnSurface * > (allocateIfcPointOnSurface(this, Step::Id_UNSET));
    }
}

IfcPointOnSurface *ExpressDataSet::cloneIfcPointOnSurface(ExpressDataSet *expressDataSet, const IfcPointOnSurface &obj, const CopyOp &copyop)
{
    IfcPointOnSurface *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPointOnSurface(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPointOnSurface_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPointOnSurface *ExpressDataSet::cloneIfcPointOnSurface(const IfcPointOnSurface &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPointOnSurface(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPointOnSurface(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPointOnSurface  > &ExpressDataSet::getAllIfcPointOnSurface ()
{
    return m_refIfcPointOnSurfaceList;
}



IfcPolygonalBoundedHalfSpace *ExpressDataSet::getIfcPolygonalBoundedHalfSpace(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPolygonalBoundedHalfSpace * > (current->second.get());
    }
    else
    {
        IfcPolygonalBoundedHalfSpace *ret = static_cast< IfcPolygonalBoundedHalfSpace * > (allocateIfcPolygonalBoundedHalfSpace(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPolygonalBoundedHalfSpace(IfcPolygonalBoundedHalfSpace *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPolygonalBoundedHalfSpace_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPolygonalBoundedHalfSpace(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPolygonalBoundedHalfSpace *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPolygonalBoundedHalfSpace(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPolygonalBoundedHalfSpace_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPolygonalBoundedHalfSpace > ExpressDataSet::createIfcPolygonalBoundedHalfSpace(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPolygonalBoundedHalfSpace(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPolygonalBoundedHalfSpace * > (allocateIfcPolygonalBoundedHalfSpace(this, Step::Id_UNSET));
    }
}

IfcPolygonalBoundedHalfSpace *ExpressDataSet::cloneIfcPolygonalBoundedHalfSpace(ExpressDataSet *expressDataSet, const IfcPolygonalBoundedHalfSpace &obj, const CopyOp &copyop)
{
    IfcPolygonalBoundedHalfSpace *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPolygonalBoundedHalfSpace(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPolygonalBoundedHalfSpace_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPolygonalBoundedHalfSpace *ExpressDataSet::cloneIfcPolygonalBoundedHalfSpace(const IfcPolygonalBoundedHalfSpace &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPolygonalBoundedHalfSpace(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPolygonalBoundedHalfSpace(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPolygonalBoundedHalfSpace  > &ExpressDataSet::getAllIfcPolygonalBoundedHalfSpace ()
{
    return m_refIfcPolygonalBoundedHalfSpaceList;
}



IfcPolyline *ExpressDataSet::getIfcPolyline(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPolyline * > (current->second.get());
    }
    else
    {
        IfcPolyline *ret = static_cast< IfcPolyline * > (allocateIfcPolyline(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPolyline(IfcPolyline *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPolyline_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPolyline(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPolyline *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPolyline(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPolyline_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPolyline > ExpressDataSet::createIfcPolyline(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPolyline(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPolyline * > (allocateIfcPolyline(this, Step::Id_UNSET));
    }
}

IfcPolyline *ExpressDataSet::cloneIfcPolyline(ExpressDataSet *expressDataSet, const IfcPolyline &obj, const CopyOp &copyop)
{
    IfcPolyline *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPolyline(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPolyline_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPolyline *ExpressDataSet::cloneIfcPolyline(const IfcPolyline &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPolyline(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPolyline(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPolyline  > &ExpressDataSet::getAllIfcPolyline ()
{
    return m_refIfcPolylineList;
}



IfcPolyLoop *ExpressDataSet::getIfcPolyLoop(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPolyLoop * > (current->second.get());
    }
    else
    {
        IfcPolyLoop *ret = static_cast< IfcPolyLoop * > (allocateIfcPolyLoop(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPolyLoop(IfcPolyLoop *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPolyLoop_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPolyLoop(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPolyLoop *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPolyLoop(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPolyLoop_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPolyLoop > ExpressDataSet::createIfcPolyLoop(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPolyLoop(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPolyLoop * > (allocateIfcPolyLoop(this, Step::Id_UNSET));
    }
}

IfcPolyLoop *ExpressDataSet::cloneIfcPolyLoop(ExpressDataSet *expressDataSet, const IfcPolyLoop &obj, const CopyOp &copyop)
{
    IfcPolyLoop *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPolyLoop(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPolyLoop_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPolyLoop *ExpressDataSet::cloneIfcPolyLoop(const IfcPolyLoop &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPolyLoop(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPolyLoop(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPolyLoop  > &ExpressDataSet::getAllIfcPolyLoop ()
{
    return m_refIfcPolyLoopList;
}



IfcPort *ExpressDataSet::getIfcPort(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPort * > (current->second.get());
    }
    else
    {
        IfcPort *ret = static_cast< IfcPort * > (allocateIfcPort(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPort(IfcPort *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPort_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPort(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPort *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPort(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPort_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPort > ExpressDataSet::createIfcPort(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPort(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPort * > (allocateIfcPort(this, Step::Id_UNSET));
    }
}

IfcPort *ExpressDataSet::cloneIfcPort(ExpressDataSet *expressDataSet, const IfcPort &obj, const CopyOp &copyop)
{
    IfcPort *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPort(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPort_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPort *ExpressDataSet::cloneIfcPort(const IfcPort &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPort(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPort(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPort  > &ExpressDataSet::getAllIfcPort ()
{
    return m_refIfcPortList;
}



IfcPostalAddress *ExpressDataSet::getIfcPostalAddress(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPostalAddress * > (current->second.get());
    }
    else
    {
        IfcPostalAddress *ret = static_cast< IfcPostalAddress * > (allocateIfcPostalAddress(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPostalAddress(IfcPostalAddress *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPostalAddress_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPostalAddress(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPostalAddress *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPostalAddress(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPostalAddress_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPostalAddress > ExpressDataSet::createIfcPostalAddress(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPostalAddress(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPostalAddress * > (allocateIfcPostalAddress(this, Step::Id_UNSET));
    }
}

IfcPostalAddress *ExpressDataSet::cloneIfcPostalAddress(ExpressDataSet *expressDataSet, const IfcPostalAddress &obj, const CopyOp &copyop)
{
    IfcPostalAddress *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPostalAddress(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPostalAddress_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPostalAddress *ExpressDataSet::cloneIfcPostalAddress(const IfcPostalAddress &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPostalAddress(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPostalAddress(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPostalAddress  > &ExpressDataSet::getAllIfcPostalAddress ()
{
    return m_refIfcPostalAddressList;
}



IfcPreDefinedColour *ExpressDataSet::getIfcPreDefinedColour(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPreDefinedColour * > (current->second.get());
    }
    else
    {
        IfcPreDefinedColour *ret = static_cast< IfcPreDefinedColour * > (allocateIfcPreDefinedColour(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPreDefinedColour(IfcPreDefinedColour *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPreDefinedColour_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPreDefinedColour(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPreDefinedColour *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPreDefinedColour(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPreDefinedColour_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPreDefinedColour > ExpressDataSet::createIfcPreDefinedColour(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPreDefinedColour(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPreDefinedColour * > (allocateIfcPreDefinedColour(this, Step::Id_UNSET));
    }
}

IfcPreDefinedColour *ExpressDataSet::cloneIfcPreDefinedColour(ExpressDataSet *expressDataSet, const IfcPreDefinedColour &obj, const CopyOp &copyop)
{
    IfcPreDefinedColour *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPreDefinedColour(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPreDefinedColour_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPreDefinedColour *ExpressDataSet::cloneIfcPreDefinedColour(const IfcPreDefinedColour &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPreDefinedColour(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPreDefinedColour(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPreDefinedColour  > &ExpressDataSet::getAllIfcPreDefinedColour ()
{
    return m_refIfcPreDefinedColourList;
}



IfcPreDefinedCurveFont *ExpressDataSet::getIfcPreDefinedCurveFont(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPreDefinedCurveFont * > (current->second.get());
    }
    else
    {
        IfcPreDefinedCurveFont *ret = static_cast< IfcPreDefinedCurveFont * > (allocateIfcPreDefinedCurveFont(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPreDefinedCurveFont(IfcPreDefinedCurveFont *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPreDefinedCurveFont_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPreDefinedCurveFont(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPreDefinedCurveFont *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPreDefinedCurveFont(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPreDefinedCurveFont_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPreDefinedCurveFont > ExpressDataSet::createIfcPreDefinedCurveFont(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPreDefinedCurveFont(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPreDefinedCurveFont * > (allocateIfcPreDefinedCurveFont(this, Step::Id_UNSET));
    }
}

IfcPreDefinedCurveFont *ExpressDataSet::cloneIfcPreDefinedCurveFont(ExpressDataSet *expressDataSet, const IfcPreDefinedCurveFont &obj, const CopyOp &copyop)
{
    IfcPreDefinedCurveFont *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPreDefinedCurveFont(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPreDefinedCurveFont_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPreDefinedCurveFont *ExpressDataSet::cloneIfcPreDefinedCurveFont(const IfcPreDefinedCurveFont &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPreDefinedCurveFont(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPreDefinedCurveFont(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPreDefinedCurveFont  > &ExpressDataSet::getAllIfcPreDefinedCurveFont ()
{
    return m_refIfcPreDefinedCurveFontList;
}



IfcPreDefinedDimensionSymbol *ExpressDataSet::getIfcPreDefinedDimensionSymbol(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPreDefinedDimensionSymbol * > (current->second.get());
    }
    else
    {
        IfcPreDefinedDimensionSymbol *ret = static_cast< IfcPreDefinedDimensionSymbol * > (allocateIfcPreDefinedDimensionSymbol(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPreDefinedDimensionSymbol(IfcPreDefinedDimensionSymbol *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPreDefinedDimensionSymbol_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPreDefinedDimensionSymbol(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPreDefinedDimensionSymbol *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPreDefinedDimensionSymbol(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPreDefinedDimensionSymbol_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPreDefinedDimensionSymbol > ExpressDataSet::createIfcPreDefinedDimensionSymbol(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPreDefinedDimensionSymbol(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPreDefinedDimensionSymbol * > (allocateIfcPreDefinedDimensionSymbol(this, Step::Id_UNSET));
    }
}

IfcPreDefinedDimensionSymbol *ExpressDataSet::cloneIfcPreDefinedDimensionSymbol(ExpressDataSet *expressDataSet, const IfcPreDefinedDimensionSymbol &obj, const CopyOp &copyop)
{
    IfcPreDefinedDimensionSymbol *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPreDefinedDimensionSymbol(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPreDefinedDimensionSymbol_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPreDefinedDimensionSymbol *ExpressDataSet::cloneIfcPreDefinedDimensionSymbol(const IfcPreDefinedDimensionSymbol &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPreDefinedDimensionSymbol(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPreDefinedDimensionSymbol(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPreDefinedDimensionSymbol  > &ExpressDataSet::getAllIfcPreDefinedDimensionSymbol ()
{
    return m_refIfcPreDefinedDimensionSymbolList;
}



IfcPreDefinedItem *ExpressDataSet::getIfcPreDefinedItem(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPreDefinedItem * > (current->second.get());
    }
    else
    {
        IfcPreDefinedItem *ret = static_cast< IfcPreDefinedItem * > (allocateIfcPreDefinedItem(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPreDefinedItem(IfcPreDefinedItem *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPreDefinedItem_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPreDefinedItem(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPreDefinedItem *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPreDefinedItem(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPreDefinedItem_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPreDefinedItem > ExpressDataSet::createIfcPreDefinedItem(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPreDefinedItem(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPreDefinedItem * > (allocateIfcPreDefinedItem(this, Step::Id_UNSET));
    }
}

IfcPreDefinedItem *ExpressDataSet::cloneIfcPreDefinedItem(ExpressDataSet *expressDataSet, const IfcPreDefinedItem &obj, const CopyOp &copyop)
{
    IfcPreDefinedItem *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPreDefinedItem(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPreDefinedItem_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPreDefinedItem *ExpressDataSet::cloneIfcPreDefinedItem(const IfcPreDefinedItem &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPreDefinedItem(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPreDefinedItem(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPreDefinedItem  > &ExpressDataSet::getAllIfcPreDefinedItem ()
{
    return m_refIfcPreDefinedItemList;
}



IfcPreDefinedPointMarkerSymbol *ExpressDataSet::getIfcPreDefinedPointMarkerSymbol(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPreDefinedPointMarkerSymbol * > (current->second.get());
    }
    else
    {
        IfcPreDefinedPointMarkerSymbol *ret = static_cast< IfcPreDefinedPointMarkerSymbol * > (allocateIfcPreDefinedPointMarkerSymbol(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPreDefinedPointMarkerSymbol(IfcPreDefinedPointMarkerSymbol *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPreDefinedPointMarkerSymbol_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPreDefinedPointMarkerSymbol(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPreDefinedPointMarkerSymbol *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPreDefinedPointMarkerSymbol(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPreDefinedPointMarkerSymbol_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPreDefinedPointMarkerSymbol > ExpressDataSet::createIfcPreDefinedPointMarkerSymbol(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPreDefinedPointMarkerSymbol(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPreDefinedPointMarkerSymbol * > (allocateIfcPreDefinedPointMarkerSymbol(this, Step::Id_UNSET));
    }
}

IfcPreDefinedPointMarkerSymbol *ExpressDataSet::cloneIfcPreDefinedPointMarkerSymbol(ExpressDataSet *expressDataSet, const IfcPreDefinedPointMarkerSymbol &obj, const CopyOp &copyop)
{
    IfcPreDefinedPointMarkerSymbol *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPreDefinedPointMarkerSymbol(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPreDefinedPointMarkerSymbol_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPreDefinedPointMarkerSymbol *ExpressDataSet::cloneIfcPreDefinedPointMarkerSymbol(const IfcPreDefinedPointMarkerSymbol &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPreDefinedPointMarkerSymbol(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPreDefinedPointMarkerSymbol(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPreDefinedPointMarkerSymbol  > &ExpressDataSet::getAllIfcPreDefinedPointMarkerSymbol ()
{
    return m_refIfcPreDefinedPointMarkerSymbolList;
}



IfcPreDefinedSymbol *ExpressDataSet::getIfcPreDefinedSymbol(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPreDefinedSymbol * > (current->second.get());
    }
    else
    {
        IfcPreDefinedSymbol *ret = static_cast< IfcPreDefinedSymbol * > (allocateIfcPreDefinedSymbol(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPreDefinedSymbol(IfcPreDefinedSymbol *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPreDefinedSymbol_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPreDefinedSymbol(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPreDefinedSymbol *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPreDefinedSymbol(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPreDefinedSymbol_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPreDefinedSymbol > ExpressDataSet::createIfcPreDefinedSymbol(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPreDefinedSymbol(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPreDefinedSymbol * > (allocateIfcPreDefinedSymbol(this, Step::Id_UNSET));
    }
}

IfcPreDefinedSymbol *ExpressDataSet::cloneIfcPreDefinedSymbol(ExpressDataSet *expressDataSet, const IfcPreDefinedSymbol &obj, const CopyOp &copyop)
{
    IfcPreDefinedSymbol *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPreDefinedSymbol(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPreDefinedSymbol_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPreDefinedSymbol *ExpressDataSet::cloneIfcPreDefinedSymbol(const IfcPreDefinedSymbol &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPreDefinedSymbol(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPreDefinedSymbol(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPreDefinedSymbol  > &ExpressDataSet::getAllIfcPreDefinedSymbol ()
{
    return m_refIfcPreDefinedSymbolList;
}



IfcPreDefinedTerminatorSymbol *ExpressDataSet::getIfcPreDefinedTerminatorSymbol(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPreDefinedTerminatorSymbol * > (current->second.get());
    }
    else
    {
        IfcPreDefinedTerminatorSymbol *ret = static_cast< IfcPreDefinedTerminatorSymbol * > (allocateIfcPreDefinedTerminatorSymbol(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPreDefinedTerminatorSymbol(IfcPreDefinedTerminatorSymbol *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPreDefinedTerminatorSymbol_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPreDefinedTerminatorSymbol(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPreDefinedTerminatorSymbol *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPreDefinedTerminatorSymbol(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPreDefinedTerminatorSymbol_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPreDefinedTerminatorSymbol > ExpressDataSet::createIfcPreDefinedTerminatorSymbol(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPreDefinedTerminatorSymbol(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPreDefinedTerminatorSymbol * > (allocateIfcPreDefinedTerminatorSymbol(this, Step::Id_UNSET));
    }
}

IfcPreDefinedTerminatorSymbol *ExpressDataSet::cloneIfcPreDefinedTerminatorSymbol(ExpressDataSet *expressDataSet, const IfcPreDefinedTerminatorSymbol &obj, const CopyOp &copyop)
{
    IfcPreDefinedTerminatorSymbol *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPreDefinedTerminatorSymbol(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPreDefinedTerminatorSymbol_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPreDefinedTerminatorSymbol *ExpressDataSet::cloneIfcPreDefinedTerminatorSymbol(const IfcPreDefinedTerminatorSymbol &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPreDefinedTerminatorSymbol(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPreDefinedTerminatorSymbol(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPreDefinedTerminatorSymbol  > &ExpressDataSet::getAllIfcPreDefinedTerminatorSymbol ()
{
    return m_refIfcPreDefinedTerminatorSymbolList;
}



IfcPreDefinedTextFont *ExpressDataSet::getIfcPreDefinedTextFont(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPreDefinedTextFont * > (current->second.get());
    }
    else
    {
        IfcPreDefinedTextFont *ret = static_cast< IfcPreDefinedTextFont * > (allocateIfcPreDefinedTextFont(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPreDefinedTextFont(IfcPreDefinedTextFont *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPreDefinedTextFont_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPreDefinedTextFont(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPreDefinedTextFont *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPreDefinedTextFont(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPreDefinedTextFont_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPreDefinedTextFont > ExpressDataSet::createIfcPreDefinedTextFont(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPreDefinedTextFont(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPreDefinedTextFont * > (allocateIfcPreDefinedTextFont(this, Step::Id_UNSET));
    }
}

IfcPreDefinedTextFont *ExpressDataSet::cloneIfcPreDefinedTextFont(ExpressDataSet *expressDataSet, const IfcPreDefinedTextFont &obj, const CopyOp &copyop)
{
    IfcPreDefinedTextFont *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPreDefinedTextFont(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPreDefinedTextFont_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPreDefinedTextFont *ExpressDataSet::cloneIfcPreDefinedTextFont(const IfcPreDefinedTextFont &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPreDefinedTextFont(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPreDefinedTextFont(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPreDefinedTextFont  > &ExpressDataSet::getAllIfcPreDefinedTextFont ()
{
    return m_refIfcPreDefinedTextFontList;
}



IfcPresentationLayerAssignment *ExpressDataSet::getIfcPresentationLayerAssignment(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPresentationLayerAssignment * > (current->second.get());
    }
    else
    {
        IfcPresentationLayerAssignment *ret = static_cast< IfcPresentationLayerAssignment * > (allocateIfcPresentationLayerAssignment(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPresentationLayerAssignment(IfcPresentationLayerAssignment *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPresentationLayerAssignment_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPresentationLayerAssignment(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPresentationLayerAssignment *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPresentationLayerAssignment(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPresentationLayerAssignment_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPresentationLayerAssignment > ExpressDataSet::createIfcPresentationLayerAssignment(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPresentationLayerAssignment(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPresentationLayerAssignment * > (allocateIfcPresentationLayerAssignment(this, Step::Id_UNSET));
    }
}

IfcPresentationLayerAssignment *ExpressDataSet::cloneIfcPresentationLayerAssignment(ExpressDataSet *expressDataSet, const IfcPresentationLayerAssignment &obj, const CopyOp &copyop)
{
    IfcPresentationLayerAssignment *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPresentationLayerAssignment(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPresentationLayerAssignment_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPresentationLayerAssignment *ExpressDataSet::cloneIfcPresentationLayerAssignment(const IfcPresentationLayerAssignment &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPresentationLayerAssignment(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPresentationLayerAssignment(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPresentationLayerAssignment  > &ExpressDataSet::getAllIfcPresentationLayerAssignment ()
{
    return m_refIfcPresentationLayerAssignmentList;
}



IfcPresentationLayerWithStyle *ExpressDataSet::getIfcPresentationLayerWithStyle(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPresentationLayerWithStyle * > (current->second.get());
    }
    else
    {
        IfcPresentationLayerWithStyle *ret = static_cast< IfcPresentationLayerWithStyle * > (allocateIfcPresentationLayerWithStyle(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPresentationLayerWithStyle(IfcPresentationLayerWithStyle *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPresentationLayerWithStyle_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPresentationLayerWithStyle(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPresentationLayerWithStyle *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPresentationLayerWithStyle(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPresentationLayerWithStyle_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPresentationLayerWithStyle > ExpressDataSet::createIfcPresentationLayerWithStyle(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPresentationLayerWithStyle(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPresentationLayerWithStyle * > (allocateIfcPresentationLayerWithStyle(this, Step::Id_UNSET));
    }
}

IfcPresentationLayerWithStyle *ExpressDataSet::cloneIfcPresentationLayerWithStyle(ExpressDataSet *expressDataSet, const IfcPresentationLayerWithStyle &obj, const CopyOp &copyop)
{
    IfcPresentationLayerWithStyle *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPresentationLayerWithStyle(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPresentationLayerWithStyle_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPresentationLayerWithStyle *ExpressDataSet::cloneIfcPresentationLayerWithStyle(const IfcPresentationLayerWithStyle &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPresentationLayerWithStyle(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPresentationLayerWithStyle(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPresentationLayerWithStyle  > &ExpressDataSet::getAllIfcPresentationLayerWithStyle ()
{
    return m_refIfcPresentationLayerWithStyleList;
}



IfcPresentationStyle *ExpressDataSet::getIfcPresentationStyle(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPresentationStyle * > (current->second.get());
    }
    else
    {
        IfcPresentationStyle *ret = static_cast< IfcPresentationStyle * > (allocateIfcPresentationStyle(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPresentationStyle(IfcPresentationStyle *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPresentationStyle_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPresentationStyle(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPresentationStyle *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPresentationStyle(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPresentationStyle_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPresentationStyle > ExpressDataSet::createIfcPresentationStyle(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPresentationStyle(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPresentationStyle * > (allocateIfcPresentationStyle(this, Step::Id_UNSET));
    }
}

IfcPresentationStyle *ExpressDataSet::cloneIfcPresentationStyle(ExpressDataSet *expressDataSet, const IfcPresentationStyle &obj, const CopyOp &copyop)
{
    IfcPresentationStyle *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPresentationStyle(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPresentationStyle_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPresentationStyle *ExpressDataSet::cloneIfcPresentationStyle(const IfcPresentationStyle &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPresentationStyle(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPresentationStyle(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPresentationStyle  > &ExpressDataSet::getAllIfcPresentationStyle ()
{
    return m_refIfcPresentationStyleList;
}



IfcPresentationStyleAssignment *ExpressDataSet::getIfcPresentationStyleAssignment(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPresentationStyleAssignment * > (current->second.get());
    }
    else
    {
        IfcPresentationStyleAssignment *ret = static_cast< IfcPresentationStyleAssignment * > (allocateIfcPresentationStyleAssignment(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPresentationStyleAssignment(IfcPresentationStyleAssignment *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPresentationStyleAssignment_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPresentationStyleAssignment(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPresentationStyleAssignment *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPresentationStyleAssignment(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPresentationStyleAssignment_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPresentationStyleAssignment > ExpressDataSet::createIfcPresentationStyleAssignment(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPresentationStyleAssignment(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPresentationStyleAssignment * > (allocateIfcPresentationStyleAssignment(this, Step::Id_UNSET));
    }
}

IfcPresentationStyleAssignment *ExpressDataSet::cloneIfcPresentationStyleAssignment(ExpressDataSet *expressDataSet, const IfcPresentationStyleAssignment &obj, const CopyOp &copyop)
{
    IfcPresentationStyleAssignment *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPresentationStyleAssignment(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPresentationStyleAssignment_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPresentationStyleAssignment *ExpressDataSet::cloneIfcPresentationStyleAssignment(const IfcPresentationStyleAssignment &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPresentationStyleAssignment(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPresentationStyleAssignment(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPresentationStyleAssignment  > &ExpressDataSet::getAllIfcPresentationStyleAssignment ()
{
    return m_refIfcPresentationStyleAssignmentList;
}



IfcProcedure *ExpressDataSet::getIfcProcedure(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcProcedure * > (current->second.get());
    }
    else
    {
        IfcProcedure *ret = static_cast< IfcProcedure * > (allocateIfcProcedure(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcProcedure(IfcProcedure *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcProcedure_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcProcedure(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcProcedure *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcProcedure(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcProcedure_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcProcedure > ExpressDataSet::createIfcProcedure(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcProcedure(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcProcedure * > (allocateIfcProcedure(this, Step::Id_UNSET));
    }
}

IfcProcedure *ExpressDataSet::cloneIfcProcedure(ExpressDataSet *expressDataSet, const IfcProcedure &obj, const CopyOp &copyop)
{
    IfcProcedure *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcProcedure(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcProcedure_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcProcedure *ExpressDataSet::cloneIfcProcedure(const IfcProcedure &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcProcedure(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcProcedure(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcProcedure  > &ExpressDataSet::getAllIfcProcedure ()
{
    return m_refIfcProcedureList;
}



IfcProcess *ExpressDataSet::getIfcProcess(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcProcess * > (current->second.get());
    }
    else
    {
        IfcProcess *ret = static_cast< IfcProcess * > (allocateIfcProcess(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcProcess(IfcProcess *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcProcess_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcProcess(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcProcess *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcProcess(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcProcess_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcProcess > ExpressDataSet::createIfcProcess(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcProcess(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcProcess * > (allocateIfcProcess(this, Step::Id_UNSET));
    }
}

IfcProcess *ExpressDataSet::cloneIfcProcess(ExpressDataSet *expressDataSet, const IfcProcess &obj, const CopyOp &copyop)
{
    IfcProcess *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcProcess(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcProcess_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcProcess *ExpressDataSet::cloneIfcProcess(const IfcProcess &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcProcess(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcProcess(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcProcess  > &ExpressDataSet::getAllIfcProcess ()
{
    return m_refIfcProcessList;
}



IfcProduct *ExpressDataSet::getIfcProduct(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcProduct * > (current->second.get());
    }
    else
    {
        IfcProduct *ret = static_cast< IfcProduct * > (allocateIfcProduct(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcProduct(IfcProduct *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcProduct_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcProduct(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcProduct *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcProduct(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcProduct_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcProduct > ExpressDataSet::createIfcProduct(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcProduct(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcProduct * > (allocateIfcProduct(this, Step::Id_UNSET));
    }
}

IfcProduct *ExpressDataSet::cloneIfcProduct(ExpressDataSet *expressDataSet, const IfcProduct &obj, const CopyOp &copyop)
{
    IfcProduct *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcProduct(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcProduct_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcProduct *ExpressDataSet::cloneIfcProduct(const IfcProduct &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcProduct(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcProduct(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcProduct  > &ExpressDataSet::getAllIfcProduct ()
{
    return m_refIfcProductList;
}



IfcProductDefinitionShape *ExpressDataSet::getIfcProductDefinitionShape(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcProductDefinitionShape * > (current->second.get());
    }
    else
    {
        IfcProductDefinitionShape *ret = static_cast< IfcProductDefinitionShape * > (allocateIfcProductDefinitionShape(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcProductDefinitionShape(IfcProductDefinitionShape *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcProductDefinitionShape_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcProductDefinitionShape(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcProductDefinitionShape *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcProductDefinitionShape(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcProductDefinitionShape_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcProductDefinitionShape > ExpressDataSet::createIfcProductDefinitionShape(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcProductDefinitionShape(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcProductDefinitionShape * > (allocateIfcProductDefinitionShape(this, Step::Id_UNSET));
    }
}

IfcProductDefinitionShape *ExpressDataSet::cloneIfcProductDefinitionShape(ExpressDataSet *expressDataSet, const IfcProductDefinitionShape &obj, const CopyOp &copyop)
{
    IfcProductDefinitionShape *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcProductDefinitionShape(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcProductDefinitionShape_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcProductDefinitionShape *ExpressDataSet::cloneIfcProductDefinitionShape(const IfcProductDefinitionShape &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcProductDefinitionShape(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcProductDefinitionShape(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcProductDefinitionShape  > &ExpressDataSet::getAllIfcProductDefinitionShape ()
{
    return m_refIfcProductDefinitionShapeList;
}



IfcProductRepresentation *ExpressDataSet::getIfcProductRepresentation(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcProductRepresentation * > (current->second.get());
    }
    else
    {
        IfcProductRepresentation *ret = static_cast< IfcProductRepresentation * > (allocateIfcProductRepresentation(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcProductRepresentation(IfcProductRepresentation *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcProductRepresentation_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcProductRepresentation(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcProductRepresentation *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcProductRepresentation(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcProductRepresentation_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcProductRepresentation > ExpressDataSet::createIfcProductRepresentation(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcProductRepresentation(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcProductRepresentation * > (allocateIfcProductRepresentation(this, Step::Id_UNSET));
    }
}

IfcProductRepresentation *ExpressDataSet::cloneIfcProductRepresentation(ExpressDataSet *expressDataSet, const IfcProductRepresentation &obj, const CopyOp &copyop)
{
    IfcProductRepresentation *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcProductRepresentation(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcProductRepresentation_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcProductRepresentation *ExpressDataSet::cloneIfcProductRepresentation(const IfcProductRepresentation &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcProductRepresentation(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcProductRepresentation(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcProductRepresentation  > &ExpressDataSet::getAllIfcProductRepresentation ()
{
    return m_refIfcProductRepresentationList;
}



IfcProductsOfCombustionProperties *ExpressDataSet::getIfcProductsOfCombustionProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcProductsOfCombustionProperties * > (current->second.get());
    }
    else
    {
        IfcProductsOfCombustionProperties *ret = static_cast< IfcProductsOfCombustionProperties * > (allocateIfcProductsOfCombustionProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcProductsOfCombustionProperties(IfcProductsOfCombustionProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcProductsOfCombustionProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcProductsOfCombustionProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcProductsOfCombustionProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcProductsOfCombustionProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcProductsOfCombustionProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcProductsOfCombustionProperties > ExpressDataSet::createIfcProductsOfCombustionProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcProductsOfCombustionProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcProductsOfCombustionProperties * > (allocateIfcProductsOfCombustionProperties(this, Step::Id_UNSET));
    }
}

IfcProductsOfCombustionProperties *ExpressDataSet::cloneIfcProductsOfCombustionProperties(ExpressDataSet *expressDataSet, const IfcProductsOfCombustionProperties &obj, const CopyOp &copyop)
{
    IfcProductsOfCombustionProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcProductsOfCombustionProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcProductsOfCombustionProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcProductsOfCombustionProperties *ExpressDataSet::cloneIfcProductsOfCombustionProperties(const IfcProductsOfCombustionProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcProductsOfCombustionProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcProductsOfCombustionProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcProductsOfCombustionProperties  > &ExpressDataSet::getAllIfcProductsOfCombustionProperties ()
{
    return m_refIfcProductsOfCombustionPropertiesList;
}



IfcProfileDef *ExpressDataSet::getIfcProfileDef(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcProfileDef * > (current->second.get());
    }
    else
    {
        IfcProfileDef *ret = static_cast< IfcProfileDef * > (allocateIfcProfileDef(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcProfileDef(IfcProfileDef *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcProfileDef *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcProfileDef > ExpressDataSet::createIfcProfileDef(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcProfileDef(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcProfileDef * > (allocateIfcProfileDef(this, Step::Id_UNSET));
    }
}

IfcProfileDef *ExpressDataSet::cloneIfcProfileDef(ExpressDataSet *expressDataSet, const IfcProfileDef &obj, const CopyOp &copyop)
{
    IfcProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcProfileDef *ExpressDataSet::cloneIfcProfileDef(const IfcProfileDef &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcProfileDef(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcProfileDef  > &ExpressDataSet::getAllIfcProfileDef ()
{
    return m_refIfcProfileDefList;
}



IfcProfileProperties *ExpressDataSet::getIfcProfileProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcProfileProperties * > (current->second.get());
    }
    else
    {
        IfcProfileProperties *ret = static_cast< IfcProfileProperties * > (allocateIfcProfileProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcProfileProperties(IfcProfileProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcProfileProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcProfileProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcProfileProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcProfileProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcProfileProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcProfileProperties > ExpressDataSet::createIfcProfileProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcProfileProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcProfileProperties * > (allocateIfcProfileProperties(this, Step::Id_UNSET));
    }
}

IfcProfileProperties *ExpressDataSet::cloneIfcProfileProperties(ExpressDataSet *expressDataSet, const IfcProfileProperties &obj, const CopyOp &copyop)
{
    IfcProfileProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcProfileProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcProfileProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcProfileProperties *ExpressDataSet::cloneIfcProfileProperties(const IfcProfileProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcProfileProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcProfileProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcProfileProperties  > &ExpressDataSet::getAllIfcProfileProperties ()
{
    return m_refIfcProfilePropertiesList;
}



IfcProject *ExpressDataSet::getIfcProject(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcProject * > (current->second.get());
    }
    else
    {
        IfcProject *ret = static_cast< IfcProject * > (allocateIfcProject(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcProject(IfcProject *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcProject_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcProject(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcProject *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcProject(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcProject_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcProject > ExpressDataSet::createIfcProject(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcProject(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcProject * > (allocateIfcProject(this, Step::Id_UNSET));
    }
}

IfcProject *ExpressDataSet::cloneIfcProject(ExpressDataSet *expressDataSet, const IfcProject &obj, const CopyOp &copyop)
{
    IfcProject *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcProject(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcProject_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcProject *ExpressDataSet::cloneIfcProject(const IfcProject &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcProject(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcProject(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcProject  > &ExpressDataSet::getAllIfcProject ()
{
    return m_refIfcProjectList;
}



IfcProjectionCurve *ExpressDataSet::getIfcProjectionCurve(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcProjectionCurve * > (current->second.get());
    }
    else
    {
        IfcProjectionCurve *ret = static_cast< IfcProjectionCurve * > (allocateIfcProjectionCurve(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcProjectionCurve(IfcProjectionCurve *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcProjectionCurve_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcProjectionCurve(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcProjectionCurve *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcProjectionCurve(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcProjectionCurve_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcProjectionCurve > ExpressDataSet::createIfcProjectionCurve(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcProjectionCurve(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcProjectionCurve * > (allocateIfcProjectionCurve(this, Step::Id_UNSET));
    }
}

IfcProjectionCurve *ExpressDataSet::cloneIfcProjectionCurve(ExpressDataSet *expressDataSet, const IfcProjectionCurve &obj, const CopyOp &copyop)
{
    IfcProjectionCurve *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcProjectionCurve(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcProjectionCurve_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcProjectionCurve *ExpressDataSet::cloneIfcProjectionCurve(const IfcProjectionCurve &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcProjectionCurve(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcProjectionCurve(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcProjectionCurve  > &ExpressDataSet::getAllIfcProjectionCurve ()
{
    return m_refIfcProjectionCurveList;
}



IfcProjectionElement *ExpressDataSet::getIfcProjectionElement(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcProjectionElement * > (current->second.get());
    }
    else
    {
        IfcProjectionElement *ret = static_cast< IfcProjectionElement * > (allocateIfcProjectionElement(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcProjectionElement(IfcProjectionElement *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcProjectionElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcProjectionElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcProjectionElement *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcProjectionElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcProjectionElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcProjectionElement > ExpressDataSet::createIfcProjectionElement(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcProjectionElement(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcProjectionElement * > (allocateIfcProjectionElement(this, Step::Id_UNSET));
    }
}

IfcProjectionElement *ExpressDataSet::cloneIfcProjectionElement(ExpressDataSet *expressDataSet, const IfcProjectionElement &obj, const CopyOp &copyop)
{
    IfcProjectionElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcProjectionElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcProjectionElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcProjectionElement *ExpressDataSet::cloneIfcProjectionElement(const IfcProjectionElement &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcProjectionElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcProjectionElement(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcProjectionElement  > &ExpressDataSet::getAllIfcProjectionElement ()
{
    return m_refIfcProjectionElementList;
}



IfcProjectOrder *ExpressDataSet::getIfcProjectOrder(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcProjectOrder * > (current->second.get());
    }
    else
    {
        IfcProjectOrder *ret = static_cast< IfcProjectOrder * > (allocateIfcProjectOrder(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcProjectOrder(IfcProjectOrder *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcProjectOrder_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcProjectOrder(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcProjectOrder *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcProjectOrder(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcProjectOrder_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcProjectOrder > ExpressDataSet::createIfcProjectOrder(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcProjectOrder(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcProjectOrder * > (allocateIfcProjectOrder(this, Step::Id_UNSET));
    }
}

IfcProjectOrder *ExpressDataSet::cloneIfcProjectOrder(ExpressDataSet *expressDataSet, const IfcProjectOrder &obj, const CopyOp &copyop)
{
    IfcProjectOrder *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcProjectOrder(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcProjectOrder_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcProjectOrder *ExpressDataSet::cloneIfcProjectOrder(const IfcProjectOrder &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcProjectOrder(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcProjectOrder(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcProjectOrder  > &ExpressDataSet::getAllIfcProjectOrder ()
{
    return m_refIfcProjectOrderList;
}



IfcProjectOrderRecord *ExpressDataSet::getIfcProjectOrderRecord(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcProjectOrderRecord * > (current->second.get());
    }
    else
    {
        IfcProjectOrderRecord *ret = static_cast< IfcProjectOrderRecord * > (allocateIfcProjectOrderRecord(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcProjectOrderRecord(IfcProjectOrderRecord *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcProjectOrderRecord_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcProjectOrderRecord(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcProjectOrderRecord *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcProjectOrderRecord(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcProjectOrderRecord_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcProjectOrderRecord > ExpressDataSet::createIfcProjectOrderRecord(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcProjectOrderRecord(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcProjectOrderRecord * > (allocateIfcProjectOrderRecord(this, Step::Id_UNSET));
    }
}

IfcProjectOrderRecord *ExpressDataSet::cloneIfcProjectOrderRecord(ExpressDataSet *expressDataSet, const IfcProjectOrderRecord &obj, const CopyOp &copyop)
{
    IfcProjectOrderRecord *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcProjectOrderRecord(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcProjectOrderRecord_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcProjectOrderRecord *ExpressDataSet::cloneIfcProjectOrderRecord(const IfcProjectOrderRecord &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcProjectOrderRecord(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcProjectOrderRecord(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcProjectOrderRecord  > &ExpressDataSet::getAllIfcProjectOrderRecord ()
{
    return m_refIfcProjectOrderRecordList;
}



IfcProperty *ExpressDataSet::getIfcProperty(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcProperty * > (current->second.get());
    }
    else
    {
        IfcProperty *ret = static_cast< IfcProperty * > (allocateIfcProperty(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcProperty(IfcProperty *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcProperty_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcProperty(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcProperty *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcProperty(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcProperty_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcProperty > ExpressDataSet::createIfcProperty(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcProperty(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcProperty * > (allocateIfcProperty(this, Step::Id_UNSET));
    }
}

IfcProperty *ExpressDataSet::cloneIfcProperty(ExpressDataSet *expressDataSet, const IfcProperty &obj, const CopyOp &copyop)
{
    IfcProperty *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcProperty(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcProperty_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcProperty *ExpressDataSet::cloneIfcProperty(const IfcProperty &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcProperty(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcProperty(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcProperty  > &ExpressDataSet::getAllIfcProperty ()
{
    return m_refIfcPropertyList;
}



IfcPropertyBoundedValue *ExpressDataSet::getIfcPropertyBoundedValue(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPropertyBoundedValue * > (current->second.get());
    }
    else
    {
        IfcPropertyBoundedValue *ret = static_cast< IfcPropertyBoundedValue * > (allocateIfcPropertyBoundedValue(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPropertyBoundedValue(IfcPropertyBoundedValue *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPropertyBoundedValue_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPropertyBoundedValue(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPropertyBoundedValue *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPropertyBoundedValue(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPropertyBoundedValue_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPropertyBoundedValue > ExpressDataSet::createIfcPropertyBoundedValue(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPropertyBoundedValue(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPropertyBoundedValue * > (allocateIfcPropertyBoundedValue(this, Step::Id_UNSET));
    }
}

IfcPropertyBoundedValue *ExpressDataSet::cloneIfcPropertyBoundedValue(ExpressDataSet *expressDataSet, const IfcPropertyBoundedValue &obj, const CopyOp &copyop)
{
    IfcPropertyBoundedValue *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPropertyBoundedValue(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPropertyBoundedValue_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPropertyBoundedValue *ExpressDataSet::cloneIfcPropertyBoundedValue(const IfcPropertyBoundedValue &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPropertyBoundedValue(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPropertyBoundedValue(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPropertyBoundedValue  > &ExpressDataSet::getAllIfcPropertyBoundedValue ()
{
    return m_refIfcPropertyBoundedValueList;
}



IfcPropertyConstraintRelationship *ExpressDataSet::getIfcPropertyConstraintRelationship(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPropertyConstraintRelationship * > (current->second.get());
    }
    else
    {
        IfcPropertyConstraintRelationship *ret = static_cast< IfcPropertyConstraintRelationship * > (allocateIfcPropertyConstraintRelationship(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPropertyConstraintRelationship(IfcPropertyConstraintRelationship *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPropertyConstraintRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPropertyConstraintRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPropertyConstraintRelationship *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPropertyConstraintRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPropertyConstraintRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPropertyConstraintRelationship > ExpressDataSet::createIfcPropertyConstraintRelationship(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPropertyConstraintRelationship(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPropertyConstraintRelationship * > (allocateIfcPropertyConstraintRelationship(this, Step::Id_UNSET));
    }
}

IfcPropertyConstraintRelationship *ExpressDataSet::cloneIfcPropertyConstraintRelationship(ExpressDataSet *expressDataSet, const IfcPropertyConstraintRelationship &obj, const CopyOp &copyop)
{
    IfcPropertyConstraintRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPropertyConstraintRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPropertyConstraintRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPropertyConstraintRelationship *ExpressDataSet::cloneIfcPropertyConstraintRelationship(const IfcPropertyConstraintRelationship &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPropertyConstraintRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPropertyConstraintRelationship(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPropertyConstraintRelationship  > &ExpressDataSet::getAllIfcPropertyConstraintRelationship ()
{
    return m_refIfcPropertyConstraintRelationshipList;
}



IfcPropertyDefinition *ExpressDataSet::getIfcPropertyDefinition(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPropertyDefinition * > (current->second.get());
    }
    else
    {
        IfcPropertyDefinition *ret = static_cast< IfcPropertyDefinition * > (allocateIfcPropertyDefinition(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPropertyDefinition(IfcPropertyDefinition *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPropertyDefinition_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPropertyDefinition(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPropertyDefinition *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPropertyDefinition(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPropertyDefinition_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPropertyDefinition > ExpressDataSet::createIfcPropertyDefinition(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPropertyDefinition(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPropertyDefinition * > (allocateIfcPropertyDefinition(this, Step::Id_UNSET));
    }
}

IfcPropertyDefinition *ExpressDataSet::cloneIfcPropertyDefinition(ExpressDataSet *expressDataSet, const IfcPropertyDefinition &obj, const CopyOp &copyop)
{
    IfcPropertyDefinition *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPropertyDefinition(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPropertyDefinition_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPropertyDefinition *ExpressDataSet::cloneIfcPropertyDefinition(const IfcPropertyDefinition &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPropertyDefinition(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPropertyDefinition(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPropertyDefinition  > &ExpressDataSet::getAllIfcPropertyDefinition ()
{
    return m_refIfcPropertyDefinitionList;
}



IfcPropertyDependencyRelationship *ExpressDataSet::getIfcPropertyDependencyRelationship(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPropertyDependencyRelationship * > (current->second.get());
    }
    else
    {
        IfcPropertyDependencyRelationship *ret = static_cast< IfcPropertyDependencyRelationship * > (allocateIfcPropertyDependencyRelationship(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPropertyDependencyRelationship(IfcPropertyDependencyRelationship *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPropertyDependencyRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPropertyDependencyRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPropertyDependencyRelationship *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPropertyDependencyRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPropertyDependencyRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPropertyDependencyRelationship > ExpressDataSet::createIfcPropertyDependencyRelationship(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPropertyDependencyRelationship(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPropertyDependencyRelationship * > (allocateIfcPropertyDependencyRelationship(this, Step::Id_UNSET));
    }
}

IfcPropertyDependencyRelationship *ExpressDataSet::cloneIfcPropertyDependencyRelationship(ExpressDataSet *expressDataSet, const IfcPropertyDependencyRelationship &obj, const CopyOp &copyop)
{
    IfcPropertyDependencyRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPropertyDependencyRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPropertyDependencyRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPropertyDependencyRelationship *ExpressDataSet::cloneIfcPropertyDependencyRelationship(const IfcPropertyDependencyRelationship &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPropertyDependencyRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPropertyDependencyRelationship(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPropertyDependencyRelationship  > &ExpressDataSet::getAllIfcPropertyDependencyRelationship ()
{
    return m_refIfcPropertyDependencyRelationshipList;
}



IfcPropertyEnumeratedValue *ExpressDataSet::getIfcPropertyEnumeratedValue(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPropertyEnumeratedValue * > (current->second.get());
    }
    else
    {
        IfcPropertyEnumeratedValue *ret = static_cast< IfcPropertyEnumeratedValue * > (allocateIfcPropertyEnumeratedValue(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPropertyEnumeratedValue(IfcPropertyEnumeratedValue *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPropertyEnumeratedValue_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPropertyEnumeratedValue(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPropertyEnumeratedValue *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPropertyEnumeratedValue(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPropertyEnumeratedValue_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPropertyEnumeratedValue > ExpressDataSet::createIfcPropertyEnumeratedValue(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPropertyEnumeratedValue(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPropertyEnumeratedValue * > (allocateIfcPropertyEnumeratedValue(this, Step::Id_UNSET));
    }
}

IfcPropertyEnumeratedValue *ExpressDataSet::cloneIfcPropertyEnumeratedValue(ExpressDataSet *expressDataSet, const IfcPropertyEnumeratedValue &obj, const CopyOp &copyop)
{
    IfcPropertyEnumeratedValue *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPropertyEnumeratedValue(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPropertyEnumeratedValue_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPropertyEnumeratedValue *ExpressDataSet::cloneIfcPropertyEnumeratedValue(const IfcPropertyEnumeratedValue &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPropertyEnumeratedValue(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPropertyEnumeratedValue(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPropertyEnumeratedValue  > &ExpressDataSet::getAllIfcPropertyEnumeratedValue ()
{
    return m_refIfcPropertyEnumeratedValueList;
}



IfcPropertyEnumeration *ExpressDataSet::getIfcPropertyEnumeration(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPropertyEnumeration * > (current->second.get());
    }
    else
    {
        IfcPropertyEnumeration *ret = static_cast< IfcPropertyEnumeration * > (allocateIfcPropertyEnumeration(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPropertyEnumeration(IfcPropertyEnumeration *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPropertyEnumeration_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPropertyEnumeration(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPropertyEnumeration *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPropertyEnumeration(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPropertyEnumeration_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPropertyEnumeration > ExpressDataSet::createIfcPropertyEnumeration(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPropertyEnumeration(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPropertyEnumeration * > (allocateIfcPropertyEnumeration(this, Step::Id_UNSET));
    }
}

IfcPropertyEnumeration *ExpressDataSet::cloneIfcPropertyEnumeration(ExpressDataSet *expressDataSet, const IfcPropertyEnumeration &obj, const CopyOp &copyop)
{
    IfcPropertyEnumeration *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPropertyEnumeration(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPropertyEnumeration_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPropertyEnumeration *ExpressDataSet::cloneIfcPropertyEnumeration(const IfcPropertyEnumeration &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPropertyEnumeration(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPropertyEnumeration(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPropertyEnumeration  > &ExpressDataSet::getAllIfcPropertyEnumeration ()
{
    return m_refIfcPropertyEnumerationList;
}



IfcPropertyListValue *ExpressDataSet::getIfcPropertyListValue(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPropertyListValue * > (current->second.get());
    }
    else
    {
        IfcPropertyListValue *ret = static_cast< IfcPropertyListValue * > (allocateIfcPropertyListValue(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPropertyListValue(IfcPropertyListValue *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPropertyListValue_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPropertyListValue(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPropertyListValue *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPropertyListValue(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPropertyListValue_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPropertyListValue > ExpressDataSet::createIfcPropertyListValue(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPropertyListValue(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPropertyListValue * > (allocateIfcPropertyListValue(this, Step::Id_UNSET));
    }
}

IfcPropertyListValue *ExpressDataSet::cloneIfcPropertyListValue(ExpressDataSet *expressDataSet, const IfcPropertyListValue &obj, const CopyOp &copyop)
{
    IfcPropertyListValue *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPropertyListValue(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPropertyListValue_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPropertyListValue *ExpressDataSet::cloneIfcPropertyListValue(const IfcPropertyListValue &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPropertyListValue(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPropertyListValue(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPropertyListValue  > &ExpressDataSet::getAllIfcPropertyListValue ()
{
    return m_refIfcPropertyListValueList;
}



IfcPropertyReferenceValue *ExpressDataSet::getIfcPropertyReferenceValue(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPropertyReferenceValue * > (current->second.get());
    }
    else
    {
        IfcPropertyReferenceValue *ret = static_cast< IfcPropertyReferenceValue * > (allocateIfcPropertyReferenceValue(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPropertyReferenceValue(IfcPropertyReferenceValue *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPropertyReferenceValue_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPropertyReferenceValue(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPropertyReferenceValue *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPropertyReferenceValue(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPropertyReferenceValue_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPropertyReferenceValue > ExpressDataSet::createIfcPropertyReferenceValue(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPropertyReferenceValue(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPropertyReferenceValue * > (allocateIfcPropertyReferenceValue(this, Step::Id_UNSET));
    }
}

IfcPropertyReferenceValue *ExpressDataSet::cloneIfcPropertyReferenceValue(ExpressDataSet *expressDataSet, const IfcPropertyReferenceValue &obj, const CopyOp &copyop)
{
    IfcPropertyReferenceValue *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPropertyReferenceValue(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPropertyReferenceValue_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPropertyReferenceValue *ExpressDataSet::cloneIfcPropertyReferenceValue(const IfcPropertyReferenceValue &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPropertyReferenceValue(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPropertyReferenceValue(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPropertyReferenceValue  > &ExpressDataSet::getAllIfcPropertyReferenceValue ()
{
    return m_refIfcPropertyReferenceValueList;
}



IfcPropertySet *ExpressDataSet::getIfcPropertySet(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPropertySet * > (current->second.get());
    }
    else
    {
        IfcPropertySet *ret = static_cast< IfcPropertySet * > (allocateIfcPropertySet(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPropertySet(IfcPropertySet *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPropertySet_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPropertySet(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPropertySet *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPropertySet(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPropertySet_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPropertySet > ExpressDataSet::createIfcPropertySet(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPropertySet(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPropertySet * > (allocateIfcPropertySet(this, Step::Id_UNSET));
    }
}

IfcPropertySet *ExpressDataSet::cloneIfcPropertySet(ExpressDataSet *expressDataSet, const IfcPropertySet &obj, const CopyOp &copyop)
{
    IfcPropertySet *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPropertySet(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPropertySet_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPropertySet *ExpressDataSet::cloneIfcPropertySet(const IfcPropertySet &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPropertySet(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPropertySet(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPropertySet  > &ExpressDataSet::getAllIfcPropertySet ()
{
    return m_refIfcPropertySetList;
}



IfcPropertySetDefinition *ExpressDataSet::getIfcPropertySetDefinition(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPropertySetDefinition * > (current->second.get());
    }
    else
    {
        IfcPropertySetDefinition *ret = static_cast< IfcPropertySetDefinition * > (allocateIfcPropertySetDefinition(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPropertySetDefinition(IfcPropertySetDefinition *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPropertySetDefinition_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPropertySetDefinition(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPropertySetDefinition *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPropertySetDefinition(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPropertySetDefinition_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPropertySetDefinition > ExpressDataSet::createIfcPropertySetDefinition(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPropertySetDefinition(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPropertySetDefinition * > (allocateIfcPropertySetDefinition(this, Step::Id_UNSET));
    }
}

IfcPropertySetDefinition *ExpressDataSet::cloneIfcPropertySetDefinition(ExpressDataSet *expressDataSet, const IfcPropertySetDefinition &obj, const CopyOp &copyop)
{
    IfcPropertySetDefinition *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPropertySetDefinition(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPropertySetDefinition_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPropertySetDefinition *ExpressDataSet::cloneIfcPropertySetDefinition(const IfcPropertySetDefinition &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPropertySetDefinition(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPropertySetDefinition(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPropertySetDefinition  > &ExpressDataSet::getAllIfcPropertySetDefinition ()
{
    return m_refIfcPropertySetDefinitionList;
}



IfcPropertySingleValue *ExpressDataSet::getIfcPropertySingleValue(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPropertySingleValue * > (current->second.get());
    }
    else
    {
        IfcPropertySingleValue *ret = static_cast< IfcPropertySingleValue * > (allocateIfcPropertySingleValue(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPropertySingleValue(IfcPropertySingleValue *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPropertySingleValue_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPropertySingleValue(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPropertySingleValue *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPropertySingleValue(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPropertySingleValue_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPropertySingleValue > ExpressDataSet::createIfcPropertySingleValue(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPropertySingleValue(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPropertySingleValue * > (allocateIfcPropertySingleValue(this, Step::Id_UNSET));
    }
}

IfcPropertySingleValue *ExpressDataSet::cloneIfcPropertySingleValue(ExpressDataSet *expressDataSet, const IfcPropertySingleValue &obj, const CopyOp &copyop)
{
    IfcPropertySingleValue *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPropertySingleValue(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPropertySingleValue_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPropertySingleValue *ExpressDataSet::cloneIfcPropertySingleValue(const IfcPropertySingleValue &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPropertySingleValue(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPropertySingleValue(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPropertySingleValue  > &ExpressDataSet::getAllIfcPropertySingleValue ()
{
    return m_refIfcPropertySingleValueList;
}



IfcPropertyTableValue *ExpressDataSet::getIfcPropertyTableValue(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPropertyTableValue * > (current->second.get());
    }
    else
    {
        IfcPropertyTableValue *ret = static_cast< IfcPropertyTableValue * > (allocateIfcPropertyTableValue(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPropertyTableValue(IfcPropertyTableValue *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPropertyTableValue_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPropertyTableValue(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPropertyTableValue *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPropertyTableValue(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPropertyTableValue_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPropertyTableValue > ExpressDataSet::createIfcPropertyTableValue(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPropertyTableValue(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPropertyTableValue * > (allocateIfcPropertyTableValue(this, Step::Id_UNSET));
    }
}

IfcPropertyTableValue *ExpressDataSet::cloneIfcPropertyTableValue(ExpressDataSet *expressDataSet, const IfcPropertyTableValue &obj, const CopyOp &copyop)
{
    IfcPropertyTableValue *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPropertyTableValue(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPropertyTableValue_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPropertyTableValue *ExpressDataSet::cloneIfcPropertyTableValue(const IfcPropertyTableValue &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPropertyTableValue(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPropertyTableValue(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPropertyTableValue  > &ExpressDataSet::getAllIfcPropertyTableValue ()
{
    return m_refIfcPropertyTableValueList;
}



IfcProtectiveDeviceType *ExpressDataSet::getIfcProtectiveDeviceType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcProtectiveDeviceType * > (current->second.get());
    }
    else
    {
        IfcProtectiveDeviceType *ret = static_cast< IfcProtectiveDeviceType * > (allocateIfcProtectiveDeviceType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcProtectiveDeviceType(IfcProtectiveDeviceType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcProtectiveDeviceType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcProtectiveDeviceType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcProtectiveDeviceType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcProtectiveDeviceType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcProtectiveDeviceType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcProtectiveDeviceType > ExpressDataSet::createIfcProtectiveDeviceType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcProtectiveDeviceType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcProtectiveDeviceType * > (allocateIfcProtectiveDeviceType(this, Step::Id_UNSET));
    }
}

IfcProtectiveDeviceType *ExpressDataSet::cloneIfcProtectiveDeviceType(ExpressDataSet *expressDataSet, const IfcProtectiveDeviceType &obj, const CopyOp &copyop)
{
    IfcProtectiveDeviceType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcProtectiveDeviceType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcProtectiveDeviceType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcProtectiveDeviceType *ExpressDataSet::cloneIfcProtectiveDeviceType(const IfcProtectiveDeviceType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcProtectiveDeviceType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcProtectiveDeviceType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcProtectiveDeviceType  > &ExpressDataSet::getAllIfcProtectiveDeviceType ()
{
    return m_refIfcProtectiveDeviceTypeList;
}



IfcProxy *ExpressDataSet::getIfcProxy(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcProxy * > (current->second.get());
    }
    else
    {
        IfcProxy *ret = static_cast< IfcProxy * > (allocateIfcProxy(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcProxy(IfcProxy *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcProxy_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcProxy(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcProxy *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcProxy(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcProxy_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcProxy > ExpressDataSet::createIfcProxy(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcProxy(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcProxy * > (allocateIfcProxy(this, Step::Id_UNSET));
    }
}

IfcProxy *ExpressDataSet::cloneIfcProxy(ExpressDataSet *expressDataSet, const IfcProxy &obj, const CopyOp &copyop)
{
    IfcProxy *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcProxy(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcProxy_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcProxy *ExpressDataSet::cloneIfcProxy(const IfcProxy &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcProxy(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcProxy(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcProxy  > &ExpressDataSet::getAllIfcProxy ()
{
    return m_refIfcProxyList;
}



IfcPumpType *ExpressDataSet::getIfcPumpType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcPumpType * > (current->second.get());
    }
    else
    {
        IfcPumpType *ret = static_cast< IfcPumpType * > (allocateIfcPumpType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcPumpType(IfcPumpType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcPumpType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPumpType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcPumpType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPumpType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPumpType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPumpType > ExpressDataSet::createIfcPumpType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcPumpType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcPumpType * > (allocateIfcPumpType(this, Step::Id_UNSET));
    }
}

IfcPumpType *ExpressDataSet::cloneIfcPumpType(ExpressDataSet *expressDataSet, const IfcPumpType &obj, const CopyOp &copyop)
{
    IfcPumpType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPumpType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPumpType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPumpType *ExpressDataSet::cloneIfcPumpType(const IfcPumpType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcPumpType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcPumpType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcPumpType  > &ExpressDataSet::getAllIfcPumpType ()
{
    return m_refIfcPumpTypeList;
}



IfcQuantityArea *ExpressDataSet::getIfcQuantityArea(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcQuantityArea * > (current->second.get());
    }
    else
    {
        IfcQuantityArea *ret = static_cast< IfcQuantityArea * > (allocateIfcQuantityArea(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcQuantityArea(IfcQuantityArea *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcQuantityArea_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcQuantityArea(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcQuantityArea *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcQuantityArea(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcQuantityArea_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcQuantityArea > ExpressDataSet::createIfcQuantityArea(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcQuantityArea(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcQuantityArea * > (allocateIfcQuantityArea(this, Step::Id_UNSET));
    }
}

IfcQuantityArea *ExpressDataSet::cloneIfcQuantityArea(ExpressDataSet *expressDataSet, const IfcQuantityArea &obj, const CopyOp &copyop)
{
    IfcQuantityArea *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcQuantityArea(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcQuantityArea_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcQuantityArea *ExpressDataSet::cloneIfcQuantityArea(const IfcQuantityArea &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcQuantityArea(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcQuantityArea(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcQuantityArea  > &ExpressDataSet::getAllIfcQuantityArea ()
{
    return m_refIfcQuantityAreaList;
}



IfcQuantityCount *ExpressDataSet::getIfcQuantityCount(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcQuantityCount * > (current->second.get());
    }
    else
    {
        IfcQuantityCount *ret = static_cast< IfcQuantityCount * > (allocateIfcQuantityCount(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcQuantityCount(IfcQuantityCount *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcQuantityCount_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcQuantityCount(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcQuantityCount *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcQuantityCount(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcQuantityCount_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcQuantityCount > ExpressDataSet::createIfcQuantityCount(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcQuantityCount(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcQuantityCount * > (allocateIfcQuantityCount(this, Step::Id_UNSET));
    }
}

IfcQuantityCount *ExpressDataSet::cloneIfcQuantityCount(ExpressDataSet *expressDataSet, const IfcQuantityCount &obj, const CopyOp &copyop)
{
    IfcQuantityCount *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcQuantityCount(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcQuantityCount_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcQuantityCount *ExpressDataSet::cloneIfcQuantityCount(const IfcQuantityCount &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcQuantityCount(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcQuantityCount(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcQuantityCount  > &ExpressDataSet::getAllIfcQuantityCount ()
{
    return m_refIfcQuantityCountList;
}



IfcQuantityLength *ExpressDataSet::getIfcQuantityLength(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcQuantityLength * > (current->second.get());
    }
    else
    {
        IfcQuantityLength *ret = static_cast< IfcQuantityLength * > (allocateIfcQuantityLength(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcQuantityLength(IfcQuantityLength *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcQuantityLength_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcQuantityLength(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcQuantityLength *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcQuantityLength(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcQuantityLength_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcQuantityLength > ExpressDataSet::createIfcQuantityLength(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcQuantityLength(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcQuantityLength * > (allocateIfcQuantityLength(this, Step::Id_UNSET));
    }
}

IfcQuantityLength *ExpressDataSet::cloneIfcQuantityLength(ExpressDataSet *expressDataSet, const IfcQuantityLength &obj, const CopyOp &copyop)
{
    IfcQuantityLength *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcQuantityLength(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcQuantityLength_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcQuantityLength *ExpressDataSet::cloneIfcQuantityLength(const IfcQuantityLength &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcQuantityLength(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcQuantityLength(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcQuantityLength  > &ExpressDataSet::getAllIfcQuantityLength ()
{
    return m_refIfcQuantityLengthList;
}



IfcQuantityTime *ExpressDataSet::getIfcQuantityTime(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcQuantityTime * > (current->second.get());
    }
    else
    {
        IfcQuantityTime *ret = static_cast< IfcQuantityTime * > (allocateIfcQuantityTime(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcQuantityTime(IfcQuantityTime *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcQuantityTime_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcQuantityTime(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcQuantityTime *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcQuantityTime(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcQuantityTime_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcQuantityTime > ExpressDataSet::createIfcQuantityTime(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcQuantityTime(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcQuantityTime * > (allocateIfcQuantityTime(this, Step::Id_UNSET));
    }
}

IfcQuantityTime *ExpressDataSet::cloneIfcQuantityTime(ExpressDataSet *expressDataSet, const IfcQuantityTime &obj, const CopyOp &copyop)
{
    IfcQuantityTime *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcQuantityTime(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcQuantityTime_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcQuantityTime *ExpressDataSet::cloneIfcQuantityTime(const IfcQuantityTime &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcQuantityTime(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcQuantityTime(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcQuantityTime  > &ExpressDataSet::getAllIfcQuantityTime ()
{
    return m_refIfcQuantityTimeList;
}



IfcQuantityVolume *ExpressDataSet::getIfcQuantityVolume(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcQuantityVolume * > (current->second.get());
    }
    else
    {
        IfcQuantityVolume *ret = static_cast< IfcQuantityVolume * > (allocateIfcQuantityVolume(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcQuantityVolume(IfcQuantityVolume *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcQuantityVolume_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcQuantityVolume(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcQuantityVolume *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcQuantityVolume(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcQuantityVolume_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcQuantityVolume > ExpressDataSet::createIfcQuantityVolume(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcQuantityVolume(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcQuantityVolume * > (allocateIfcQuantityVolume(this, Step::Id_UNSET));
    }
}

IfcQuantityVolume *ExpressDataSet::cloneIfcQuantityVolume(ExpressDataSet *expressDataSet, const IfcQuantityVolume &obj, const CopyOp &copyop)
{
    IfcQuantityVolume *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcQuantityVolume(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcQuantityVolume_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcQuantityVolume *ExpressDataSet::cloneIfcQuantityVolume(const IfcQuantityVolume &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcQuantityVolume(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcQuantityVolume(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcQuantityVolume  > &ExpressDataSet::getAllIfcQuantityVolume ()
{
    return m_refIfcQuantityVolumeList;
}



IfcQuantityWeight *ExpressDataSet::getIfcQuantityWeight(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcQuantityWeight * > (current->second.get());
    }
    else
    {
        IfcQuantityWeight *ret = static_cast< IfcQuantityWeight * > (allocateIfcQuantityWeight(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcQuantityWeight(IfcQuantityWeight *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcQuantityWeight_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcQuantityWeight(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcQuantityWeight *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcQuantityWeight(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcQuantityWeight_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcQuantityWeight > ExpressDataSet::createIfcQuantityWeight(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcQuantityWeight(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcQuantityWeight * > (allocateIfcQuantityWeight(this, Step::Id_UNSET));
    }
}

IfcQuantityWeight *ExpressDataSet::cloneIfcQuantityWeight(ExpressDataSet *expressDataSet, const IfcQuantityWeight &obj, const CopyOp &copyop)
{
    IfcQuantityWeight *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcQuantityWeight(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcQuantityWeight_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcQuantityWeight *ExpressDataSet::cloneIfcQuantityWeight(const IfcQuantityWeight &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcQuantityWeight(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcQuantityWeight(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcQuantityWeight  > &ExpressDataSet::getAllIfcQuantityWeight ()
{
    return m_refIfcQuantityWeightList;
}



IfcRadiusDimension *ExpressDataSet::getIfcRadiusDimension(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRadiusDimension * > (current->second.get());
    }
    else
    {
        IfcRadiusDimension *ret = static_cast< IfcRadiusDimension * > (allocateIfcRadiusDimension(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRadiusDimension(IfcRadiusDimension *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRadiusDimension_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRadiusDimension(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRadiusDimension *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRadiusDimension(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRadiusDimension_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRadiusDimension > ExpressDataSet::createIfcRadiusDimension(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRadiusDimension(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRadiusDimension * > (allocateIfcRadiusDimension(this, Step::Id_UNSET));
    }
}

IfcRadiusDimension *ExpressDataSet::cloneIfcRadiusDimension(ExpressDataSet *expressDataSet, const IfcRadiusDimension &obj, const CopyOp &copyop)
{
    IfcRadiusDimension *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRadiusDimension(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRadiusDimension_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRadiusDimension *ExpressDataSet::cloneIfcRadiusDimension(const IfcRadiusDimension &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRadiusDimension(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRadiusDimension(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRadiusDimension  > &ExpressDataSet::getAllIfcRadiusDimension ()
{
    return m_refIfcRadiusDimensionList;
}



IfcRailing *ExpressDataSet::getIfcRailing(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRailing * > (current->second.get());
    }
    else
    {
        IfcRailing *ret = static_cast< IfcRailing * > (allocateIfcRailing(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRailing(IfcRailing *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRailing_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRailing(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRailing *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRailing(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRailing_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRailing > ExpressDataSet::createIfcRailing(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRailing(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRailing * > (allocateIfcRailing(this, Step::Id_UNSET));
    }
}

IfcRailing *ExpressDataSet::cloneIfcRailing(ExpressDataSet *expressDataSet, const IfcRailing &obj, const CopyOp &copyop)
{
    IfcRailing *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRailing(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRailing_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRailing *ExpressDataSet::cloneIfcRailing(const IfcRailing &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRailing(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRailing(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRailing  > &ExpressDataSet::getAllIfcRailing ()
{
    return m_refIfcRailingList;
}



IfcRailingType *ExpressDataSet::getIfcRailingType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRailingType * > (current->second.get());
    }
    else
    {
        IfcRailingType *ret = static_cast< IfcRailingType * > (allocateIfcRailingType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRailingType(IfcRailingType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRailingType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRailingType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRailingType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRailingType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRailingType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRailingType > ExpressDataSet::createIfcRailingType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRailingType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRailingType * > (allocateIfcRailingType(this, Step::Id_UNSET));
    }
}

IfcRailingType *ExpressDataSet::cloneIfcRailingType(ExpressDataSet *expressDataSet, const IfcRailingType &obj, const CopyOp &copyop)
{
    IfcRailingType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRailingType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRailingType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRailingType *ExpressDataSet::cloneIfcRailingType(const IfcRailingType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRailingType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRailingType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRailingType  > &ExpressDataSet::getAllIfcRailingType ()
{
    return m_refIfcRailingTypeList;
}



IfcRamp *ExpressDataSet::getIfcRamp(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRamp * > (current->second.get());
    }
    else
    {
        IfcRamp *ret = static_cast< IfcRamp * > (allocateIfcRamp(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRamp(IfcRamp *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRamp_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRamp(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRamp *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRamp(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRamp_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRamp > ExpressDataSet::createIfcRamp(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRamp(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRamp * > (allocateIfcRamp(this, Step::Id_UNSET));
    }
}

IfcRamp *ExpressDataSet::cloneIfcRamp(ExpressDataSet *expressDataSet, const IfcRamp &obj, const CopyOp &copyop)
{
    IfcRamp *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRamp(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRamp_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRamp *ExpressDataSet::cloneIfcRamp(const IfcRamp &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRamp(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRamp(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRamp  > &ExpressDataSet::getAllIfcRamp ()
{
    return m_refIfcRampList;
}



IfcRampFlight *ExpressDataSet::getIfcRampFlight(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRampFlight * > (current->second.get());
    }
    else
    {
        IfcRampFlight *ret = static_cast< IfcRampFlight * > (allocateIfcRampFlight(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRampFlight(IfcRampFlight *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRampFlight_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRampFlight(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRampFlight *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRampFlight(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRampFlight_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRampFlight > ExpressDataSet::createIfcRampFlight(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRampFlight(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRampFlight * > (allocateIfcRampFlight(this, Step::Id_UNSET));
    }
}

IfcRampFlight *ExpressDataSet::cloneIfcRampFlight(ExpressDataSet *expressDataSet, const IfcRampFlight &obj, const CopyOp &copyop)
{
    IfcRampFlight *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRampFlight(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRampFlight_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRampFlight *ExpressDataSet::cloneIfcRampFlight(const IfcRampFlight &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRampFlight(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRampFlight(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRampFlight  > &ExpressDataSet::getAllIfcRampFlight ()
{
    return m_refIfcRampFlightList;
}



IfcRampFlightType *ExpressDataSet::getIfcRampFlightType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRampFlightType * > (current->second.get());
    }
    else
    {
        IfcRampFlightType *ret = static_cast< IfcRampFlightType * > (allocateIfcRampFlightType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRampFlightType(IfcRampFlightType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRampFlightType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRampFlightType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRampFlightType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRampFlightType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRampFlightType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRampFlightType > ExpressDataSet::createIfcRampFlightType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRampFlightType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRampFlightType * > (allocateIfcRampFlightType(this, Step::Id_UNSET));
    }
}

IfcRampFlightType *ExpressDataSet::cloneIfcRampFlightType(ExpressDataSet *expressDataSet, const IfcRampFlightType &obj, const CopyOp &copyop)
{
    IfcRampFlightType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRampFlightType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRampFlightType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRampFlightType *ExpressDataSet::cloneIfcRampFlightType(const IfcRampFlightType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRampFlightType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRampFlightType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRampFlightType  > &ExpressDataSet::getAllIfcRampFlightType ()
{
    return m_refIfcRampFlightTypeList;
}



IfcRationalBezierCurve *ExpressDataSet::getIfcRationalBezierCurve(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRationalBezierCurve * > (current->second.get());
    }
    else
    {
        IfcRationalBezierCurve *ret = static_cast< IfcRationalBezierCurve * > (allocateIfcRationalBezierCurve(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRationalBezierCurve(IfcRationalBezierCurve *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRationalBezierCurve_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRationalBezierCurve(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRationalBezierCurve *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRationalBezierCurve(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRationalBezierCurve_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRationalBezierCurve > ExpressDataSet::createIfcRationalBezierCurve(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRationalBezierCurve(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRationalBezierCurve * > (allocateIfcRationalBezierCurve(this, Step::Id_UNSET));
    }
}

IfcRationalBezierCurve *ExpressDataSet::cloneIfcRationalBezierCurve(ExpressDataSet *expressDataSet, const IfcRationalBezierCurve &obj, const CopyOp &copyop)
{
    IfcRationalBezierCurve *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRationalBezierCurve(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRationalBezierCurve_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRationalBezierCurve *ExpressDataSet::cloneIfcRationalBezierCurve(const IfcRationalBezierCurve &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRationalBezierCurve(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRationalBezierCurve(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRationalBezierCurve  > &ExpressDataSet::getAllIfcRationalBezierCurve ()
{
    return m_refIfcRationalBezierCurveList;
}



IfcRectangleHollowProfileDef *ExpressDataSet::getIfcRectangleHollowProfileDef(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRectangleHollowProfileDef * > (current->second.get());
    }
    else
    {
        IfcRectangleHollowProfileDef *ret = static_cast< IfcRectangleHollowProfileDef * > (allocateIfcRectangleHollowProfileDef(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRectangleHollowProfileDef(IfcRectangleHollowProfileDef *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRectangleHollowProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRectangleHollowProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRectangleHollowProfileDef *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRectangleHollowProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRectangleHollowProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRectangleHollowProfileDef > ExpressDataSet::createIfcRectangleHollowProfileDef(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRectangleHollowProfileDef(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRectangleHollowProfileDef * > (allocateIfcRectangleHollowProfileDef(this, Step::Id_UNSET));
    }
}

IfcRectangleHollowProfileDef *ExpressDataSet::cloneIfcRectangleHollowProfileDef(ExpressDataSet *expressDataSet, const IfcRectangleHollowProfileDef &obj, const CopyOp &copyop)
{
    IfcRectangleHollowProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRectangleHollowProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRectangleHollowProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRectangleHollowProfileDef *ExpressDataSet::cloneIfcRectangleHollowProfileDef(const IfcRectangleHollowProfileDef &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRectangleHollowProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRectangleHollowProfileDef(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRectangleHollowProfileDef  > &ExpressDataSet::getAllIfcRectangleHollowProfileDef ()
{
    return m_refIfcRectangleHollowProfileDefList;
}



IfcRectangleProfileDef *ExpressDataSet::getIfcRectangleProfileDef(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRectangleProfileDef * > (current->second.get());
    }
    else
    {
        IfcRectangleProfileDef *ret = static_cast< IfcRectangleProfileDef * > (allocateIfcRectangleProfileDef(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRectangleProfileDef(IfcRectangleProfileDef *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRectangleProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRectangleProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRectangleProfileDef *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRectangleProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRectangleProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRectangleProfileDef > ExpressDataSet::createIfcRectangleProfileDef(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRectangleProfileDef(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRectangleProfileDef * > (allocateIfcRectangleProfileDef(this, Step::Id_UNSET));
    }
}

IfcRectangleProfileDef *ExpressDataSet::cloneIfcRectangleProfileDef(ExpressDataSet *expressDataSet, const IfcRectangleProfileDef &obj, const CopyOp &copyop)
{
    IfcRectangleProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRectangleProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRectangleProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRectangleProfileDef *ExpressDataSet::cloneIfcRectangleProfileDef(const IfcRectangleProfileDef &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRectangleProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRectangleProfileDef(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRectangleProfileDef  > &ExpressDataSet::getAllIfcRectangleProfileDef ()
{
    return m_refIfcRectangleProfileDefList;
}



IfcRectangularPyramid *ExpressDataSet::getIfcRectangularPyramid(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRectangularPyramid * > (current->second.get());
    }
    else
    {
        IfcRectangularPyramid *ret = static_cast< IfcRectangularPyramid * > (allocateIfcRectangularPyramid(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRectangularPyramid(IfcRectangularPyramid *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRectangularPyramid_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRectangularPyramid(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRectangularPyramid *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRectangularPyramid(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRectangularPyramid_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRectangularPyramid > ExpressDataSet::createIfcRectangularPyramid(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRectangularPyramid(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRectangularPyramid * > (allocateIfcRectangularPyramid(this, Step::Id_UNSET));
    }
}

IfcRectangularPyramid *ExpressDataSet::cloneIfcRectangularPyramid(ExpressDataSet *expressDataSet, const IfcRectangularPyramid &obj, const CopyOp &copyop)
{
    IfcRectangularPyramid *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRectangularPyramid(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRectangularPyramid_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRectangularPyramid *ExpressDataSet::cloneIfcRectangularPyramid(const IfcRectangularPyramid &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRectangularPyramid(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRectangularPyramid(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRectangularPyramid  > &ExpressDataSet::getAllIfcRectangularPyramid ()
{
    return m_refIfcRectangularPyramidList;
}



IfcRectangularTrimmedSurface *ExpressDataSet::getIfcRectangularTrimmedSurface(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRectangularTrimmedSurface * > (current->second.get());
    }
    else
    {
        IfcRectangularTrimmedSurface *ret = static_cast< IfcRectangularTrimmedSurface * > (allocateIfcRectangularTrimmedSurface(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRectangularTrimmedSurface(IfcRectangularTrimmedSurface *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRectangularTrimmedSurface_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRectangularTrimmedSurface(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRectangularTrimmedSurface *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRectangularTrimmedSurface(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRectangularTrimmedSurface_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRectangularTrimmedSurface > ExpressDataSet::createIfcRectangularTrimmedSurface(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRectangularTrimmedSurface(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRectangularTrimmedSurface * > (allocateIfcRectangularTrimmedSurface(this, Step::Id_UNSET));
    }
}

IfcRectangularTrimmedSurface *ExpressDataSet::cloneIfcRectangularTrimmedSurface(ExpressDataSet *expressDataSet, const IfcRectangularTrimmedSurface &obj, const CopyOp &copyop)
{
    IfcRectangularTrimmedSurface *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRectangularTrimmedSurface(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRectangularTrimmedSurface_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRectangularTrimmedSurface *ExpressDataSet::cloneIfcRectangularTrimmedSurface(const IfcRectangularTrimmedSurface &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRectangularTrimmedSurface(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRectangularTrimmedSurface(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRectangularTrimmedSurface  > &ExpressDataSet::getAllIfcRectangularTrimmedSurface ()
{
    return m_refIfcRectangularTrimmedSurfaceList;
}



IfcReferencesValueDocument *ExpressDataSet::getIfcReferencesValueDocument(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcReferencesValueDocument * > (current->second.get());
    }
    else
    {
        IfcReferencesValueDocument *ret = static_cast< IfcReferencesValueDocument * > (allocateIfcReferencesValueDocument(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcReferencesValueDocument(IfcReferencesValueDocument *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcReferencesValueDocument_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcReferencesValueDocument(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcReferencesValueDocument *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcReferencesValueDocument(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcReferencesValueDocument_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcReferencesValueDocument > ExpressDataSet::createIfcReferencesValueDocument(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcReferencesValueDocument(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcReferencesValueDocument * > (allocateIfcReferencesValueDocument(this, Step::Id_UNSET));
    }
}

IfcReferencesValueDocument *ExpressDataSet::cloneIfcReferencesValueDocument(ExpressDataSet *expressDataSet, const IfcReferencesValueDocument &obj, const CopyOp &copyop)
{
    IfcReferencesValueDocument *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcReferencesValueDocument(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcReferencesValueDocument_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcReferencesValueDocument *ExpressDataSet::cloneIfcReferencesValueDocument(const IfcReferencesValueDocument &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcReferencesValueDocument(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcReferencesValueDocument(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcReferencesValueDocument  > &ExpressDataSet::getAllIfcReferencesValueDocument ()
{
    return m_refIfcReferencesValueDocumentList;
}



IfcRegularTimeSeries *ExpressDataSet::getIfcRegularTimeSeries(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRegularTimeSeries * > (current->second.get());
    }
    else
    {
        IfcRegularTimeSeries *ret = static_cast< IfcRegularTimeSeries * > (allocateIfcRegularTimeSeries(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRegularTimeSeries(IfcRegularTimeSeries *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRegularTimeSeries_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRegularTimeSeries(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRegularTimeSeries *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRegularTimeSeries(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRegularTimeSeries_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRegularTimeSeries > ExpressDataSet::createIfcRegularTimeSeries(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRegularTimeSeries(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRegularTimeSeries * > (allocateIfcRegularTimeSeries(this, Step::Id_UNSET));
    }
}

IfcRegularTimeSeries *ExpressDataSet::cloneIfcRegularTimeSeries(ExpressDataSet *expressDataSet, const IfcRegularTimeSeries &obj, const CopyOp &copyop)
{
    IfcRegularTimeSeries *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRegularTimeSeries(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRegularTimeSeries_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRegularTimeSeries *ExpressDataSet::cloneIfcRegularTimeSeries(const IfcRegularTimeSeries &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRegularTimeSeries(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRegularTimeSeries(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRegularTimeSeries  > &ExpressDataSet::getAllIfcRegularTimeSeries ()
{
    return m_refIfcRegularTimeSeriesList;
}



IfcReinforcementBarProperties *ExpressDataSet::getIfcReinforcementBarProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcReinforcementBarProperties * > (current->second.get());
    }
    else
    {
        IfcReinforcementBarProperties *ret = static_cast< IfcReinforcementBarProperties * > (allocateIfcReinforcementBarProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcReinforcementBarProperties(IfcReinforcementBarProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcReinforcementBarProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcReinforcementBarProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcReinforcementBarProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcReinforcementBarProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcReinforcementBarProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcReinforcementBarProperties > ExpressDataSet::createIfcReinforcementBarProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcReinforcementBarProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcReinforcementBarProperties * > (allocateIfcReinforcementBarProperties(this, Step::Id_UNSET));
    }
}

IfcReinforcementBarProperties *ExpressDataSet::cloneIfcReinforcementBarProperties(ExpressDataSet *expressDataSet, const IfcReinforcementBarProperties &obj, const CopyOp &copyop)
{
    IfcReinforcementBarProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcReinforcementBarProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcReinforcementBarProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcReinforcementBarProperties *ExpressDataSet::cloneIfcReinforcementBarProperties(const IfcReinforcementBarProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcReinforcementBarProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcReinforcementBarProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcReinforcementBarProperties  > &ExpressDataSet::getAllIfcReinforcementBarProperties ()
{
    return m_refIfcReinforcementBarPropertiesList;
}



IfcReinforcementDefinitionProperties *ExpressDataSet::getIfcReinforcementDefinitionProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcReinforcementDefinitionProperties * > (current->second.get());
    }
    else
    {
        IfcReinforcementDefinitionProperties *ret = static_cast< IfcReinforcementDefinitionProperties * > (allocateIfcReinforcementDefinitionProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcReinforcementDefinitionProperties(IfcReinforcementDefinitionProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcReinforcementDefinitionProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcReinforcementDefinitionProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcReinforcementDefinitionProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcReinforcementDefinitionProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcReinforcementDefinitionProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcReinforcementDefinitionProperties > ExpressDataSet::createIfcReinforcementDefinitionProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcReinforcementDefinitionProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcReinforcementDefinitionProperties * > (allocateIfcReinforcementDefinitionProperties(this, Step::Id_UNSET));
    }
}

IfcReinforcementDefinitionProperties *ExpressDataSet::cloneIfcReinforcementDefinitionProperties(ExpressDataSet *expressDataSet, const IfcReinforcementDefinitionProperties &obj, const CopyOp &copyop)
{
    IfcReinforcementDefinitionProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcReinforcementDefinitionProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcReinforcementDefinitionProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcReinforcementDefinitionProperties *ExpressDataSet::cloneIfcReinforcementDefinitionProperties(const IfcReinforcementDefinitionProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcReinforcementDefinitionProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcReinforcementDefinitionProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcReinforcementDefinitionProperties  > &ExpressDataSet::getAllIfcReinforcementDefinitionProperties ()
{
    return m_refIfcReinforcementDefinitionPropertiesList;
}



IfcReinforcingBar *ExpressDataSet::getIfcReinforcingBar(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcReinforcingBar * > (current->second.get());
    }
    else
    {
        IfcReinforcingBar *ret = static_cast< IfcReinforcingBar * > (allocateIfcReinforcingBar(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcReinforcingBar(IfcReinforcingBar *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcReinforcingBar_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcReinforcingBar(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcReinforcingBar *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcReinforcingBar(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcReinforcingBar_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcReinforcingBar > ExpressDataSet::createIfcReinforcingBar(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcReinforcingBar(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcReinforcingBar * > (allocateIfcReinforcingBar(this, Step::Id_UNSET));
    }
}

IfcReinforcingBar *ExpressDataSet::cloneIfcReinforcingBar(ExpressDataSet *expressDataSet, const IfcReinforcingBar &obj, const CopyOp &copyop)
{
    IfcReinforcingBar *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcReinforcingBar(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcReinforcingBar_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcReinforcingBar *ExpressDataSet::cloneIfcReinforcingBar(const IfcReinforcingBar &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcReinforcingBar(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcReinforcingBar(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcReinforcingBar  > &ExpressDataSet::getAllIfcReinforcingBar ()
{
    return m_refIfcReinforcingBarList;
}



IfcReinforcingElement *ExpressDataSet::getIfcReinforcingElement(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcReinforcingElement * > (current->second.get());
    }
    else
    {
        IfcReinforcingElement *ret = static_cast< IfcReinforcingElement * > (allocateIfcReinforcingElement(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcReinforcingElement(IfcReinforcingElement *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcReinforcingElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcReinforcingElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcReinforcingElement *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcReinforcingElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcReinforcingElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcReinforcingElement > ExpressDataSet::createIfcReinforcingElement(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcReinforcingElement(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcReinforcingElement * > (allocateIfcReinforcingElement(this, Step::Id_UNSET));
    }
}

IfcReinforcingElement *ExpressDataSet::cloneIfcReinforcingElement(ExpressDataSet *expressDataSet, const IfcReinforcingElement &obj, const CopyOp &copyop)
{
    IfcReinforcingElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcReinforcingElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcReinforcingElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcReinforcingElement *ExpressDataSet::cloneIfcReinforcingElement(const IfcReinforcingElement &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcReinforcingElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcReinforcingElement(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcReinforcingElement  > &ExpressDataSet::getAllIfcReinforcingElement ()
{
    return m_refIfcReinforcingElementList;
}



IfcReinforcingMesh *ExpressDataSet::getIfcReinforcingMesh(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcReinforcingMesh * > (current->second.get());
    }
    else
    {
        IfcReinforcingMesh *ret = static_cast< IfcReinforcingMesh * > (allocateIfcReinforcingMesh(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcReinforcingMesh(IfcReinforcingMesh *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcReinforcingMesh_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcReinforcingMesh(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcReinforcingMesh *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcReinforcingMesh(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcReinforcingMesh_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcReinforcingMesh > ExpressDataSet::createIfcReinforcingMesh(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcReinforcingMesh(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcReinforcingMesh * > (allocateIfcReinforcingMesh(this, Step::Id_UNSET));
    }
}

IfcReinforcingMesh *ExpressDataSet::cloneIfcReinforcingMesh(ExpressDataSet *expressDataSet, const IfcReinforcingMesh &obj, const CopyOp &copyop)
{
    IfcReinforcingMesh *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcReinforcingMesh(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcReinforcingMesh_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcReinforcingMesh *ExpressDataSet::cloneIfcReinforcingMesh(const IfcReinforcingMesh &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcReinforcingMesh(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcReinforcingMesh(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcReinforcingMesh  > &ExpressDataSet::getAllIfcReinforcingMesh ()
{
    return m_refIfcReinforcingMeshList;
}



IfcRelAggregates *ExpressDataSet::getIfcRelAggregates(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelAggregates * > (current->second.get());
    }
    else
    {
        IfcRelAggregates *ret = static_cast< IfcRelAggregates * > (allocateIfcRelAggregates(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelAggregates(IfcRelAggregates *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelAggregates_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAggregates(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelAggregates *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAggregates(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAggregates_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAggregates > ExpressDataSet::createIfcRelAggregates(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelAggregates(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelAggregates * > (allocateIfcRelAggregates(this, Step::Id_UNSET));
    }
}

IfcRelAggregates *ExpressDataSet::cloneIfcRelAggregates(ExpressDataSet *expressDataSet, const IfcRelAggregates &obj, const CopyOp &copyop)
{
    IfcRelAggregates *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAggregates(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAggregates_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAggregates *ExpressDataSet::cloneIfcRelAggregates(const IfcRelAggregates &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelAggregates(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelAggregates(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelAggregates  > &ExpressDataSet::getAllIfcRelAggregates ()
{
    return m_refIfcRelAggregatesList;
}



IfcRelAssigns *ExpressDataSet::getIfcRelAssigns(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelAssigns * > (current->second.get());
    }
    else
    {
        IfcRelAssigns *ret = static_cast< IfcRelAssigns * > (allocateIfcRelAssigns(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelAssigns(IfcRelAssigns *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelAssigns_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssigns(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelAssigns *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssigns(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssigns_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssigns > ExpressDataSet::createIfcRelAssigns(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelAssigns(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelAssigns * > (allocateIfcRelAssigns(this, Step::Id_UNSET));
    }
}

IfcRelAssigns *ExpressDataSet::cloneIfcRelAssigns(ExpressDataSet *expressDataSet, const IfcRelAssigns &obj, const CopyOp &copyop)
{
    IfcRelAssigns *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssigns(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssigns_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssigns *ExpressDataSet::cloneIfcRelAssigns(const IfcRelAssigns &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelAssigns(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelAssigns(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelAssigns  > &ExpressDataSet::getAllIfcRelAssigns ()
{
    return m_refIfcRelAssignsList;
}



IfcRelAssignsTasks *ExpressDataSet::getIfcRelAssignsTasks(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelAssignsTasks * > (current->second.get());
    }
    else
    {
        IfcRelAssignsTasks *ret = static_cast< IfcRelAssignsTasks * > (allocateIfcRelAssignsTasks(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelAssignsTasks(IfcRelAssignsTasks *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelAssignsTasks_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssignsTasks(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelAssignsTasks *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssignsTasks(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssignsTasks_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssignsTasks > ExpressDataSet::createIfcRelAssignsTasks(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelAssignsTasks(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelAssignsTasks * > (allocateIfcRelAssignsTasks(this, Step::Id_UNSET));
    }
}

IfcRelAssignsTasks *ExpressDataSet::cloneIfcRelAssignsTasks(ExpressDataSet *expressDataSet, const IfcRelAssignsTasks &obj, const CopyOp &copyop)
{
    IfcRelAssignsTasks *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssignsTasks(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssignsTasks_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssignsTasks *ExpressDataSet::cloneIfcRelAssignsTasks(const IfcRelAssignsTasks &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelAssignsTasks(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelAssignsTasks(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelAssignsTasks  > &ExpressDataSet::getAllIfcRelAssignsTasks ()
{
    return m_refIfcRelAssignsTasksList;
}



IfcRelAssignsToActor *ExpressDataSet::getIfcRelAssignsToActor(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelAssignsToActor * > (current->second.get());
    }
    else
    {
        IfcRelAssignsToActor *ret = static_cast< IfcRelAssignsToActor * > (allocateIfcRelAssignsToActor(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelAssignsToActor(IfcRelAssignsToActor *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelAssignsToActor_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssignsToActor(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelAssignsToActor *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssignsToActor(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssignsToActor_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssignsToActor > ExpressDataSet::createIfcRelAssignsToActor(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelAssignsToActor(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelAssignsToActor * > (allocateIfcRelAssignsToActor(this, Step::Id_UNSET));
    }
}

IfcRelAssignsToActor *ExpressDataSet::cloneIfcRelAssignsToActor(ExpressDataSet *expressDataSet, const IfcRelAssignsToActor &obj, const CopyOp &copyop)
{
    IfcRelAssignsToActor *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssignsToActor(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssignsToActor_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssignsToActor *ExpressDataSet::cloneIfcRelAssignsToActor(const IfcRelAssignsToActor &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelAssignsToActor(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelAssignsToActor(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelAssignsToActor  > &ExpressDataSet::getAllIfcRelAssignsToActor ()
{
    return m_refIfcRelAssignsToActorList;
}



IfcRelAssignsToControl *ExpressDataSet::getIfcRelAssignsToControl(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelAssignsToControl * > (current->second.get());
    }
    else
    {
        IfcRelAssignsToControl *ret = static_cast< IfcRelAssignsToControl * > (allocateIfcRelAssignsToControl(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelAssignsToControl(IfcRelAssignsToControl *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelAssignsToControl_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssignsToControl(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelAssignsToControl *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssignsToControl(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssignsToControl_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssignsToControl > ExpressDataSet::createIfcRelAssignsToControl(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelAssignsToControl(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelAssignsToControl * > (allocateIfcRelAssignsToControl(this, Step::Id_UNSET));
    }
}

IfcRelAssignsToControl *ExpressDataSet::cloneIfcRelAssignsToControl(ExpressDataSet *expressDataSet, const IfcRelAssignsToControl &obj, const CopyOp &copyop)
{
    IfcRelAssignsToControl *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssignsToControl(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssignsToControl_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssignsToControl *ExpressDataSet::cloneIfcRelAssignsToControl(const IfcRelAssignsToControl &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelAssignsToControl(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelAssignsToControl(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelAssignsToControl  > &ExpressDataSet::getAllIfcRelAssignsToControl ()
{
    return m_refIfcRelAssignsToControlList;
}



IfcRelAssignsToGroup *ExpressDataSet::getIfcRelAssignsToGroup(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelAssignsToGroup * > (current->second.get());
    }
    else
    {
        IfcRelAssignsToGroup *ret = static_cast< IfcRelAssignsToGroup * > (allocateIfcRelAssignsToGroup(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelAssignsToGroup(IfcRelAssignsToGroup *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelAssignsToGroup_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssignsToGroup(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelAssignsToGroup *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssignsToGroup(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssignsToGroup_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssignsToGroup > ExpressDataSet::createIfcRelAssignsToGroup(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelAssignsToGroup(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelAssignsToGroup * > (allocateIfcRelAssignsToGroup(this, Step::Id_UNSET));
    }
}

IfcRelAssignsToGroup *ExpressDataSet::cloneIfcRelAssignsToGroup(ExpressDataSet *expressDataSet, const IfcRelAssignsToGroup &obj, const CopyOp &copyop)
{
    IfcRelAssignsToGroup *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssignsToGroup(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssignsToGroup_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssignsToGroup *ExpressDataSet::cloneIfcRelAssignsToGroup(const IfcRelAssignsToGroup &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelAssignsToGroup(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelAssignsToGroup(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelAssignsToGroup  > &ExpressDataSet::getAllIfcRelAssignsToGroup ()
{
    return m_refIfcRelAssignsToGroupList;
}



IfcRelAssignsToProcess *ExpressDataSet::getIfcRelAssignsToProcess(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelAssignsToProcess * > (current->second.get());
    }
    else
    {
        IfcRelAssignsToProcess *ret = static_cast< IfcRelAssignsToProcess * > (allocateIfcRelAssignsToProcess(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelAssignsToProcess(IfcRelAssignsToProcess *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelAssignsToProcess_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssignsToProcess(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelAssignsToProcess *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssignsToProcess(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssignsToProcess_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssignsToProcess > ExpressDataSet::createIfcRelAssignsToProcess(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelAssignsToProcess(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelAssignsToProcess * > (allocateIfcRelAssignsToProcess(this, Step::Id_UNSET));
    }
}

IfcRelAssignsToProcess *ExpressDataSet::cloneIfcRelAssignsToProcess(ExpressDataSet *expressDataSet, const IfcRelAssignsToProcess &obj, const CopyOp &copyop)
{
    IfcRelAssignsToProcess *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssignsToProcess(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssignsToProcess_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssignsToProcess *ExpressDataSet::cloneIfcRelAssignsToProcess(const IfcRelAssignsToProcess &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelAssignsToProcess(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelAssignsToProcess(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelAssignsToProcess  > &ExpressDataSet::getAllIfcRelAssignsToProcess ()
{
    return m_refIfcRelAssignsToProcessList;
}



IfcRelAssignsToProduct *ExpressDataSet::getIfcRelAssignsToProduct(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelAssignsToProduct * > (current->second.get());
    }
    else
    {
        IfcRelAssignsToProduct *ret = static_cast< IfcRelAssignsToProduct * > (allocateIfcRelAssignsToProduct(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelAssignsToProduct(IfcRelAssignsToProduct *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelAssignsToProduct_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssignsToProduct(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelAssignsToProduct *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssignsToProduct(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssignsToProduct_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssignsToProduct > ExpressDataSet::createIfcRelAssignsToProduct(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelAssignsToProduct(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelAssignsToProduct * > (allocateIfcRelAssignsToProduct(this, Step::Id_UNSET));
    }
}

IfcRelAssignsToProduct *ExpressDataSet::cloneIfcRelAssignsToProduct(ExpressDataSet *expressDataSet, const IfcRelAssignsToProduct &obj, const CopyOp &copyop)
{
    IfcRelAssignsToProduct *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssignsToProduct(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssignsToProduct_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssignsToProduct *ExpressDataSet::cloneIfcRelAssignsToProduct(const IfcRelAssignsToProduct &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelAssignsToProduct(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelAssignsToProduct(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelAssignsToProduct  > &ExpressDataSet::getAllIfcRelAssignsToProduct ()
{
    return m_refIfcRelAssignsToProductList;
}



IfcRelAssignsToProjectOrder *ExpressDataSet::getIfcRelAssignsToProjectOrder(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelAssignsToProjectOrder * > (current->second.get());
    }
    else
    {
        IfcRelAssignsToProjectOrder *ret = static_cast< IfcRelAssignsToProjectOrder * > (allocateIfcRelAssignsToProjectOrder(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelAssignsToProjectOrder(IfcRelAssignsToProjectOrder *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelAssignsToProjectOrder_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssignsToProjectOrder(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelAssignsToProjectOrder *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssignsToProjectOrder(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssignsToProjectOrder_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssignsToProjectOrder > ExpressDataSet::createIfcRelAssignsToProjectOrder(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelAssignsToProjectOrder(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelAssignsToProjectOrder * > (allocateIfcRelAssignsToProjectOrder(this, Step::Id_UNSET));
    }
}

IfcRelAssignsToProjectOrder *ExpressDataSet::cloneIfcRelAssignsToProjectOrder(ExpressDataSet *expressDataSet, const IfcRelAssignsToProjectOrder &obj, const CopyOp &copyop)
{
    IfcRelAssignsToProjectOrder *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssignsToProjectOrder(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssignsToProjectOrder_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssignsToProjectOrder *ExpressDataSet::cloneIfcRelAssignsToProjectOrder(const IfcRelAssignsToProjectOrder &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelAssignsToProjectOrder(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelAssignsToProjectOrder(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelAssignsToProjectOrder  > &ExpressDataSet::getAllIfcRelAssignsToProjectOrder ()
{
    return m_refIfcRelAssignsToProjectOrderList;
}



IfcRelAssignsToResource *ExpressDataSet::getIfcRelAssignsToResource(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelAssignsToResource * > (current->second.get());
    }
    else
    {
        IfcRelAssignsToResource *ret = static_cast< IfcRelAssignsToResource * > (allocateIfcRelAssignsToResource(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelAssignsToResource(IfcRelAssignsToResource *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelAssignsToResource_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssignsToResource(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelAssignsToResource *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssignsToResource(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssignsToResource_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssignsToResource > ExpressDataSet::createIfcRelAssignsToResource(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelAssignsToResource(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelAssignsToResource * > (allocateIfcRelAssignsToResource(this, Step::Id_UNSET));
    }
}

IfcRelAssignsToResource *ExpressDataSet::cloneIfcRelAssignsToResource(ExpressDataSet *expressDataSet, const IfcRelAssignsToResource &obj, const CopyOp &copyop)
{
    IfcRelAssignsToResource *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssignsToResource(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssignsToResource_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssignsToResource *ExpressDataSet::cloneIfcRelAssignsToResource(const IfcRelAssignsToResource &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelAssignsToResource(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelAssignsToResource(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelAssignsToResource  > &ExpressDataSet::getAllIfcRelAssignsToResource ()
{
    return m_refIfcRelAssignsToResourceList;
}



IfcRelAssociates *ExpressDataSet::getIfcRelAssociates(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelAssociates * > (current->second.get());
    }
    else
    {
        IfcRelAssociates *ret = static_cast< IfcRelAssociates * > (allocateIfcRelAssociates(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelAssociates(IfcRelAssociates *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelAssociates_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssociates(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelAssociates *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssociates(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssociates_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssociates > ExpressDataSet::createIfcRelAssociates(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelAssociates(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelAssociates * > (allocateIfcRelAssociates(this, Step::Id_UNSET));
    }
}

IfcRelAssociates *ExpressDataSet::cloneIfcRelAssociates(ExpressDataSet *expressDataSet, const IfcRelAssociates &obj, const CopyOp &copyop)
{
    IfcRelAssociates *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssociates(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssociates_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssociates *ExpressDataSet::cloneIfcRelAssociates(const IfcRelAssociates &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelAssociates(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelAssociates(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelAssociates  > &ExpressDataSet::getAllIfcRelAssociates ()
{
    return m_refIfcRelAssociatesList;
}



IfcRelAssociatesAppliedValue *ExpressDataSet::getIfcRelAssociatesAppliedValue(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelAssociatesAppliedValue * > (current->second.get());
    }
    else
    {
        IfcRelAssociatesAppliedValue *ret = static_cast< IfcRelAssociatesAppliedValue * > (allocateIfcRelAssociatesAppliedValue(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelAssociatesAppliedValue(IfcRelAssociatesAppliedValue *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelAssociatesAppliedValue_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssociatesAppliedValue(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelAssociatesAppliedValue *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssociatesAppliedValue(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssociatesAppliedValue_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssociatesAppliedValue > ExpressDataSet::createIfcRelAssociatesAppliedValue(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelAssociatesAppliedValue(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelAssociatesAppliedValue * > (allocateIfcRelAssociatesAppliedValue(this, Step::Id_UNSET));
    }
}

IfcRelAssociatesAppliedValue *ExpressDataSet::cloneIfcRelAssociatesAppliedValue(ExpressDataSet *expressDataSet, const IfcRelAssociatesAppliedValue &obj, const CopyOp &copyop)
{
    IfcRelAssociatesAppliedValue *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssociatesAppliedValue(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssociatesAppliedValue_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssociatesAppliedValue *ExpressDataSet::cloneIfcRelAssociatesAppliedValue(const IfcRelAssociatesAppliedValue &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelAssociatesAppliedValue(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelAssociatesAppliedValue(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelAssociatesAppliedValue  > &ExpressDataSet::getAllIfcRelAssociatesAppliedValue ()
{
    return m_refIfcRelAssociatesAppliedValueList;
}



IfcRelAssociatesApproval *ExpressDataSet::getIfcRelAssociatesApproval(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelAssociatesApproval * > (current->second.get());
    }
    else
    {
        IfcRelAssociatesApproval *ret = static_cast< IfcRelAssociatesApproval * > (allocateIfcRelAssociatesApproval(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelAssociatesApproval(IfcRelAssociatesApproval *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelAssociatesApproval_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssociatesApproval(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelAssociatesApproval *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssociatesApproval(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssociatesApproval_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssociatesApproval > ExpressDataSet::createIfcRelAssociatesApproval(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelAssociatesApproval(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelAssociatesApproval * > (allocateIfcRelAssociatesApproval(this, Step::Id_UNSET));
    }
}

IfcRelAssociatesApproval *ExpressDataSet::cloneIfcRelAssociatesApproval(ExpressDataSet *expressDataSet, const IfcRelAssociatesApproval &obj, const CopyOp &copyop)
{
    IfcRelAssociatesApproval *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssociatesApproval(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssociatesApproval_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssociatesApproval *ExpressDataSet::cloneIfcRelAssociatesApproval(const IfcRelAssociatesApproval &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelAssociatesApproval(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelAssociatesApproval(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelAssociatesApproval  > &ExpressDataSet::getAllIfcRelAssociatesApproval ()
{
    return m_refIfcRelAssociatesApprovalList;
}



IfcRelAssociatesClassification *ExpressDataSet::getIfcRelAssociatesClassification(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelAssociatesClassification * > (current->second.get());
    }
    else
    {
        IfcRelAssociatesClassification *ret = static_cast< IfcRelAssociatesClassification * > (allocateIfcRelAssociatesClassification(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelAssociatesClassification(IfcRelAssociatesClassification *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelAssociatesClassification_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssociatesClassification(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelAssociatesClassification *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssociatesClassification(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssociatesClassification_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssociatesClassification > ExpressDataSet::createIfcRelAssociatesClassification(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelAssociatesClassification(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelAssociatesClassification * > (allocateIfcRelAssociatesClassification(this, Step::Id_UNSET));
    }
}

IfcRelAssociatesClassification *ExpressDataSet::cloneIfcRelAssociatesClassification(ExpressDataSet *expressDataSet, const IfcRelAssociatesClassification &obj, const CopyOp &copyop)
{
    IfcRelAssociatesClassification *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssociatesClassification(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssociatesClassification_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssociatesClassification *ExpressDataSet::cloneIfcRelAssociatesClassification(const IfcRelAssociatesClassification &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelAssociatesClassification(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelAssociatesClassification(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelAssociatesClassification  > &ExpressDataSet::getAllIfcRelAssociatesClassification ()
{
    return m_refIfcRelAssociatesClassificationList;
}



IfcRelAssociatesConstraint *ExpressDataSet::getIfcRelAssociatesConstraint(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelAssociatesConstraint * > (current->second.get());
    }
    else
    {
        IfcRelAssociatesConstraint *ret = static_cast< IfcRelAssociatesConstraint * > (allocateIfcRelAssociatesConstraint(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelAssociatesConstraint(IfcRelAssociatesConstraint *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelAssociatesConstraint_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssociatesConstraint(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelAssociatesConstraint *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssociatesConstraint(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssociatesConstraint_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssociatesConstraint > ExpressDataSet::createIfcRelAssociatesConstraint(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelAssociatesConstraint(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelAssociatesConstraint * > (allocateIfcRelAssociatesConstraint(this, Step::Id_UNSET));
    }
}

IfcRelAssociatesConstraint *ExpressDataSet::cloneIfcRelAssociatesConstraint(ExpressDataSet *expressDataSet, const IfcRelAssociatesConstraint &obj, const CopyOp &copyop)
{
    IfcRelAssociatesConstraint *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssociatesConstraint(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssociatesConstraint_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssociatesConstraint *ExpressDataSet::cloneIfcRelAssociatesConstraint(const IfcRelAssociatesConstraint &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelAssociatesConstraint(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelAssociatesConstraint(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelAssociatesConstraint  > &ExpressDataSet::getAllIfcRelAssociatesConstraint ()
{
    return m_refIfcRelAssociatesConstraintList;
}



IfcRelAssociatesDocument *ExpressDataSet::getIfcRelAssociatesDocument(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelAssociatesDocument * > (current->second.get());
    }
    else
    {
        IfcRelAssociatesDocument *ret = static_cast< IfcRelAssociatesDocument * > (allocateIfcRelAssociatesDocument(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelAssociatesDocument(IfcRelAssociatesDocument *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelAssociatesDocument_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssociatesDocument(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelAssociatesDocument *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssociatesDocument(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssociatesDocument_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssociatesDocument > ExpressDataSet::createIfcRelAssociatesDocument(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelAssociatesDocument(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelAssociatesDocument * > (allocateIfcRelAssociatesDocument(this, Step::Id_UNSET));
    }
}

IfcRelAssociatesDocument *ExpressDataSet::cloneIfcRelAssociatesDocument(ExpressDataSet *expressDataSet, const IfcRelAssociatesDocument &obj, const CopyOp &copyop)
{
    IfcRelAssociatesDocument *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssociatesDocument(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssociatesDocument_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssociatesDocument *ExpressDataSet::cloneIfcRelAssociatesDocument(const IfcRelAssociatesDocument &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelAssociatesDocument(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelAssociatesDocument(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelAssociatesDocument  > &ExpressDataSet::getAllIfcRelAssociatesDocument ()
{
    return m_refIfcRelAssociatesDocumentList;
}



IfcRelAssociatesLibrary *ExpressDataSet::getIfcRelAssociatesLibrary(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelAssociatesLibrary * > (current->second.get());
    }
    else
    {
        IfcRelAssociatesLibrary *ret = static_cast< IfcRelAssociatesLibrary * > (allocateIfcRelAssociatesLibrary(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelAssociatesLibrary(IfcRelAssociatesLibrary *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelAssociatesLibrary_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssociatesLibrary(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelAssociatesLibrary *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssociatesLibrary(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssociatesLibrary_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssociatesLibrary > ExpressDataSet::createIfcRelAssociatesLibrary(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelAssociatesLibrary(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelAssociatesLibrary * > (allocateIfcRelAssociatesLibrary(this, Step::Id_UNSET));
    }
}

IfcRelAssociatesLibrary *ExpressDataSet::cloneIfcRelAssociatesLibrary(ExpressDataSet *expressDataSet, const IfcRelAssociatesLibrary &obj, const CopyOp &copyop)
{
    IfcRelAssociatesLibrary *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssociatesLibrary(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssociatesLibrary_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssociatesLibrary *ExpressDataSet::cloneIfcRelAssociatesLibrary(const IfcRelAssociatesLibrary &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelAssociatesLibrary(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelAssociatesLibrary(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelAssociatesLibrary  > &ExpressDataSet::getAllIfcRelAssociatesLibrary ()
{
    return m_refIfcRelAssociatesLibraryList;
}



IfcRelAssociatesMaterial *ExpressDataSet::getIfcRelAssociatesMaterial(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelAssociatesMaterial * > (current->second.get());
    }
    else
    {
        IfcRelAssociatesMaterial *ret = static_cast< IfcRelAssociatesMaterial * > (allocateIfcRelAssociatesMaterial(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelAssociatesMaterial(IfcRelAssociatesMaterial *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelAssociatesMaterial_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssociatesMaterial(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelAssociatesMaterial *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssociatesMaterial(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssociatesMaterial_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssociatesMaterial > ExpressDataSet::createIfcRelAssociatesMaterial(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelAssociatesMaterial(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelAssociatesMaterial * > (allocateIfcRelAssociatesMaterial(this, Step::Id_UNSET));
    }
}

IfcRelAssociatesMaterial *ExpressDataSet::cloneIfcRelAssociatesMaterial(ExpressDataSet *expressDataSet, const IfcRelAssociatesMaterial &obj, const CopyOp &copyop)
{
    IfcRelAssociatesMaterial *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssociatesMaterial(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssociatesMaterial_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssociatesMaterial *ExpressDataSet::cloneIfcRelAssociatesMaterial(const IfcRelAssociatesMaterial &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelAssociatesMaterial(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelAssociatesMaterial(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelAssociatesMaterial  > &ExpressDataSet::getAllIfcRelAssociatesMaterial ()
{
    return m_refIfcRelAssociatesMaterialList;
}



IfcRelAssociatesProfileProperties *ExpressDataSet::getIfcRelAssociatesProfileProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelAssociatesProfileProperties * > (current->second.get());
    }
    else
    {
        IfcRelAssociatesProfileProperties *ret = static_cast< IfcRelAssociatesProfileProperties * > (allocateIfcRelAssociatesProfileProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelAssociatesProfileProperties(IfcRelAssociatesProfileProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelAssociatesProfileProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssociatesProfileProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelAssociatesProfileProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssociatesProfileProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssociatesProfileProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssociatesProfileProperties > ExpressDataSet::createIfcRelAssociatesProfileProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelAssociatesProfileProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelAssociatesProfileProperties * > (allocateIfcRelAssociatesProfileProperties(this, Step::Id_UNSET));
    }
}

IfcRelAssociatesProfileProperties *ExpressDataSet::cloneIfcRelAssociatesProfileProperties(ExpressDataSet *expressDataSet, const IfcRelAssociatesProfileProperties &obj, const CopyOp &copyop)
{
    IfcRelAssociatesProfileProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssociatesProfileProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssociatesProfileProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssociatesProfileProperties *ExpressDataSet::cloneIfcRelAssociatesProfileProperties(const IfcRelAssociatesProfileProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelAssociatesProfileProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelAssociatesProfileProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelAssociatesProfileProperties  > &ExpressDataSet::getAllIfcRelAssociatesProfileProperties ()
{
    return m_refIfcRelAssociatesProfilePropertiesList;
}



IfcRelationship *ExpressDataSet::getIfcRelationship(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelationship * > (current->second.get());
    }
    else
    {
        IfcRelationship *ret = static_cast< IfcRelationship * > (allocateIfcRelationship(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelationship(IfcRelationship *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelationship *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelationship > ExpressDataSet::createIfcRelationship(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelationship(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelationship * > (allocateIfcRelationship(this, Step::Id_UNSET));
    }
}

IfcRelationship *ExpressDataSet::cloneIfcRelationship(ExpressDataSet *expressDataSet, const IfcRelationship &obj, const CopyOp &copyop)
{
    IfcRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelationship *ExpressDataSet::cloneIfcRelationship(const IfcRelationship &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelationship(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelationship  > &ExpressDataSet::getAllIfcRelationship ()
{
    return m_refIfcRelationshipList;
}



IfcRelaxation *ExpressDataSet::getIfcRelaxation(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelaxation * > (current->second.get());
    }
    else
    {
        IfcRelaxation *ret = static_cast< IfcRelaxation * > (allocateIfcRelaxation(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelaxation(IfcRelaxation *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelaxation_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelaxation(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelaxation *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelaxation(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelaxation_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelaxation > ExpressDataSet::createIfcRelaxation(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelaxation(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelaxation * > (allocateIfcRelaxation(this, Step::Id_UNSET));
    }
}

IfcRelaxation *ExpressDataSet::cloneIfcRelaxation(ExpressDataSet *expressDataSet, const IfcRelaxation &obj, const CopyOp &copyop)
{
    IfcRelaxation *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelaxation(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelaxation_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelaxation *ExpressDataSet::cloneIfcRelaxation(const IfcRelaxation &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelaxation(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelaxation(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelaxation  > &ExpressDataSet::getAllIfcRelaxation ()
{
    return m_refIfcRelaxationList;
}



IfcRelConnects *ExpressDataSet::getIfcRelConnects(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelConnects * > (current->second.get());
    }
    else
    {
        IfcRelConnects *ret = static_cast< IfcRelConnects * > (allocateIfcRelConnects(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelConnects(IfcRelConnects *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelConnects_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelConnects(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelConnects *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelConnects(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelConnects_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelConnects > ExpressDataSet::createIfcRelConnects(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelConnects(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelConnects * > (allocateIfcRelConnects(this, Step::Id_UNSET));
    }
}

IfcRelConnects *ExpressDataSet::cloneIfcRelConnects(ExpressDataSet *expressDataSet, const IfcRelConnects &obj, const CopyOp &copyop)
{
    IfcRelConnects *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelConnects(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelConnects_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelConnects *ExpressDataSet::cloneIfcRelConnects(const IfcRelConnects &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelConnects(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelConnects(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelConnects  > &ExpressDataSet::getAllIfcRelConnects ()
{
    return m_refIfcRelConnectsList;
}



IfcRelConnectsElements *ExpressDataSet::getIfcRelConnectsElements(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelConnectsElements * > (current->second.get());
    }
    else
    {
        IfcRelConnectsElements *ret = static_cast< IfcRelConnectsElements * > (allocateIfcRelConnectsElements(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelConnectsElements(IfcRelConnectsElements *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelConnectsElements_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelConnectsElements(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelConnectsElements *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelConnectsElements(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelConnectsElements_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelConnectsElements > ExpressDataSet::createIfcRelConnectsElements(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelConnectsElements(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelConnectsElements * > (allocateIfcRelConnectsElements(this, Step::Id_UNSET));
    }
}

IfcRelConnectsElements *ExpressDataSet::cloneIfcRelConnectsElements(ExpressDataSet *expressDataSet, const IfcRelConnectsElements &obj, const CopyOp &copyop)
{
    IfcRelConnectsElements *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelConnectsElements(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelConnectsElements_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelConnectsElements *ExpressDataSet::cloneIfcRelConnectsElements(const IfcRelConnectsElements &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelConnectsElements(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelConnectsElements(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelConnectsElements  > &ExpressDataSet::getAllIfcRelConnectsElements ()
{
    return m_refIfcRelConnectsElementsList;
}



IfcRelConnectsPathElements *ExpressDataSet::getIfcRelConnectsPathElements(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelConnectsPathElements * > (current->second.get());
    }
    else
    {
        IfcRelConnectsPathElements *ret = static_cast< IfcRelConnectsPathElements * > (allocateIfcRelConnectsPathElements(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelConnectsPathElements(IfcRelConnectsPathElements *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelConnectsPathElements_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelConnectsPathElements(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelConnectsPathElements *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelConnectsPathElements(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelConnectsPathElements_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelConnectsPathElements > ExpressDataSet::createIfcRelConnectsPathElements(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelConnectsPathElements(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelConnectsPathElements * > (allocateIfcRelConnectsPathElements(this, Step::Id_UNSET));
    }
}

IfcRelConnectsPathElements *ExpressDataSet::cloneIfcRelConnectsPathElements(ExpressDataSet *expressDataSet, const IfcRelConnectsPathElements &obj, const CopyOp &copyop)
{
    IfcRelConnectsPathElements *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelConnectsPathElements(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelConnectsPathElements_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelConnectsPathElements *ExpressDataSet::cloneIfcRelConnectsPathElements(const IfcRelConnectsPathElements &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelConnectsPathElements(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelConnectsPathElements(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelConnectsPathElements  > &ExpressDataSet::getAllIfcRelConnectsPathElements ()
{
    return m_refIfcRelConnectsPathElementsList;
}



IfcRelConnectsPorts *ExpressDataSet::getIfcRelConnectsPorts(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelConnectsPorts * > (current->second.get());
    }
    else
    {
        IfcRelConnectsPorts *ret = static_cast< IfcRelConnectsPorts * > (allocateIfcRelConnectsPorts(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelConnectsPorts(IfcRelConnectsPorts *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelConnectsPorts_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelConnectsPorts(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelConnectsPorts *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelConnectsPorts(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelConnectsPorts_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelConnectsPorts > ExpressDataSet::createIfcRelConnectsPorts(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelConnectsPorts(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelConnectsPorts * > (allocateIfcRelConnectsPorts(this, Step::Id_UNSET));
    }
}

IfcRelConnectsPorts *ExpressDataSet::cloneIfcRelConnectsPorts(ExpressDataSet *expressDataSet, const IfcRelConnectsPorts &obj, const CopyOp &copyop)
{
    IfcRelConnectsPorts *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelConnectsPorts(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelConnectsPorts_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelConnectsPorts *ExpressDataSet::cloneIfcRelConnectsPorts(const IfcRelConnectsPorts &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelConnectsPorts(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelConnectsPorts(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelConnectsPorts  > &ExpressDataSet::getAllIfcRelConnectsPorts ()
{
    return m_refIfcRelConnectsPortsList;
}



IfcRelConnectsPortToElement *ExpressDataSet::getIfcRelConnectsPortToElement(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelConnectsPortToElement * > (current->second.get());
    }
    else
    {
        IfcRelConnectsPortToElement *ret = static_cast< IfcRelConnectsPortToElement * > (allocateIfcRelConnectsPortToElement(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelConnectsPortToElement(IfcRelConnectsPortToElement *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelConnectsPortToElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelConnectsPortToElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelConnectsPortToElement *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelConnectsPortToElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelConnectsPortToElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelConnectsPortToElement > ExpressDataSet::createIfcRelConnectsPortToElement(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelConnectsPortToElement(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelConnectsPortToElement * > (allocateIfcRelConnectsPortToElement(this, Step::Id_UNSET));
    }
}

IfcRelConnectsPortToElement *ExpressDataSet::cloneIfcRelConnectsPortToElement(ExpressDataSet *expressDataSet, const IfcRelConnectsPortToElement &obj, const CopyOp &copyop)
{
    IfcRelConnectsPortToElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelConnectsPortToElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelConnectsPortToElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelConnectsPortToElement *ExpressDataSet::cloneIfcRelConnectsPortToElement(const IfcRelConnectsPortToElement &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelConnectsPortToElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelConnectsPortToElement(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelConnectsPortToElement  > &ExpressDataSet::getAllIfcRelConnectsPortToElement ()
{
    return m_refIfcRelConnectsPortToElementList;
}



IfcRelConnectsStructuralActivity *ExpressDataSet::getIfcRelConnectsStructuralActivity(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelConnectsStructuralActivity * > (current->second.get());
    }
    else
    {
        IfcRelConnectsStructuralActivity *ret = static_cast< IfcRelConnectsStructuralActivity * > (allocateIfcRelConnectsStructuralActivity(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelConnectsStructuralActivity(IfcRelConnectsStructuralActivity *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelConnectsStructuralActivity_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelConnectsStructuralActivity(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelConnectsStructuralActivity *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelConnectsStructuralActivity(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelConnectsStructuralActivity_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelConnectsStructuralActivity > ExpressDataSet::createIfcRelConnectsStructuralActivity(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelConnectsStructuralActivity(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelConnectsStructuralActivity * > (allocateIfcRelConnectsStructuralActivity(this, Step::Id_UNSET));
    }
}

IfcRelConnectsStructuralActivity *ExpressDataSet::cloneIfcRelConnectsStructuralActivity(ExpressDataSet *expressDataSet, const IfcRelConnectsStructuralActivity &obj, const CopyOp &copyop)
{
    IfcRelConnectsStructuralActivity *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelConnectsStructuralActivity(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelConnectsStructuralActivity_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelConnectsStructuralActivity *ExpressDataSet::cloneIfcRelConnectsStructuralActivity(const IfcRelConnectsStructuralActivity &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelConnectsStructuralActivity(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelConnectsStructuralActivity(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelConnectsStructuralActivity  > &ExpressDataSet::getAllIfcRelConnectsStructuralActivity ()
{
    return m_refIfcRelConnectsStructuralActivityList;
}



IfcRelConnectsStructuralElement *ExpressDataSet::getIfcRelConnectsStructuralElement(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelConnectsStructuralElement * > (current->second.get());
    }
    else
    {
        IfcRelConnectsStructuralElement *ret = static_cast< IfcRelConnectsStructuralElement * > (allocateIfcRelConnectsStructuralElement(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelConnectsStructuralElement(IfcRelConnectsStructuralElement *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelConnectsStructuralElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelConnectsStructuralElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelConnectsStructuralElement *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelConnectsStructuralElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelConnectsStructuralElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelConnectsStructuralElement > ExpressDataSet::createIfcRelConnectsStructuralElement(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelConnectsStructuralElement(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelConnectsStructuralElement * > (allocateIfcRelConnectsStructuralElement(this, Step::Id_UNSET));
    }
}

IfcRelConnectsStructuralElement *ExpressDataSet::cloneIfcRelConnectsStructuralElement(ExpressDataSet *expressDataSet, const IfcRelConnectsStructuralElement &obj, const CopyOp &copyop)
{
    IfcRelConnectsStructuralElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelConnectsStructuralElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelConnectsStructuralElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelConnectsStructuralElement *ExpressDataSet::cloneIfcRelConnectsStructuralElement(const IfcRelConnectsStructuralElement &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelConnectsStructuralElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelConnectsStructuralElement(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelConnectsStructuralElement  > &ExpressDataSet::getAllIfcRelConnectsStructuralElement ()
{
    return m_refIfcRelConnectsStructuralElementList;
}



IfcRelConnectsStructuralMember *ExpressDataSet::getIfcRelConnectsStructuralMember(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelConnectsStructuralMember * > (current->second.get());
    }
    else
    {
        IfcRelConnectsStructuralMember *ret = static_cast< IfcRelConnectsStructuralMember * > (allocateIfcRelConnectsStructuralMember(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelConnectsStructuralMember(IfcRelConnectsStructuralMember *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelConnectsStructuralMember_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelConnectsStructuralMember(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelConnectsStructuralMember *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelConnectsStructuralMember(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelConnectsStructuralMember_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelConnectsStructuralMember > ExpressDataSet::createIfcRelConnectsStructuralMember(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelConnectsStructuralMember(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelConnectsStructuralMember * > (allocateIfcRelConnectsStructuralMember(this, Step::Id_UNSET));
    }
}

IfcRelConnectsStructuralMember *ExpressDataSet::cloneIfcRelConnectsStructuralMember(ExpressDataSet *expressDataSet, const IfcRelConnectsStructuralMember &obj, const CopyOp &copyop)
{
    IfcRelConnectsStructuralMember *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelConnectsStructuralMember(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelConnectsStructuralMember_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelConnectsStructuralMember *ExpressDataSet::cloneIfcRelConnectsStructuralMember(const IfcRelConnectsStructuralMember &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelConnectsStructuralMember(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelConnectsStructuralMember(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelConnectsStructuralMember  > &ExpressDataSet::getAllIfcRelConnectsStructuralMember ()
{
    return m_refIfcRelConnectsStructuralMemberList;
}



IfcRelConnectsWithEccentricity *ExpressDataSet::getIfcRelConnectsWithEccentricity(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelConnectsWithEccentricity * > (current->second.get());
    }
    else
    {
        IfcRelConnectsWithEccentricity *ret = static_cast< IfcRelConnectsWithEccentricity * > (allocateIfcRelConnectsWithEccentricity(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelConnectsWithEccentricity(IfcRelConnectsWithEccentricity *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelConnectsWithEccentricity_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelConnectsWithEccentricity(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelConnectsWithEccentricity *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelConnectsWithEccentricity(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelConnectsWithEccentricity_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelConnectsWithEccentricity > ExpressDataSet::createIfcRelConnectsWithEccentricity(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelConnectsWithEccentricity(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelConnectsWithEccentricity * > (allocateIfcRelConnectsWithEccentricity(this, Step::Id_UNSET));
    }
}

IfcRelConnectsWithEccentricity *ExpressDataSet::cloneIfcRelConnectsWithEccentricity(ExpressDataSet *expressDataSet, const IfcRelConnectsWithEccentricity &obj, const CopyOp &copyop)
{
    IfcRelConnectsWithEccentricity *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelConnectsWithEccentricity(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelConnectsWithEccentricity_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelConnectsWithEccentricity *ExpressDataSet::cloneIfcRelConnectsWithEccentricity(const IfcRelConnectsWithEccentricity &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelConnectsWithEccentricity(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelConnectsWithEccentricity(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelConnectsWithEccentricity  > &ExpressDataSet::getAllIfcRelConnectsWithEccentricity ()
{
    return m_refIfcRelConnectsWithEccentricityList;
}



IfcRelConnectsWithRealizingElements *ExpressDataSet::getIfcRelConnectsWithRealizingElements(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelConnectsWithRealizingElements * > (current->second.get());
    }
    else
    {
        IfcRelConnectsWithRealizingElements *ret = static_cast< IfcRelConnectsWithRealizingElements * > (allocateIfcRelConnectsWithRealizingElements(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelConnectsWithRealizingElements(IfcRelConnectsWithRealizingElements *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelConnectsWithRealizingElements_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelConnectsWithRealizingElements(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelConnectsWithRealizingElements *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelConnectsWithRealizingElements(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelConnectsWithRealizingElements_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelConnectsWithRealizingElements > ExpressDataSet::createIfcRelConnectsWithRealizingElements(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelConnectsWithRealizingElements(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelConnectsWithRealizingElements * > (allocateIfcRelConnectsWithRealizingElements(this, Step::Id_UNSET));
    }
}

IfcRelConnectsWithRealizingElements *ExpressDataSet::cloneIfcRelConnectsWithRealizingElements(ExpressDataSet *expressDataSet, const IfcRelConnectsWithRealizingElements &obj, const CopyOp &copyop)
{
    IfcRelConnectsWithRealizingElements *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelConnectsWithRealizingElements(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelConnectsWithRealizingElements_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelConnectsWithRealizingElements *ExpressDataSet::cloneIfcRelConnectsWithRealizingElements(const IfcRelConnectsWithRealizingElements &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelConnectsWithRealizingElements(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelConnectsWithRealizingElements(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelConnectsWithRealizingElements  > &ExpressDataSet::getAllIfcRelConnectsWithRealizingElements ()
{
    return m_refIfcRelConnectsWithRealizingElementsList;
}



IfcRelContainedInSpatialStructure *ExpressDataSet::getIfcRelContainedInSpatialStructure(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelContainedInSpatialStructure * > (current->second.get());
    }
    else
    {
        IfcRelContainedInSpatialStructure *ret = static_cast< IfcRelContainedInSpatialStructure * > (allocateIfcRelContainedInSpatialStructure(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelContainedInSpatialStructure(IfcRelContainedInSpatialStructure *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelContainedInSpatialStructure_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelContainedInSpatialStructure(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelContainedInSpatialStructure *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelContainedInSpatialStructure(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelContainedInSpatialStructure_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelContainedInSpatialStructure > ExpressDataSet::createIfcRelContainedInSpatialStructure(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelContainedInSpatialStructure(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelContainedInSpatialStructure * > (allocateIfcRelContainedInSpatialStructure(this, Step::Id_UNSET));
    }
}

IfcRelContainedInSpatialStructure *ExpressDataSet::cloneIfcRelContainedInSpatialStructure(ExpressDataSet *expressDataSet, const IfcRelContainedInSpatialStructure &obj, const CopyOp &copyop)
{
    IfcRelContainedInSpatialStructure *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelContainedInSpatialStructure(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelContainedInSpatialStructure_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelContainedInSpatialStructure *ExpressDataSet::cloneIfcRelContainedInSpatialStructure(const IfcRelContainedInSpatialStructure &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelContainedInSpatialStructure(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelContainedInSpatialStructure(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelContainedInSpatialStructure  > &ExpressDataSet::getAllIfcRelContainedInSpatialStructure ()
{
    return m_refIfcRelContainedInSpatialStructureList;
}



IfcRelCoversBldgElements *ExpressDataSet::getIfcRelCoversBldgElements(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelCoversBldgElements * > (current->second.get());
    }
    else
    {
        IfcRelCoversBldgElements *ret = static_cast< IfcRelCoversBldgElements * > (allocateIfcRelCoversBldgElements(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelCoversBldgElements(IfcRelCoversBldgElements *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelCoversBldgElements_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelCoversBldgElements(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelCoversBldgElements *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelCoversBldgElements(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelCoversBldgElements_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelCoversBldgElements > ExpressDataSet::createIfcRelCoversBldgElements(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelCoversBldgElements(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelCoversBldgElements * > (allocateIfcRelCoversBldgElements(this, Step::Id_UNSET));
    }
}

IfcRelCoversBldgElements *ExpressDataSet::cloneIfcRelCoversBldgElements(ExpressDataSet *expressDataSet, const IfcRelCoversBldgElements &obj, const CopyOp &copyop)
{
    IfcRelCoversBldgElements *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelCoversBldgElements(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelCoversBldgElements_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelCoversBldgElements *ExpressDataSet::cloneIfcRelCoversBldgElements(const IfcRelCoversBldgElements &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelCoversBldgElements(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelCoversBldgElements(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelCoversBldgElements  > &ExpressDataSet::getAllIfcRelCoversBldgElements ()
{
    return m_refIfcRelCoversBldgElementsList;
}



IfcRelCoversSpaces *ExpressDataSet::getIfcRelCoversSpaces(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelCoversSpaces * > (current->second.get());
    }
    else
    {
        IfcRelCoversSpaces *ret = static_cast< IfcRelCoversSpaces * > (allocateIfcRelCoversSpaces(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelCoversSpaces(IfcRelCoversSpaces *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelCoversSpaces_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelCoversSpaces(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelCoversSpaces *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelCoversSpaces(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelCoversSpaces_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelCoversSpaces > ExpressDataSet::createIfcRelCoversSpaces(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelCoversSpaces(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelCoversSpaces * > (allocateIfcRelCoversSpaces(this, Step::Id_UNSET));
    }
}

IfcRelCoversSpaces *ExpressDataSet::cloneIfcRelCoversSpaces(ExpressDataSet *expressDataSet, const IfcRelCoversSpaces &obj, const CopyOp &copyop)
{
    IfcRelCoversSpaces *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelCoversSpaces(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelCoversSpaces_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelCoversSpaces *ExpressDataSet::cloneIfcRelCoversSpaces(const IfcRelCoversSpaces &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelCoversSpaces(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelCoversSpaces(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelCoversSpaces  > &ExpressDataSet::getAllIfcRelCoversSpaces ()
{
    return m_refIfcRelCoversSpacesList;
}



IfcRelDecomposes *ExpressDataSet::getIfcRelDecomposes(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelDecomposes * > (current->second.get());
    }
    else
    {
        IfcRelDecomposes *ret = static_cast< IfcRelDecomposes * > (allocateIfcRelDecomposes(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelDecomposes(IfcRelDecomposes *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelDecomposes_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelDecomposes(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelDecomposes *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelDecomposes(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelDecomposes_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelDecomposes > ExpressDataSet::createIfcRelDecomposes(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelDecomposes(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelDecomposes * > (allocateIfcRelDecomposes(this, Step::Id_UNSET));
    }
}

IfcRelDecomposes *ExpressDataSet::cloneIfcRelDecomposes(ExpressDataSet *expressDataSet, const IfcRelDecomposes &obj, const CopyOp &copyop)
{
    IfcRelDecomposes *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelDecomposes(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelDecomposes_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelDecomposes *ExpressDataSet::cloneIfcRelDecomposes(const IfcRelDecomposes &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelDecomposes(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelDecomposes(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelDecomposes  > &ExpressDataSet::getAllIfcRelDecomposes ()
{
    return m_refIfcRelDecomposesList;
}



IfcRelDefines *ExpressDataSet::getIfcRelDefines(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelDefines * > (current->second.get());
    }
    else
    {
        IfcRelDefines *ret = static_cast< IfcRelDefines * > (allocateIfcRelDefines(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelDefines(IfcRelDefines *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelDefines_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelDefines(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelDefines *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelDefines(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelDefines_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelDefines > ExpressDataSet::createIfcRelDefines(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelDefines(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelDefines * > (allocateIfcRelDefines(this, Step::Id_UNSET));
    }
}

IfcRelDefines *ExpressDataSet::cloneIfcRelDefines(ExpressDataSet *expressDataSet, const IfcRelDefines &obj, const CopyOp &copyop)
{
    IfcRelDefines *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelDefines(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelDefines_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelDefines *ExpressDataSet::cloneIfcRelDefines(const IfcRelDefines &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelDefines(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelDefines(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelDefines  > &ExpressDataSet::getAllIfcRelDefines ()
{
    return m_refIfcRelDefinesList;
}



IfcRelDefinesByProperties *ExpressDataSet::getIfcRelDefinesByProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelDefinesByProperties * > (current->second.get());
    }
    else
    {
        IfcRelDefinesByProperties *ret = static_cast< IfcRelDefinesByProperties * > (allocateIfcRelDefinesByProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelDefinesByProperties(IfcRelDefinesByProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelDefinesByProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelDefinesByProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelDefinesByProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelDefinesByProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelDefinesByProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelDefinesByProperties > ExpressDataSet::createIfcRelDefinesByProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelDefinesByProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelDefinesByProperties * > (allocateIfcRelDefinesByProperties(this, Step::Id_UNSET));
    }
}

IfcRelDefinesByProperties *ExpressDataSet::cloneIfcRelDefinesByProperties(ExpressDataSet *expressDataSet, const IfcRelDefinesByProperties &obj, const CopyOp &copyop)
{
    IfcRelDefinesByProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelDefinesByProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelDefinesByProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelDefinesByProperties *ExpressDataSet::cloneIfcRelDefinesByProperties(const IfcRelDefinesByProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelDefinesByProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelDefinesByProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelDefinesByProperties  > &ExpressDataSet::getAllIfcRelDefinesByProperties ()
{
    return m_refIfcRelDefinesByPropertiesList;
}



IfcRelDefinesByType *ExpressDataSet::getIfcRelDefinesByType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelDefinesByType * > (current->second.get());
    }
    else
    {
        IfcRelDefinesByType *ret = static_cast< IfcRelDefinesByType * > (allocateIfcRelDefinesByType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelDefinesByType(IfcRelDefinesByType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelDefinesByType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelDefinesByType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelDefinesByType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelDefinesByType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelDefinesByType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelDefinesByType > ExpressDataSet::createIfcRelDefinesByType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelDefinesByType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelDefinesByType * > (allocateIfcRelDefinesByType(this, Step::Id_UNSET));
    }
}

IfcRelDefinesByType *ExpressDataSet::cloneIfcRelDefinesByType(ExpressDataSet *expressDataSet, const IfcRelDefinesByType &obj, const CopyOp &copyop)
{
    IfcRelDefinesByType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelDefinesByType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelDefinesByType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelDefinesByType *ExpressDataSet::cloneIfcRelDefinesByType(const IfcRelDefinesByType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelDefinesByType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelDefinesByType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelDefinesByType  > &ExpressDataSet::getAllIfcRelDefinesByType ()
{
    return m_refIfcRelDefinesByTypeList;
}



IfcRelFillsElement *ExpressDataSet::getIfcRelFillsElement(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelFillsElement * > (current->second.get());
    }
    else
    {
        IfcRelFillsElement *ret = static_cast< IfcRelFillsElement * > (allocateIfcRelFillsElement(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelFillsElement(IfcRelFillsElement *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelFillsElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelFillsElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelFillsElement *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelFillsElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelFillsElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelFillsElement > ExpressDataSet::createIfcRelFillsElement(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelFillsElement(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelFillsElement * > (allocateIfcRelFillsElement(this, Step::Id_UNSET));
    }
}

IfcRelFillsElement *ExpressDataSet::cloneIfcRelFillsElement(ExpressDataSet *expressDataSet, const IfcRelFillsElement &obj, const CopyOp &copyop)
{
    IfcRelFillsElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelFillsElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelFillsElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelFillsElement *ExpressDataSet::cloneIfcRelFillsElement(const IfcRelFillsElement &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelFillsElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelFillsElement(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelFillsElement  > &ExpressDataSet::getAllIfcRelFillsElement ()
{
    return m_refIfcRelFillsElementList;
}



IfcRelFlowControlElements *ExpressDataSet::getIfcRelFlowControlElements(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelFlowControlElements * > (current->second.get());
    }
    else
    {
        IfcRelFlowControlElements *ret = static_cast< IfcRelFlowControlElements * > (allocateIfcRelFlowControlElements(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelFlowControlElements(IfcRelFlowControlElements *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelFlowControlElements_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelFlowControlElements(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelFlowControlElements *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelFlowControlElements(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelFlowControlElements_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelFlowControlElements > ExpressDataSet::createIfcRelFlowControlElements(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelFlowControlElements(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelFlowControlElements * > (allocateIfcRelFlowControlElements(this, Step::Id_UNSET));
    }
}

IfcRelFlowControlElements *ExpressDataSet::cloneIfcRelFlowControlElements(ExpressDataSet *expressDataSet, const IfcRelFlowControlElements &obj, const CopyOp &copyop)
{
    IfcRelFlowControlElements *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelFlowControlElements(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelFlowControlElements_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelFlowControlElements *ExpressDataSet::cloneIfcRelFlowControlElements(const IfcRelFlowControlElements &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelFlowControlElements(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelFlowControlElements(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelFlowControlElements  > &ExpressDataSet::getAllIfcRelFlowControlElements ()
{
    return m_refIfcRelFlowControlElementsList;
}



IfcRelInteractionRequirements *ExpressDataSet::getIfcRelInteractionRequirements(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelInteractionRequirements * > (current->second.get());
    }
    else
    {
        IfcRelInteractionRequirements *ret = static_cast< IfcRelInteractionRequirements * > (allocateIfcRelInteractionRequirements(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelInteractionRequirements(IfcRelInteractionRequirements *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelInteractionRequirements_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelInteractionRequirements(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelInteractionRequirements *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelInteractionRequirements(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelInteractionRequirements_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelInteractionRequirements > ExpressDataSet::createIfcRelInteractionRequirements(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelInteractionRequirements(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelInteractionRequirements * > (allocateIfcRelInteractionRequirements(this, Step::Id_UNSET));
    }
}

IfcRelInteractionRequirements *ExpressDataSet::cloneIfcRelInteractionRequirements(ExpressDataSet *expressDataSet, const IfcRelInteractionRequirements &obj, const CopyOp &copyop)
{
    IfcRelInteractionRequirements *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelInteractionRequirements(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelInteractionRequirements_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelInteractionRequirements *ExpressDataSet::cloneIfcRelInteractionRequirements(const IfcRelInteractionRequirements &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelInteractionRequirements(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelInteractionRequirements(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelInteractionRequirements  > &ExpressDataSet::getAllIfcRelInteractionRequirements ()
{
    return m_refIfcRelInteractionRequirementsList;
}



IfcRelNests *ExpressDataSet::getIfcRelNests(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelNests * > (current->second.get());
    }
    else
    {
        IfcRelNests *ret = static_cast< IfcRelNests * > (allocateIfcRelNests(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelNests(IfcRelNests *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelNests_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelNests(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelNests *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelNests(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelNests_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelNests > ExpressDataSet::createIfcRelNests(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelNests(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelNests * > (allocateIfcRelNests(this, Step::Id_UNSET));
    }
}

IfcRelNests *ExpressDataSet::cloneIfcRelNests(ExpressDataSet *expressDataSet, const IfcRelNests &obj, const CopyOp &copyop)
{
    IfcRelNests *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelNests(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelNests_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelNests *ExpressDataSet::cloneIfcRelNests(const IfcRelNests &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelNests(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelNests(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelNests  > &ExpressDataSet::getAllIfcRelNests ()
{
    return m_refIfcRelNestsList;
}



IfcRelOccupiesSpaces *ExpressDataSet::getIfcRelOccupiesSpaces(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelOccupiesSpaces * > (current->second.get());
    }
    else
    {
        IfcRelOccupiesSpaces *ret = static_cast< IfcRelOccupiesSpaces * > (allocateIfcRelOccupiesSpaces(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelOccupiesSpaces(IfcRelOccupiesSpaces *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelOccupiesSpaces_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelOccupiesSpaces(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelOccupiesSpaces *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelOccupiesSpaces(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelOccupiesSpaces_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelOccupiesSpaces > ExpressDataSet::createIfcRelOccupiesSpaces(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelOccupiesSpaces(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelOccupiesSpaces * > (allocateIfcRelOccupiesSpaces(this, Step::Id_UNSET));
    }
}

IfcRelOccupiesSpaces *ExpressDataSet::cloneIfcRelOccupiesSpaces(ExpressDataSet *expressDataSet, const IfcRelOccupiesSpaces &obj, const CopyOp &copyop)
{
    IfcRelOccupiesSpaces *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelOccupiesSpaces(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelOccupiesSpaces_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelOccupiesSpaces *ExpressDataSet::cloneIfcRelOccupiesSpaces(const IfcRelOccupiesSpaces &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelOccupiesSpaces(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelOccupiesSpaces(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelOccupiesSpaces  > &ExpressDataSet::getAllIfcRelOccupiesSpaces ()
{
    return m_refIfcRelOccupiesSpacesList;
}



IfcRelOverridesProperties *ExpressDataSet::getIfcRelOverridesProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelOverridesProperties * > (current->second.get());
    }
    else
    {
        IfcRelOverridesProperties *ret = static_cast< IfcRelOverridesProperties * > (allocateIfcRelOverridesProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelOverridesProperties(IfcRelOverridesProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelOverridesProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelOverridesProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelOverridesProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelOverridesProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelOverridesProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelOverridesProperties > ExpressDataSet::createIfcRelOverridesProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelOverridesProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelOverridesProperties * > (allocateIfcRelOverridesProperties(this, Step::Id_UNSET));
    }
}

IfcRelOverridesProperties *ExpressDataSet::cloneIfcRelOverridesProperties(ExpressDataSet *expressDataSet, const IfcRelOverridesProperties &obj, const CopyOp &copyop)
{
    IfcRelOverridesProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelOverridesProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelOverridesProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelOverridesProperties *ExpressDataSet::cloneIfcRelOverridesProperties(const IfcRelOverridesProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelOverridesProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelOverridesProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelOverridesProperties  > &ExpressDataSet::getAllIfcRelOverridesProperties ()
{
    return m_refIfcRelOverridesPropertiesList;
}



IfcRelProjectsElement *ExpressDataSet::getIfcRelProjectsElement(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelProjectsElement * > (current->second.get());
    }
    else
    {
        IfcRelProjectsElement *ret = static_cast< IfcRelProjectsElement * > (allocateIfcRelProjectsElement(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelProjectsElement(IfcRelProjectsElement *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelProjectsElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelProjectsElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelProjectsElement *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelProjectsElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelProjectsElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelProjectsElement > ExpressDataSet::createIfcRelProjectsElement(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelProjectsElement(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelProjectsElement * > (allocateIfcRelProjectsElement(this, Step::Id_UNSET));
    }
}

IfcRelProjectsElement *ExpressDataSet::cloneIfcRelProjectsElement(ExpressDataSet *expressDataSet, const IfcRelProjectsElement &obj, const CopyOp &copyop)
{
    IfcRelProjectsElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelProjectsElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelProjectsElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelProjectsElement *ExpressDataSet::cloneIfcRelProjectsElement(const IfcRelProjectsElement &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelProjectsElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelProjectsElement(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelProjectsElement  > &ExpressDataSet::getAllIfcRelProjectsElement ()
{
    return m_refIfcRelProjectsElementList;
}



IfcRelReferencedInSpatialStructure *ExpressDataSet::getIfcRelReferencedInSpatialStructure(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelReferencedInSpatialStructure * > (current->second.get());
    }
    else
    {
        IfcRelReferencedInSpatialStructure *ret = static_cast< IfcRelReferencedInSpatialStructure * > (allocateIfcRelReferencedInSpatialStructure(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelReferencedInSpatialStructure(IfcRelReferencedInSpatialStructure *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelReferencedInSpatialStructure_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelReferencedInSpatialStructure(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelReferencedInSpatialStructure *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelReferencedInSpatialStructure(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelReferencedInSpatialStructure_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelReferencedInSpatialStructure > ExpressDataSet::createIfcRelReferencedInSpatialStructure(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelReferencedInSpatialStructure(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelReferencedInSpatialStructure * > (allocateIfcRelReferencedInSpatialStructure(this, Step::Id_UNSET));
    }
}

IfcRelReferencedInSpatialStructure *ExpressDataSet::cloneIfcRelReferencedInSpatialStructure(ExpressDataSet *expressDataSet, const IfcRelReferencedInSpatialStructure &obj, const CopyOp &copyop)
{
    IfcRelReferencedInSpatialStructure *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelReferencedInSpatialStructure(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelReferencedInSpatialStructure_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelReferencedInSpatialStructure *ExpressDataSet::cloneIfcRelReferencedInSpatialStructure(const IfcRelReferencedInSpatialStructure &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelReferencedInSpatialStructure(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelReferencedInSpatialStructure(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelReferencedInSpatialStructure  > &ExpressDataSet::getAllIfcRelReferencedInSpatialStructure ()
{
    return m_refIfcRelReferencedInSpatialStructureList;
}



IfcRelSchedulesCostItems *ExpressDataSet::getIfcRelSchedulesCostItems(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelSchedulesCostItems * > (current->second.get());
    }
    else
    {
        IfcRelSchedulesCostItems *ret = static_cast< IfcRelSchedulesCostItems * > (allocateIfcRelSchedulesCostItems(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelSchedulesCostItems(IfcRelSchedulesCostItems *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelSchedulesCostItems_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelSchedulesCostItems(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelSchedulesCostItems *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelSchedulesCostItems(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelSchedulesCostItems_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelSchedulesCostItems > ExpressDataSet::createIfcRelSchedulesCostItems(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelSchedulesCostItems(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelSchedulesCostItems * > (allocateIfcRelSchedulesCostItems(this, Step::Id_UNSET));
    }
}

IfcRelSchedulesCostItems *ExpressDataSet::cloneIfcRelSchedulesCostItems(ExpressDataSet *expressDataSet, const IfcRelSchedulesCostItems &obj, const CopyOp &copyop)
{
    IfcRelSchedulesCostItems *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelSchedulesCostItems(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelSchedulesCostItems_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelSchedulesCostItems *ExpressDataSet::cloneIfcRelSchedulesCostItems(const IfcRelSchedulesCostItems &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelSchedulesCostItems(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelSchedulesCostItems(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelSchedulesCostItems  > &ExpressDataSet::getAllIfcRelSchedulesCostItems ()
{
    return m_refIfcRelSchedulesCostItemsList;
}



IfcRelSequence *ExpressDataSet::getIfcRelSequence(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelSequence * > (current->second.get());
    }
    else
    {
        IfcRelSequence *ret = static_cast< IfcRelSequence * > (allocateIfcRelSequence(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelSequence(IfcRelSequence *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelSequence_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelSequence(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelSequence *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelSequence(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelSequence_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelSequence > ExpressDataSet::createIfcRelSequence(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelSequence(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelSequence * > (allocateIfcRelSequence(this, Step::Id_UNSET));
    }
}

IfcRelSequence *ExpressDataSet::cloneIfcRelSequence(ExpressDataSet *expressDataSet, const IfcRelSequence &obj, const CopyOp &copyop)
{
    IfcRelSequence *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelSequence(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelSequence_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelSequence *ExpressDataSet::cloneIfcRelSequence(const IfcRelSequence &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelSequence(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelSequence(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelSequence  > &ExpressDataSet::getAllIfcRelSequence ()
{
    return m_refIfcRelSequenceList;
}



IfcRelServicesBuildings *ExpressDataSet::getIfcRelServicesBuildings(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelServicesBuildings * > (current->second.get());
    }
    else
    {
        IfcRelServicesBuildings *ret = static_cast< IfcRelServicesBuildings * > (allocateIfcRelServicesBuildings(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelServicesBuildings(IfcRelServicesBuildings *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelServicesBuildings_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelServicesBuildings(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelServicesBuildings *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelServicesBuildings(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelServicesBuildings_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelServicesBuildings > ExpressDataSet::createIfcRelServicesBuildings(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelServicesBuildings(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelServicesBuildings * > (allocateIfcRelServicesBuildings(this, Step::Id_UNSET));
    }
}

IfcRelServicesBuildings *ExpressDataSet::cloneIfcRelServicesBuildings(ExpressDataSet *expressDataSet, const IfcRelServicesBuildings &obj, const CopyOp &copyop)
{
    IfcRelServicesBuildings *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelServicesBuildings(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelServicesBuildings_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelServicesBuildings *ExpressDataSet::cloneIfcRelServicesBuildings(const IfcRelServicesBuildings &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelServicesBuildings(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelServicesBuildings(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelServicesBuildings  > &ExpressDataSet::getAllIfcRelServicesBuildings ()
{
    return m_refIfcRelServicesBuildingsList;
}



IfcRelSpaceBoundary *ExpressDataSet::getIfcRelSpaceBoundary(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelSpaceBoundary * > (current->second.get());
    }
    else
    {
        IfcRelSpaceBoundary *ret = static_cast< IfcRelSpaceBoundary * > (allocateIfcRelSpaceBoundary(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelSpaceBoundary(IfcRelSpaceBoundary *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelSpaceBoundary_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelSpaceBoundary(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelSpaceBoundary *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelSpaceBoundary(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelSpaceBoundary_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelSpaceBoundary > ExpressDataSet::createIfcRelSpaceBoundary(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelSpaceBoundary(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelSpaceBoundary * > (allocateIfcRelSpaceBoundary(this, Step::Id_UNSET));
    }
}

IfcRelSpaceBoundary *ExpressDataSet::cloneIfcRelSpaceBoundary(ExpressDataSet *expressDataSet, const IfcRelSpaceBoundary &obj, const CopyOp &copyop)
{
    IfcRelSpaceBoundary *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelSpaceBoundary(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelSpaceBoundary_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelSpaceBoundary *ExpressDataSet::cloneIfcRelSpaceBoundary(const IfcRelSpaceBoundary &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelSpaceBoundary(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelSpaceBoundary(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelSpaceBoundary  > &ExpressDataSet::getAllIfcRelSpaceBoundary ()
{
    return m_refIfcRelSpaceBoundaryList;
}



IfcRelVoidsElement *ExpressDataSet::getIfcRelVoidsElement(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRelVoidsElement * > (current->second.get());
    }
    else
    {
        IfcRelVoidsElement *ret = static_cast< IfcRelVoidsElement * > (allocateIfcRelVoidsElement(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRelVoidsElement(IfcRelVoidsElement *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRelVoidsElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelVoidsElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRelVoidsElement *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelVoidsElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelVoidsElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelVoidsElement > ExpressDataSet::createIfcRelVoidsElement(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRelVoidsElement(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRelVoidsElement * > (allocateIfcRelVoidsElement(this, Step::Id_UNSET));
    }
}

IfcRelVoidsElement *ExpressDataSet::cloneIfcRelVoidsElement(ExpressDataSet *expressDataSet, const IfcRelVoidsElement &obj, const CopyOp &copyop)
{
    IfcRelVoidsElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelVoidsElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelVoidsElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelVoidsElement *ExpressDataSet::cloneIfcRelVoidsElement(const IfcRelVoidsElement &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRelVoidsElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRelVoidsElement(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRelVoidsElement  > &ExpressDataSet::getAllIfcRelVoidsElement ()
{
    return m_refIfcRelVoidsElementList;
}



IfcRepresentation *ExpressDataSet::getIfcRepresentation(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRepresentation * > (current->second.get());
    }
    else
    {
        IfcRepresentation *ret = static_cast< IfcRepresentation * > (allocateIfcRepresentation(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRepresentation(IfcRepresentation *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRepresentation_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRepresentation(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRepresentation *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRepresentation(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRepresentation_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRepresentation > ExpressDataSet::createIfcRepresentation(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRepresentation(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRepresentation * > (allocateIfcRepresentation(this, Step::Id_UNSET));
    }
}

IfcRepresentation *ExpressDataSet::cloneIfcRepresentation(ExpressDataSet *expressDataSet, const IfcRepresentation &obj, const CopyOp &copyop)
{
    IfcRepresentation *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRepresentation(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRepresentation_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRepresentation *ExpressDataSet::cloneIfcRepresentation(const IfcRepresentation &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRepresentation(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRepresentation(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRepresentation  > &ExpressDataSet::getAllIfcRepresentation ()
{
    return m_refIfcRepresentationList;
}



IfcRepresentationContext *ExpressDataSet::getIfcRepresentationContext(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRepresentationContext * > (current->second.get());
    }
    else
    {
        IfcRepresentationContext *ret = static_cast< IfcRepresentationContext * > (allocateIfcRepresentationContext(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRepresentationContext(IfcRepresentationContext *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRepresentationContext_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRepresentationContext(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRepresentationContext *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRepresentationContext(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRepresentationContext_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRepresentationContext > ExpressDataSet::createIfcRepresentationContext(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRepresentationContext(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRepresentationContext * > (allocateIfcRepresentationContext(this, Step::Id_UNSET));
    }
}

IfcRepresentationContext *ExpressDataSet::cloneIfcRepresentationContext(ExpressDataSet *expressDataSet, const IfcRepresentationContext &obj, const CopyOp &copyop)
{
    IfcRepresentationContext *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRepresentationContext(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRepresentationContext_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRepresentationContext *ExpressDataSet::cloneIfcRepresentationContext(const IfcRepresentationContext &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRepresentationContext(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRepresentationContext(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRepresentationContext  > &ExpressDataSet::getAllIfcRepresentationContext ()
{
    return m_refIfcRepresentationContextList;
}



IfcRepresentationItem *ExpressDataSet::getIfcRepresentationItem(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRepresentationItem * > (current->second.get());
    }
    else
    {
        IfcRepresentationItem *ret = static_cast< IfcRepresentationItem * > (allocateIfcRepresentationItem(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRepresentationItem(IfcRepresentationItem *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRepresentationItem_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRepresentationItem(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRepresentationItem *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRepresentationItem(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRepresentationItem_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRepresentationItem > ExpressDataSet::createIfcRepresentationItem(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRepresentationItem(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRepresentationItem * > (allocateIfcRepresentationItem(this, Step::Id_UNSET));
    }
}

IfcRepresentationItem *ExpressDataSet::cloneIfcRepresentationItem(ExpressDataSet *expressDataSet, const IfcRepresentationItem &obj, const CopyOp &copyop)
{
    IfcRepresentationItem *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRepresentationItem(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRepresentationItem_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRepresentationItem *ExpressDataSet::cloneIfcRepresentationItem(const IfcRepresentationItem &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRepresentationItem(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRepresentationItem(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRepresentationItem  > &ExpressDataSet::getAllIfcRepresentationItem ()
{
    return m_refIfcRepresentationItemList;
}



IfcRepresentationMap *ExpressDataSet::getIfcRepresentationMap(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRepresentationMap * > (current->second.get());
    }
    else
    {
        IfcRepresentationMap *ret = static_cast< IfcRepresentationMap * > (allocateIfcRepresentationMap(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRepresentationMap(IfcRepresentationMap *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRepresentationMap_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRepresentationMap(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRepresentationMap *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRepresentationMap(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRepresentationMap_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRepresentationMap > ExpressDataSet::createIfcRepresentationMap(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRepresentationMap(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRepresentationMap * > (allocateIfcRepresentationMap(this, Step::Id_UNSET));
    }
}

IfcRepresentationMap *ExpressDataSet::cloneIfcRepresentationMap(ExpressDataSet *expressDataSet, const IfcRepresentationMap &obj, const CopyOp &copyop)
{
    IfcRepresentationMap *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRepresentationMap(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRepresentationMap_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRepresentationMap *ExpressDataSet::cloneIfcRepresentationMap(const IfcRepresentationMap &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRepresentationMap(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRepresentationMap(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRepresentationMap  > &ExpressDataSet::getAllIfcRepresentationMap ()
{
    return m_refIfcRepresentationMapList;
}



IfcResource *ExpressDataSet::getIfcResource(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcResource * > (current->second.get());
    }
    else
    {
        IfcResource *ret = static_cast< IfcResource * > (allocateIfcResource(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcResource(IfcResource *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcResource_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcResource(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcResource *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcResource(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcResource_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcResource > ExpressDataSet::createIfcResource(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcResource(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcResource * > (allocateIfcResource(this, Step::Id_UNSET));
    }
}

IfcResource *ExpressDataSet::cloneIfcResource(ExpressDataSet *expressDataSet, const IfcResource &obj, const CopyOp &copyop)
{
    IfcResource *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcResource(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcResource_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcResource *ExpressDataSet::cloneIfcResource(const IfcResource &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcResource(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcResource(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcResource  > &ExpressDataSet::getAllIfcResource ()
{
    return m_refIfcResourceList;
}



IfcRevolvedAreaSolid *ExpressDataSet::getIfcRevolvedAreaSolid(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRevolvedAreaSolid * > (current->second.get());
    }
    else
    {
        IfcRevolvedAreaSolid *ret = static_cast< IfcRevolvedAreaSolid * > (allocateIfcRevolvedAreaSolid(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRevolvedAreaSolid(IfcRevolvedAreaSolid *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRevolvedAreaSolid_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRevolvedAreaSolid(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRevolvedAreaSolid *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRevolvedAreaSolid(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRevolvedAreaSolid_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRevolvedAreaSolid > ExpressDataSet::createIfcRevolvedAreaSolid(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRevolvedAreaSolid(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRevolvedAreaSolid * > (allocateIfcRevolvedAreaSolid(this, Step::Id_UNSET));
    }
}

IfcRevolvedAreaSolid *ExpressDataSet::cloneIfcRevolvedAreaSolid(ExpressDataSet *expressDataSet, const IfcRevolvedAreaSolid &obj, const CopyOp &copyop)
{
    IfcRevolvedAreaSolid *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRevolvedAreaSolid(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRevolvedAreaSolid_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRevolvedAreaSolid *ExpressDataSet::cloneIfcRevolvedAreaSolid(const IfcRevolvedAreaSolid &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRevolvedAreaSolid(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRevolvedAreaSolid(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRevolvedAreaSolid  > &ExpressDataSet::getAllIfcRevolvedAreaSolid ()
{
    return m_refIfcRevolvedAreaSolidList;
}



IfcRibPlateProfileProperties *ExpressDataSet::getIfcRibPlateProfileProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRibPlateProfileProperties * > (current->second.get());
    }
    else
    {
        IfcRibPlateProfileProperties *ret = static_cast< IfcRibPlateProfileProperties * > (allocateIfcRibPlateProfileProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRibPlateProfileProperties(IfcRibPlateProfileProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRibPlateProfileProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRibPlateProfileProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRibPlateProfileProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRibPlateProfileProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRibPlateProfileProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRibPlateProfileProperties > ExpressDataSet::createIfcRibPlateProfileProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRibPlateProfileProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRibPlateProfileProperties * > (allocateIfcRibPlateProfileProperties(this, Step::Id_UNSET));
    }
}

IfcRibPlateProfileProperties *ExpressDataSet::cloneIfcRibPlateProfileProperties(ExpressDataSet *expressDataSet, const IfcRibPlateProfileProperties &obj, const CopyOp &copyop)
{
    IfcRibPlateProfileProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRibPlateProfileProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRibPlateProfileProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRibPlateProfileProperties *ExpressDataSet::cloneIfcRibPlateProfileProperties(const IfcRibPlateProfileProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRibPlateProfileProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRibPlateProfileProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRibPlateProfileProperties  > &ExpressDataSet::getAllIfcRibPlateProfileProperties ()
{
    return m_refIfcRibPlateProfilePropertiesList;
}



IfcRightCircularCone *ExpressDataSet::getIfcRightCircularCone(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRightCircularCone * > (current->second.get());
    }
    else
    {
        IfcRightCircularCone *ret = static_cast< IfcRightCircularCone * > (allocateIfcRightCircularCone(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRightCircularCone(IfcRightCircularCone *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRightCircularCone_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRightCircularCone(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRightCircularCone *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRightCircularCone(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRightCircularCone_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRightCircularCone > ExpressDataSet::createIfcRightCircularCone(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRightCircularCone(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRightCircularCone * > (allocateIfcRightCircularCone(this, Step::Id_UNSET));
    }
}

IfcRightCircularCone *ExpressDataSet::cloneIfcRightCircularCone(ExpressDataSet *expressDataSet, const IfcRightCircularCone &obj, const CopyOp &copyop)
{
    IfcRightCircularCone *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRightCircularCone(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRightCircularCone_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRightCircularCone *ExpressDataSet::cloneIfcRightCircularCone(const IfcRightCircularCone &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRightCircularCone(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRightCircularCone(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRightCircularCone  > &ExpressDataSet::getAllIfcRightCircularCone ()
{
    return m_refIfcRightCircularConeList;
}



IfcRightCircularCylinder *ExpressDataSet::getIfcRightCircularCylinder(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRightCircularCylinder * > (current->second.get());
    }
    else
    {
        IfcRightCircularCylinder *ret = static_cast< IfcRightCircularCylinder * > (allocateIfcRightCircularCylinder(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRightCircularCylinder(IfcRightCircularCylinder *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRightCircularCylinder_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRightCircularCylinder(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRightCircularCylinder *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRightCircularCylinder(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRightCircularCylinder_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRightCircularCylinder > ExpressDataSet::createIfcRightCircularCylinder(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRightCircularCylinder(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRightCircularCylinder * > (allocateIfcRightCircularCylinder(this, Step::Id_UNSET));
    }
}

IfcRightCircularCylinder *ExpressDataSet::cloneIfcRightCircularCylinder(ExpressDataSet *expressDataSet, const IfcRightCircularCylinder &obj, const CopyOp &copyop)
{
    IfcRightCircularCylinder *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRightCircularCylinder(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRightCircularCylinder_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRightCircularCylinder *ExpressDataSet::cloneIfcRightCircularCylinder(const IfcRightCircularCylinder &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRightCircularCylinder(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRightCircularCylinder(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRightCircularCylinder  > &ExpressDataSet::getAllIfcRightCircularCylinder ()
{
    return m_refIfcRightCircularCylinderList;
}



IfcRoof *ExpressDataSet::getIfcRoof(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRoof * > (current->second.get());
    }
    else
    {
        IfcRoof *ret = static_cast< IfcRoof * > (allocateIfcRoof(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRoof(IfcRoof *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRoof_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRoof(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRoof *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRoof(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRoof_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRoof > ExpressDataSet::createIfcRoof(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRoof(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRoof * > (allocateIfcRoof(this, Step::Id_UNSET));
    }
}

IfcRoof *ExpressDataSet::cloneIfcRoof(ExpressDataSet *expressDataSet, const IfcRoof &obj, const CopyOp &copyop)
{
    IfcRoof *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRoof(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRoof_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRoof *ExpressDataSet::cloneIfcRoof(const IfcRoof &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRoof(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRoof(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRoof  > &ExpressDataSet::getAllIfcRoof ()
{
    return m_refIfcRoofList;
}



IfcRoot *ExpressDataSet::getIfcRoot(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRoot * > (current->second.get());
    }
    else
    {
        IfcRoot *ret = static_cast< IfcRoot * > (allocateIfcRoot(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRoot(IfcRoot *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRoot_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRoot(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRoot *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRoot(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRoot_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRoot > ExpressDataSet::createIfcRoot(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRoot(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRoot * > (allocateIfcRoot(this, Step::Id_UNSET));
    }
}

IfcRoot *ExpressDataSet::cloneIfcRoot(ExpressDataSet *expressDataSet, const IfcRoot &obj, const CopyOp &copyop)
{
    IfcRoot *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRoot(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRoot_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRoot *ExpressDataSet::cloneIfcRoot(const IfcRoot &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRoot(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRoot(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRoot  > &ExpressDataSet::getAllIfcRoot ()
{
    return m_refIfcRootList;
}



IfcRoundedEdgeFeature *ExpressDataSet::getIfcRoundedEdgeFeature(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRoundedEdgeFeature * > (current->second.get());
    }
    else
    {
        IfcRoundedEdgeFeature *ret = static_cast< IfcRoundedEdgeFeature * > (allocateIfcRoundedEdgeFeature(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRoundedEdgeFeature(IfcRoundedEdgeFeature *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRoundedEdgeFeature_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRoundedEdgeFeature(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRoundedEdgeFeature *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRoundedEdgeFeature(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRoundedEdgeFeature_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRoundedEdgeFeature > ExpressDataSet::createIfcRoundedEdgeFeature(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRoundedEdgeFeature(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRoundedEdgeFeature * > (allocateIfcRoundedEdgeFeature(this, Step::Id_UNSET));
    }
}

IfcRoundedEdgeFeature *ExpressDataSet::cloneIfcRoundedEdgeFeature(ExpressDataSet *expressDataSet, const IfcRoundedEdgeFeature &obj, const CopyOp &copyop)
{
    IfcRoundedEdgeFeature *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRoundedEdgeFeature(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRoundedEdgeFeature_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRoundedEdgeFeature *ExpressDataSet::cloneIfcRoundedEdgeFeature(const IfcRoundedEdgeFeature &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRoundedEdgeFeature(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRoundedEdgeFeature(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRoundedEdgeFeature  > &ExpressDataSet::getAllIfcRoundedEdgeFeature ()
{
    return m_refIfcRoundedEdgeFeatureList;
}



IfcRoundedRectangleProfileDef *ExpressDataSet::getIfcRoundedRectangleProfileDef(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcRoundedRectangleProfileDef * > (current->second.get());
    }
    else
    {
        IfcRoundedRectangleProfileDef *ret = static_cast< IfcRoundedRectangleProfileDef * > (allocateIfcRoundedRectangleProfileDef(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcRoundedRectangleProfileDef(IfcRoundedRectangleProfileDef *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcRoundedRectangleProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRoundedRectangleProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcRoundedRectangleProfileDef *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRoundedRectangleProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRoundedRectangleProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRoundedRectangleProfileDef > ExpressDataSet::createIfcRoundedRectangleProfileDef(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcRoundedRectangleProfileDef(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcRoundedRectangleProfileDef * > (allocateIfcRoundedRectangleProfileDef(this, Step::Id_UNSET));
    }
}

IfcRoundedRectangleProfileDef *ExpressDataSet::cloneIfcRoundedRectangleProfileDef(ExpressDataSet *expressDataSet, const IfcRoundedRectangleProfileDef &obj, const CopyOp &copyop)
{
    IfcRoundedRectangleProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRoundedRectangleProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRoundedRectangleProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRoundedRectangleProfileDef *ExpressDataSet::cloneIfcRoundedRectangleProfileDef(const IfcRoundedRectangleProfileDef &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcRoundedRectangleProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcRoundedRectangleProfileDef(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcRoundedRectangleProfileDef  > &ExpressDataSet::getAllIfcRoundedRectangleProfileDef ()
{
    return m_refIfcRoundedRectangleProfileDefList;
}



IfcSanitaryTerminalType *ExpressDataSet::getIfcSanitaryTerminalType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSanitaryTerminalType * > (current->second.get());
    }
    else
    {
        IfcSanitaryTerminalType *ret = static_cast< IfcSanitaryTerminalType * > (allocateIfcSanitaryTerminalType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSanitaryTerminalType(IfcSanitaryTerminalType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSanitaryTerminalType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSanitaryTerminalType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSanitaryTerminalType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSanitaryTerminalType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSanitaryTerminalType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSanitaryTerminalType > ExpressDataSet::createIfcSanitaryTerminalType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSanitaryTerminalType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSanitaryTerminalType * > (allocateIfcSanitaryTerminalType(this, Step::Id_UNSET));
    }
}

IfcSanitaryTerminalType *ExpressDataSet::cloneIfcSanitaryTerminalType(ExpressDataSet *expressDataSet, const IfcSanitaryTerminalType &obj, const CopyOp &copyop)
{
    IfcSanitaryTerminalType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSanitaryTerminalType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSanitaryTerminalType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSanitaryTerminalType *ExpressDataSet::cloneIfcSanitaryTerminalType(const IfcSanitaryTerminalType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSanitaryTerminalType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSanitaryTerminalType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSanitaryTerminalType  > &ExpressDataSet::getAllIfcSanitaryTerminalType ()
{
    return m_refIfcSanitaryTerminalTypeList;
}



IfcScheduleTimeControl *ExpressDataSet::getIfcScheduleTimeControl(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcScheduleTimeControl * > (current->second.get());
    }
    else
    {
        IfcScheduleTimeControl *ret = static_cast< IfcScheduleTimeControl * > (allocateIfcScheduleTimeControl(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcScheduleTimeControl(IfcScheduleTimeControl *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcScheduleTimeControl_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcScheduleTimeControl(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcScheduleTimeControl *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcScheduleTimeControl(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcScheduleTimeControl_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcScheduleTimeControl > ExpressDataSet::createIfcScheduleTimeControl(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcScheduleTimeControl(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcScheduleTimeControl * > (allocateIfcScheduleTimeControl(this, Step::Id_UNSET));
    }
}

IfcScheduleTimeControl *ExpressDataSet::cloneIfcScheduleTimeControl(ExpressDataSet *expressDataSet, const IfcScheduleTimeControl &obj, const CopyOp &copyop)
{
    IfcScheduleTimeControl *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcScheduleTimeControl(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcScheduleTimeControl_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcScheduleTimeControl *ExpressDataSet::cloneIfcScheduleTimeControl(const IfcScheduleTimeControl &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcScheduleTimeControl(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcScheduleTimeControl(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcScheduleTimeControl  > &ExpressDataSet::getAllIfcScheduleTimeControl ()
{
    return m_refIfcScheduleTimeControlList;
}



IfcSectionedSpine *ExpressDataSet::getIfcSectionedSpine(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSectionedSpine * > (current->second.get());
    }
    else
    {
        IfcSectionedSpine *ret = static_cast< IfcSectionedSpine * > (allocateIfcSectionedSpine(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSectionedSpine(IfcSectionedSpine *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSectionedSpine_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSectionedSpine(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSectionedSpine *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSectionedSpine(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSectionedSpine_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSectionedSpine > ExpressDataSet::createIfcSectionedSpine(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSectionedSpine(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSectionedSpine * > (allocateIfcSectionedSpine(this, Step::Id_UNSET));
    }
}

IfcSectionedSpine *ExpressDataSet::cloneIfcSectionedSpine(ExpressDataSet *expressDataSet, const IfcSectionedSpine &obj, const CopyOp &copyop)
{
    IfcSectionedSpine *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSectionedSpine(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSectionedSpine_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSectionedSpine *ExpressDataSet::cloneIfcSectionedSpine(const IfcSectionedSpine &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSectionedSpine(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSectionedSpine(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSectionedSpine  > &ExpressDataSet::getAllIfcSectionedSpine ()
{
    return m_refIfcSectionedSpineList;
}



IfcSectionProperties *ExpressDataSet::getIfcSectionProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSectionProperties * > (current->second.get());
    }
    else
    {
        IfcSectionProperties *ret = static_cast< IfcSectionProperties * > (allocateIfcSectionProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSectionProperties(IfcSectionProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSectionProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSectionProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSectionProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSectionProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSectionProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSectionProperties > ExpressDataSet::createIfcSectionProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSectionProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSectionProperties * > (allocateIfcSectionProperties(this, Step::Id_UNSET));
    }
}

IfcSectionProperties *ExpressDataSet::cloneIfcSectionProperties(ExpressDataSet *expressDataSet, const IfcSectionProperties &obj, const CopyOp &copyop)
{
    IfcSectionProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSectionProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSectionProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSectionProperties *ExpressDataSet::cloneIfcSectionProperties(const IfcSectionProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSectionProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSectionProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSectionProperties  > &ExpressDataSet::getAllIfcSectionProperties ()
{
    return m_refIfcSectionPropertiesList;
}



IfcSectionReinforcementProperties *ExpressDataSet::getIfcSectionReinforcementProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSectionReinforcementProperties * > (current->second.get());
    }
    else
    {
        IfcSectionReinforcementProperties *ret = static_cast< IfcSectionReinforcementProperties * > (allocateIfcSectionReinforcementProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSectionReinforcementProperties(IfcSectionReinforcementProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSectionReinforcementProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSectionReinforcementProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSectionReinforcementProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSectionReinforcementProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSectionReinforcementProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSectionReinforcementProperties > ExpressDataSet::createIfcSectionReinforcementProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSectionReinforcementProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSectionReinforcementProperties * > (allocateIfcSectionReinforcementProperties(this, Step::Id_UNSET));
    }
}

IfcSectionReinforcementProperties *ExpressDataSet::cloneIfcSectionReinforcementProperties(ExpressDataSet *expressDataSet, const IfcSectionReinforcementProperties &obj, const CopyOp &copyop)
{
    IfcSectionReinforcementProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSectionReinforcementProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSectionReinforcementProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSectionReinforcementProperties *ExpressDataSet::cloneIfcSectionReinforcementProperties(const IfcSectionReinforcementProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSectionReinforcementProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSectionReinforcementProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSectionReinforcementProperties  > &ExpressDataSet::getAllIfcSectionReinforcementProperties ()
{
    return m_refIfcSectionReinforcementPropertiesList;
}



IfcSensorType *ExpressDataSet::getIfcSensorType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSensorType * > (current->second.get());
    }
    else
    {
        IfcSensorType *ret = static_cast< IfcSensorType * > (allocateIfcSensorType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSensorType(IfcSensorType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSensorType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSensorType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSensorType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSensorType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSensorType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSensorType > ExpressDataSet::createIfcSensorType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSensorType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSensorType * > (allocateIfcSensorType(this, Step::Id_UNSET));
    }
}

IfcSensorType *ExpressDataSet::cloneIfcSensorType(ExpressDataSet *expressDataSet, const IfcSensorType &obj, const CopyOp &copyop)
{
    IfcSensorType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSensorType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSensorType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSensorType *ExpressDataSet::cloneIfcSensorType(const IfcSensorType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSensorType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSensorType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSensorType  > &ExpressDataSet::getAllIfcSensorType ()
{
    return m_refIfcSensorTypeList;
}



IfcServiceLife *ExpressDataSet::getIfcServiceLife(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcServiceLife * > (current->second.get());
    }
    else
    {
        IfcServiceLife *ret = static_cast< IfcServiceLife * > (allocateIfcServiceLife(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcServiceLife(IfcServiceLife *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcServiceLife_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcServiceLife(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcServiceLife *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcServiceLife(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcServiceLife_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcServiceLife > ExpressDataSet::createIfcServiceLife(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcServiceLife(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcServiceLife * > (allocateIfcServiceLife(this, Step::Id_UNSET));
    }
}

IfcServiceLife *ExpressDataSet::cloneIfcServiceLife(ExpressDataSet *expressDataSet, const IfcServiceLife &obj, const CopyOp &copyop)
{
    IfcServiceLife *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcServiceLife(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcServiceLife_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcServiceLife *ExpressDataSet::cloneIfcServiceLife(const IfcServiceLife &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcServiceLife(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcServiceLife(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcServiceLife  > &ExpressDataSet::getAllIfcServiceLife ()
{
    return m_refIfcServiceLifeList;
}



IfcServiceLifeFactor *ExpressDataSet::getIfcServiceLifeFactor(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcServiceLifeFactor * > (current->second.get());
    }
    else
    {
        IfcServiceLifeFactor *ret = static_cast< IfcServiceLifeFactor * > (allocateIfcServiceLifeFactor(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcServiceLifeFactor(IfcServiceLifeFactor *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcServiceLifeFactor_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcServiceLifeFactor(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcServiceLifeFactor *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcServiceLifeFactor(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcServiceLifeFactor_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcServiceLifeFactor > ExpressDataSet::createIfcServiceLifeFactor(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcServiceLifeFactor(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcServiceLifeFactor * > (allocateIfcServiceLifeFactor(this, Step::Id_UNSET));
    }
}

IfcServiceLifeFactor *ExpressDataSet::cloneIfcServiceLifeFactor(ExpressDataSet *expressDataSet, const IfcServiceLifeFactor &obj, const CopyOp &copyop)
{
    IfcServiceLifeFactor *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcServiceLifeFactor(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcServiceLifeFactor_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcServiceLifeFactor *ExpressDataSet::cloneIfcServiceLifeFactor(const IfcServiceLifeFactor &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcServiceLifeFactor(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcServiceLifeFactor(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcServiceLifeFactor  > &ExpressDataSet::getAllIfcServiceLifeFactor ()
{
    return m_refIfcServiceLifeFactorList;
}



IfcShapeAspect *ExpressDataSet::getIfcShapeAspect(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcShapeAspect * > (current->second.get());
    }
    else
    {
        IfcShapeAspect *ret = static_cast< IfcShapeAspect * > (allocateIfcShapeAspect(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcShapeAspect(IfcShapeAspect *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcShapeAspect_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcShapeAspect(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcShapeAspect *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcShapeAspect(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcShapeAspect_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcShapeAspect > ExpressDataSet::createIfcShapeAspect(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcShapeAspect(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcShapeAspect * > (allocateIfcShapeAspect(this, Step::Id_UNSET));
    }
}

IfcShapeAspect *ExpressDataSet::cloneIfcShapeAspect(ExpressDataSet *expressDataSet, const IfcShapeAspect &obj, const CopyOp &copyop)
{
    IfcShapeAspect *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcShapeAspect(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcShapeAspect_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcShapeAspect *ExpressDataSet::cloneIfcShapeAspect(const IfcShapeAspect &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcShapeAspect(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcShapeAspect(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcShapeAspect  > &ExpressDataSet::getAllIfcShapeAspect ()
{
    return m_refIfcShapeAspectList;
}



IfcShapeModel *ExpressDataSet::getIfcShapeModel(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcShapeModel * > (current->second.get());
    }
    else
    {
        IfcShapeModel *ret = static_cast< IfcShapeModel * > (allocateIfcShapeModel(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcShapeModel(IfcShapeModel *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcShapeModel_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcShapeModel(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcShapeModel *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcShapeModel(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcShapeModel_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcShapeModel > ExpressDataSet::createIfcShapeModel(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcShapeModel(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcShapeModel * > (allocateIfcShapeModel(this, Step::Id_UNSET));
    }
}

IfcShapeModel *ExpressDataSet::cloneIfcShapeModel(ExpressDataSet *expressDataSet, const IfcShapeModel &obj, const CopyOp &copyop)
{
    IfcShapeModel *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcShapeModel(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcShapeModel_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcShapeModel *ExpressDataSet::cloneIfcShapeModel(const IfcShapeModel &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcShapeModel(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcShapeModel(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcShapeModel  > &ExpressDataSet::getAllIfcShapeModel ()
{
    return m_refIfcShapeModelList;
}



IfcShapeRepresentation *ExpressDataSet::getIfcShapeRepresentation(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcShapeRepresentation * > (current->second.get());
    }
    else
    {
        IfcShapeRepresentation *ret = static_cast< IfcShapeRepresentation * > (allocateIfcShapeRepresentation(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcShapeRepresentation(IfcShapeRepresentation *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcShapeRepresentation_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcShapeRepresentation(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcShapeRepresentation *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcShapeRepresentation(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcShapeRepresentation_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcShapeRepresentation > ExpressDataSet::createIfcShapeRepresentation(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcShapeRepresentation(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcShapeRepresentation * > (allocateIfcShapeRepresentation(this, Step::Id_UNSET));
    }
}

IfcShapeRepresentation *ExpressDataSet::cloneIfcShapeRepresentation(ExpressDataSet *expressDataSet, const IfcShapeRepresentation &obj, const CopyOp &copyop)
{
    IfcShapeRepresentation *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcShapeRepresentation(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcShapeRepresentation_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcShapeRepresentation *ExpressDataSet::cloneIfcShapeRepresentation(const IfcShapeRepresentation &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcShapeRepresentation(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcShapeRepresentation(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcShapeRepresentation  > &ExpressDataSet::getAllIfcShapeRepresentation ()
{
    return m_refIfcShapeRepresentationList;
}



IfcShellBasedSurfaceModel *ExpressDataSet::getIfcShellBasedSurfaceModel(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcShellBasedSurfaceModel * > (current->second.get());
    }
    else
    {
        IfcShellBasedSurfaceModel *ret = static_cast< IfcShellBasedSurfaceModel * > (allocateIfcShellBasedSurfaceModel(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcShellBasedSurfaceModel(IfcShellBasedSurfaceModel *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcShellBasedSurfaceModel_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcShellBasedSurfaceModel(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcShellBasedSurfaceModel *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcShellBasedSurfaceModel(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcShellBasedSurfaceModel_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcShellBasedSurfaceModel > ExpressDataSet::createIfcShellBasedSurfaceModel(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcShellBasedSurfaceModel(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcShellBasedSurfaceModel * > (allocateIfcShellBasedSurfaceModel(this, Step::Id_UNSET));
    }
}

IfcShellBasedSurfaceModel *ExpressDataSet::cloneIfcShellBasedSurfaceModel(ExpressDataSet *expressDataSet, const IfcShellBasedSurfaceModel &obj, const CopyOp &copyop)
{
    IfcShellBasedSurfaceModel *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcShellBasedSurfaceModel(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcShellBasedSurfaceModel_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcShellBasedSurfaceModel *ExpressDataSet::cloneIfcShellBasedSurfaceModel(const IfcShellBasedSurfaceModel &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcShellBasedSurfaceModel(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcShellBasedSurfaceModel(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcShellBasedSurfaceModel  > &ExpressDataSet::getAllIfcShellBasedSurfaceModel ()
{
    return m_refIfcShellBasedSurfaceModelList;
}



IfcSimpleProperty *ExpressDataSet::getIfcSimpleProperty(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSimpleProperty * > (current->second.get());
    }
    else
    {
        IfcSimpleProperty *ret = static_cast< IfcSimpleProperty * > (allocateIfcSimpleProperty(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSimpleProperty(IfcSimpleProperty *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSimpleProperty_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSimpleProperty(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSimpleProperty *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSimpleProperty(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSimpleProperty_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSimpleProperty > ExpressDataSet::createIfcSimpleProperty(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSimpleProperty(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSimpleProperty * > (allocateIfcSimpleProperty(this, Step::Id_UNSET));
    }
}

IfcSimpleProperty *ExpressDataSet::cloneIfcSimpleProperty(ExpressDataSet *expressDataSet, const IfcSimpleProperty &obj, const CopyOp &copyop)
{
    IfcSimpleProperty *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSimpleProperty(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSimpleProperty_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSimpleProperty *ExpressDataSet::cloneIfcSimpleProperty(const IfcSimpleProperty &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSimpleProperty(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSimpleProperty(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSimpleProperty  > &ExpressDataSet::getAllIfcSimpleProperty ()
{
    return m_refIfcSimplePropertyList;
}



IfcSite *ExpressDataSet::getIfcSite(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSite * > (current->second.get());
    }
    else
    {
        IfcSite *ret = static_cast< IfcSite * > (allocateIfcSite(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSite(IfcSite *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSite_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSite(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSite *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSite(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSite_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSite > ExpressDataSet::createIfcSite(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSite(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSite * > (allocateIfcSite(this, Step::Id_UNSET));
    }
}

IfcSite *ExpressDataSet::cloneIfcSite(ExpressDataSet *expressDataSet, const IfcSite &obj, const CopyOp &copyop)
{
    IfcSite *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSite(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSite_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSite *ExpressDataSet::cloneIfcSite(const IfcSite &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSite(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSite(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSite  > &ExpressDataSet::getAllIfcSite ()
{
    return m_refIfcSiteList;
}



IfcSIUnit *ExpressDataSet::getIfcSIUnit(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSIUnit * > (current->second.get());
    }
    else
    {
        IfcSIUnit *ret = static_cast< IfcSIUnit * > (allocateIfcSIUnit(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSIUnit(IfcSIUnit *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSIUnit_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSIUnit(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSIUnit *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSIUnit(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSIUnit_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSIUnit > ExpressDataSet::createIfcSIUnit(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSIUnit(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSIUnit * > (allocateIfcSIUnit(this, Step::Id_UNSET));
    }
}

IfcSIUnit *ExpressDataSet::cloneIfcSIUnit(ExpressDataSet *expressDataSet, const IfcSIUnit &obj, const CopyOp &copyop)
{
    IfcSIUnit *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSIUnit(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSIUnit_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSIUnit *ExpressDataSet::cloneIfcSIUnit(const IfcSIUnit &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSIUnit(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSIUnit(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSIUnit  > &ExpressDataSet::getAllIfcSIUnit ()
{
    return m_refIfcSIUnitList;
}



IfcSlab *ExpressDataSet::getIfcSlab(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSlab * > (current->second.get());
    }
    else
    {
        IfcSlab *ret = static_cast< IfcSlab * > (allocateIfcSlab(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSlab(IfcSlab *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSlab_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSlab(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSlab *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSlab(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSlab_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSlab > ExpressDataSet::createIfcSlab(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSlab(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSlab * > (allocateIfcSlab(this, Step::Id_UNSET));
    }
}

IfcSlab *ExpressDataSet::cloneIfcSlab(ExpressDataSet *expressDataSet, const IfcSlab &obj, const CopyOp &copyop)
{
    IfcSlab *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSlab(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSlab_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSlab *ExpressDataSet::cloneIfcSlab(const IfcSlab &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSlab(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSlab(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSlab  > &ExpressDataSet::getAllIfcSlab ()
{
    return m_refIfcSlabList;
}



IfcSlabType *ExpressDataSet::getIfcSlabType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSlabType * > (current->second.get());
    }
    else
    {
        IfcSlabType *ret = static_cast< IfcSlabType * > (allocateIfcSlabType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSlabType(IfcSlabType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSlabType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSlabType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSlabType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSlabType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSlabType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSlabType > ExpressDataSet::createIfcSlabType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSlabType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSlabType * > (allocateIfcSlabType(this, Step::Id_UNSET));
    }
}

IfcSlabType *ExpressDataSet::cloneIfcSlabType(ExpressDataSet *expressDataSet, const IfcSlabType &obj, const CopyOp &copyop)
{
    IfcSlabType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSlabType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSlabType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSlabType *ExpressDataSet::cloneIfcSlabType(const IfcSlabType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSlabType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSlabType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSlabType  > &ExpressDataSet::getAllIfcSlabType ()
{
    return m_refIfcSlabTypeList;
}



IfcSlippageConnectionCondition *ExpressDataSet::getIfcSlippageConnectionCondition(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSlippageConnectionCondition * > (current->second.get());
    }
    else
    {
        IfcSlippageConnectionCondition *ret = static_cast< IfcSlippageConnectionCondition * > (allocateIfcSlippageConnectionCondition(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSlippageConnectionCondition(IfcSlippageConnectionCondition *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSlippageConnectionCondition_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSlippageConnectionCondition(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSlippageConnectionCondition *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSlippageConnectionCondition(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSlippageConnectionCondition_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSlippageConnectionCondition > ExpressDataSet::createIfcSlippageConnectionCondition(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSlippageConnectionCondition(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSlippageConnectionCondition * > (allocateIfcSlippageConnectionCondition(this, Step::Id_UNSET));
    }
}

IfcSlippageConnectionCondition *ExpressDataSet::cloneIfcSlippageConnectionCondition(ExpressDataSet *expressDataSet, const IfcSlippageConnectionCondition &obj, const CopyOp &copyop)
{
    IfcSlippageConnectionCondition *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSlippageConnectionCondition(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSlippageConnectionCondition_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSlippageConnectionCondition *ExpressDataSet::cloneIfcSlippageConnectionCondition(const IfcSlippageConnectionCondition &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSlippageConnectionCondition(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSlippageConnectionCondition(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSlippageConnectionCondition  > &ExpressDataSet::getAllIfcSlippageConnectionCondition ()
{
    return m_refIfcSlippageConnectionConditionList;
}



IfcSolidModel *ExpressDataSet::getIfcSolidModel(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSolidModel * > (current->second.get());
    }
    else
    {
        IfcSolidModel *ret = static_cast< IfcSolidModel * > (allocateIfcSolidModel(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSolidModel(IfcSolidModel *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSolidModel_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSolidModel(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSolidModel *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSolidModel(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSolidModel_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSolidModel > ExpressDataSet::createIfcSolidModel(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSolidModel(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSolidModel * > (allocateIfcSolidModel(this, Step::Id_UNSET));
    }
}

IfcSolidModel *ExpressDataSet::cloneIfcSolidModel(ExpressDataSet *expressDataSet, const IfcSolidModel &obj, const CopyOp &copyop)
{
    IfcSolidModel *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSolidModel(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSolidModel_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSolidModel *ExpressDataSet::cloneIfcSolidModel(const IfcSolidModel &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSolidModel(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSolidModel(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSolidModel  > &ExpressDataSet::getAllIfcSolidModel ()
{
    return m_refIfcSolidModelList;
}



IfcSoundProperties *ExpressDataSet::getIfcSoundProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSoundProperties * > (current->second.get());
    }
    else
    {
        IfcSoundProperties *ret = static_cast< IfcSoundProperties * > (allocateIfcSoundProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSoundProperties(IfcSoundProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSoundProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSoundProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSoundProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSoundProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSoundProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSoundProperties > ExpressDataSet::createIfcSoundProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSoundProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSoundProperties * > (allocateIfcSoundProperties(this, Step::Id_UNSET));
    }
}

IfcSoundProperties *ExpressDataSet::cloneIfcSoundProperties(ExpressDataSet *expressDataSet, const IfcSoundProperties &obj, const CopyOp &copyop)
{
    IfcSoundProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSoundProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSoundProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSoundProperties *ExpressDataSet::cloneIfcSoundProperties(const IfcSoundProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSoundProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSoundProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSoundProperties  > &ExpressDataSet::getAllIfcSoundProperties ()
{
    return m_refIfcSoundPropertiesList;
}



IfcSoundValue *ExpressDataSet::getIfcSoundValue(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSoundValue * > (current->second.get());
    }
    else
    {
        IfcSoundValue *ret = static_cast< IfcSoundValue * > (allocateIfcSoundValue(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSoundValue(IfcSoundValue *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSoundValue_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSoundValue(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSoundValue *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSoundValue(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSoundValue_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSoundValue > ExpressDataSet::createIfcSoundValue(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSoundValue(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSoundValue * > (allocateIfcSoundValue(this, Step::Id_UNSET));
    }
}

IfcSoundValue *ExpressDataSet::cloneIfcSoundValue(ExpressDataSet *expressDataSet, const IfcSoundValue &obj, const CopyOp &copyop)
{
    IfcSoundValue *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSoundValue(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSoundValue_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSoundValue *ExpressDataSet::cloneIfcSoundValue(const IfcSoundValue &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSoundValue(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSoundValue(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSoundValue  > &ExpressDataSet::getAllIfcSoundValue ()
{
    return m_refIfcSoundValueList;
}



IfcSpace *ExpressDataSet::getIfcSpace(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSpace * > (current->second.get());
    }
    else
    {
        IfcSpace *ret = static_cast< IfcSpace * > (allocateIfcSpace(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSpace(IfcSpace *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSpace_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSpace(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSpace *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSpace(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSpace_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSpace > ExpressDataSet::createIfcSpace(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSpace(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSpace * > (allocateIfcSpace(this, Step::Id_UNSET));
    }
}

IfcSpace *ExpressDataSet::cloneIfcSpace(ExpressDataSet *expressDataSet, const IfcSpace &obj, const CopyOp &copyop)
{
    IfcSpace *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSpace(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSpace_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSpace *ExpressDataSet::cloneIfcSpace(const IfcSpace &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSpace(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSpace(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSpace  > &ExpressDataSet::getAllIfcSpace ()
{
    return m_refIfcSpaceList;
}



IfcSpaceHeaterType *ExpressDataSet::getIfcSpaceHeaterType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSpaceHeaterType * > (current->second.get());
    }
    else
    {
        IfcSpaceHeaterType *ret = static_cast< IfcSpaceHeaterType * > (allocateIfcSpaceHeaterType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSpaceHeaterType(IfcSpaceHeaterType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSpaceHeaterType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSpaceHeaterType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSpaceHeaterType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSpaceHeaterType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSpaceHeaterType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSpaceHeaterType > ExpressDataSet::createIfcSpaceHeaterType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSpaceHeaterType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSpaceHeaterType * > (allocateIfcSpaceHeaterType(this, Step::Id_UNSET));
    }
}

IfcSpaceHeaterType *ExpressDataSet::cloneIfcSpaceHeaterType(ExpressDataSet *expressDataSet, const IfcSpaceHeaterType &obj, const CopyOp &copyop)
{
    IfcSpaceHeaterType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSpaceHeaterType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSpaceHeaterType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSpaceHeaterType *ExpressDataSet::cloneIfcSpaceHeaterType(const IfcSpaceHeaterType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSpaceHeaterType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSpaceHeaterType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSpaceHeaterType  > &ExpressDataSet::getAllIfcSpaceHeaterType ()
{
    return m_refIfcSpaceHeaterTypeList;
}



IfcSpaceProgram *ExpressDataSet::getIfcSpaceProgram(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSpaceProgram * > (current->second.get());
    }
    else
    {
        IfcSpaceProgram *ret = static_cast< IfcSpaceProgram * > (allocateIfcSpaceProgram(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSpaceProgram(IfcSpaceProgram *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSpaceProgram_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSpaceProgram(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSpaceProgram *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSpaceProgram(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSpaceProgram_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSpaceProgram > ExpressDataSet::createIfcSpaceProgram(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSpaceProgram(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSpaceProgram * > (allocateIfcSpaceProgram(this, Step::Id_UNSET));
    }
}

IfcSpaceProgram *ExpressDataSet::cloneIfcSpaceProgram(ExpressDataSet *expressDataSet, const IfcSpaceProgram &obj, const CopyOp &copyop)
{
    IfcSpaceProgram *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSpaceProgram(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSpaceProgram_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSpaceProgram *ExpressDataSet::cloneIfcSpaceProgram(const IfcSpaceProgram &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSpaceProgram(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSpaceProgram(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSpaceProgram  > &ExpressDataSet::getAllIfcSpaceProgram ()
{
    return m_refIfcSpaceProgramList;
}



IfcSpaceThermalLoadProperties *ExpressDataSet::getIfcSpaceThermalLoadProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSpaceThermalLoadProperties * > (current->second.get());
    }
    else
    {
        IfcSpaceThermalLoadProperties *ret = static_cast< IfcSpaceThermalLoadProperties * > (allocateIfcSpaceThermalLoadProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSpaceThermalLoadProperties(IfcSpaceThermalLoadProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSpaceThermalLoadProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSpaceThermalLoadProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSpaceThermalLoadProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSpaceThermalLoadProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSpaceThermalLoadProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSpaceThermalLoadProperties > ExpressDataSet::createIfcSpaceThermalLoadProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSpaceThermalLoadProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSpaceThermalLoadProperties * > (allocateIfcSpaceThermalLoadProperties(this, Step::Id_UNSET));
    }
}

IfcSpaceThermalLoadProperties *ExpressDataSet::cloneIfcSpaceThermalLoadProperties(ExpressDataSet *expressDataSet, const IfcSpaceThermalLoadProperties &obj, const CopyOp &copyop)
{
    IfcSpaceThermalLoadProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSpaceThermalLoadProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSpaceThermalLoadProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSpaceThermalLoadProperties *ExpressDataSet::cloneIfcSpaceThermalLoadProperties(const IfcSpaceThermalLoadProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSpaceThermalLoadProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSpaceThermalLoadProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSpaceThermalLoadProperties  > &ExpressDataSet::getAllIfcSpaceThermalLoadProperties ()
{
    return m_refIfcSpaceThermalLoadPropertiesList;
}



IfcSpaceType *ExpressDataSet::getIfcSpaceType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSpaceType * > (current->second.get());
    }
    else
    {
        IfcSpaceType *ret = static_cast< IfcSpaceType * > (allocateIfcSpaceType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSpaceType(IfcSpaceType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSpaceType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSpaceType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSpaceType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSpaceType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSpaceType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSpaceType > ExpressDataSet::createIfcSpaceType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSpaceType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSpaceType * > (allocateIfcSpaceType(this, Step::Id_UNSET));
    }
}

IfcSpaceType *ExpressDataSet::cloneIfcSpaceType(ExpressDataSet *expressDataSet, const IfcSpaceType &obj, const CopyOp &copyop)
{
    IfcSpaceType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSpaceType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSpaceType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSpaceType *ExpressDataSet::cloneIfcSpaceType(const IfcSpaceType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSpaceType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSpaceType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSpaceType  > &ExpressDataSet::getAllIfcSpaceType ()
{
    return m_refIfcSpaceTypeList;
}



IfcSpatialStructureElement *ExpressDataSet::getIfcSpatialStructureElement(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSpatialStructureElement * > (current->second.get());
    }
    else
    {
        IfcSpatialStructureElement *ret = static_cast< IfcSpatialStructureElement * > (allocateIfcSpatialStructureElement(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSpatialStructureElement(IfcSpatialStructureElement *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSpatialStructureElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSpatialStructureElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSpatialStructureElement *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSpatialStructureElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSpatialStructureElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSpatialStructureElement > ExpressDataSet::createIfcSpatialStructureElement(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSpatialStructureElement(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSpatialStructureElement * > (allocateIfcSpatialStructureElement(this, Step::Id_UNSET));
    }
}

IfcSpatialStructureElement *ExpressDataSet::cloneIfcSpatialStructureElement(ExpressDataSet *expressDataSet, const IfcSpatialStructureElement &obj, const CopyOp &copyop)
{
    IfcSpatialStructureElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSpatialStructureElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSpatialStructureElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSpatialStructureElement *ExpressDataSet::cloneIfcSpatialStructureElement(const IfcSpatialStructureElement &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSpatialStructureElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSpatialStructureElement(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSpatialStructureElement  > &ExpressDataSet::getAllIfcSpatialStructureElement ()
{
    return m_refIfcSpatialStructureElementList;
}



IfcSpatialStructureElementType *ExpressDataSet::getIfcSpatialStructureElementType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSpatialStructureElementType * > (current->second.get());
    }
    else
    {
        IfcSpatialStructureElementType *ret = static_cast< IfcSpatialStructureElementType * > (allocateIfcSpatialStructureElementType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSpatialStructureElementType(IfcSpatialStructureElementType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSpatialStructureElementType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSpatialStructureElementType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSpatialStructureElementType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSpatialStructureElementType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSpatialStructureElementType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSpatialStructureElementType > ExpressDataSet::createIfcSpatialStructureElementType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSpatialStructureElementType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSpatialStructureElementType * > (allocateIfcSpatialStructureElementType(this, Step::Id_UNSET));
    }
}

IfcSpatialStructureElementType *ExpressDataSet::cloneIfcSpatialStructureElementType(ExpressDataSet *expressDataSet, const IfcSpatialStructureElementType &obj, const CopyOp &copyop)
{
    IfcSpatialStructureElementType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSpatialStructureElementType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSpatialStructureElementType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSpatialStructureElementType *ExpressDataSet::cloneIfcSpatialStructureElementType(const IfcSpatialStructureElementType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSpatialStructureElementType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSpatialStructureElementType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSpatialStructureElementType  > &ExpressDataSet::getAllIfcSpatialStructureElementType ()
{
    return m_refIfcSpatialStructureElementTypeList;
}



IfcSphere *ExpressDataSet::getIfcSphere(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSphere * > (current->second.get());
    }
    else
    {
        IfcSphere *ret = static_cast< IfcSphere * > (allocateIfcSphere(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSphere(IfcSphere *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSphere_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSphere(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSphere *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSphere(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSphere_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSphere > ExpressDataSet::createIfcSphere(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSphere(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSphere * > (allocateIfcSphere(this, Step::Id_UNSET));
    }
}

IfcSphere *ExpressDataSet::cloneIfcSphere(ExpressDataSet *expressDataSet, const IfcSphere &obj, const CopyOp &copyop)
{
    IfcSphere *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSphere(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSphere_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSphere *ExpressDataSet::cloneIfcSphere(const IfcSphere &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSphere(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSphere(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSphere  > &ExpressDataSet::getAllIfcSphere ()
{
    return m_refIfcSphereList;
}



IfcStackTerminalType *ExpressDataSet::getIfcStackTerminalType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStackTerminalType * > (current->second.get());
    }
    else
    {
        IfcStackTerminalType *ret = static_cast< IfcStackTerminalType * > (allocateIfcStackTerminalType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStackTerminalType(IfcStackTerminalType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStackTerminalType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStackTerminalType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStackTerminalType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStackTerminalType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStackTerminalType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStackTerminalType > ExpressDataSet::createIfcStackTerminalType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStackTerminalType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStackTerminalType * > (allocateIfcStackTerminalType(this, Step::Id_UNSET));
    }
}

IfcStackTerminalType *ExpressDataSet::cloneIfcStackTerminalType(ExpressDataSet *expressDataSet, const IfcStackTerminalType &obj, const CopyOp &copyop)
{
    IfcStackTerminalType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStackTerminalType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStackTerminalType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStackTerminalType *ExpressDataSet::cloneIfcStackTerminalType(const IfcStackTerminalType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStackTerminalType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStackTerminalType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStackTerminalType  > &ExpressDataSet::getAllIfcStackTerminalType ()
{
    return m_refIfcStackTerminalTypeList;
}



IfcStair *ExpressDataSet::getIfcStair(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStair * > (current->second.get());
    }
    else
    {
        IfcStair *ret = static_cast< IfcStair * > (allocateIfcStair(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStair(IfcStair *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStair_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStair(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStair *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStair(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStair_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStair > ExpressDataSet::createIfcStair(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStair(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStair * > (allocateIfcStair(this, Step::Id_UNSET));
    }
}

IfcStair *ExpressDataSet::cloneIfcStair(ExpressDataSet *expressDataSet, const IfcStair &obj, const CopyOp &copyop)
{
    IfcStair *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStair(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStair_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStair *ExpressDataSet::cloneIfcStair(const IfcStair &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStair(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStair(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStair  > &ExpressDataSet::getAllIfcStair ()
{
    return m_refIfcStairList;
}



IfcStairFlight *ExpressDataSet::getIfcStairFlight(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStairFlight * > (current->second.get());
    }
    else
    {
        IfcStairFlight *ret = static_cast< IfcStairFlight * > (allocateIfcStairFlight(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStairFlight(IfcStairFlight *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStairFlight_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStairFlight(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStairFlight *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStairFlight(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStairFlight_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStairFlight > ExpressDataSet::createIfcStairFlight(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStairFlight(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStairFlight * > (allocateIfcStairFlight(this, Step::Id_UNSET));
    }
}

IfcStairFlight *ExpressDataSet::cloneIfcStairFlight(ExpressDataSet *expressDataSet, const IfcStairFlight &obj, const CopyOp &copyop)
{
    IfcStairFlight *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStairFlight(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStairFlight_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStairFlight *ExpressDataSet::cloneIfcStairFlight(const IfcStairFlight &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStairFlight(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStairFlight(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStairFlight  > &ExpressDataSet::getAllIfcStairFlight ()
{
    return m_refIfcStairFlightList;
}



IfcStairFlightType *ExpressDataSet::getIfcStairFlightType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStairFlightType * > (current->second.get());
    }
    else
    {
        IfcStairFlightType *ret = static_cast< IfcStairFlightType * > (allocateIfcStairFlightType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStairFlightType(IfcStairFlightType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStairFlightType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStairFlightType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStairFlightType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStairFlightType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStairFlightType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStairFlightType > ExpressDataSet::createIfcStairFlightType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStairFlightType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStairFlightType * > (allocateIfcStairFlightType(this, Step::Id_UNSET));
    }
}

IfcStairFlightType *ExpressDataSet::cloneIfcStairFlightType(ExpressDataSet *expressDataSet, const IfcStairFlightType &obj, const CopyOp &copyop)
{
    IfcStairFlightType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStairFlightType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStairFlightType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStairFlightType *ExpressDataSet::cloneIfcStairFlightType(const IfcStairFlightType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStairFlightType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStairFlightType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStairFlightType  > &ExpressDataSet::getAllIfcStairFlightType ()
{
    return m_refIfcStairFlightTypeList;
}



IfcStructuralAction *ExpressDataSet::getIfcStructuralAction(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralAction * > (current->second.get());
    }
    else
    {
        IfcStructuralAction *ret = static_cast< IfcStructuralAction * > (allocateIfcStructuralAction(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralAction(IfcStructuralAction *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralAction_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralAction(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralAction *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralAction(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralAction_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralAction > ExpressDataSet::createIfcStructuralAction(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralAction(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralAction * > (allocateIfcStructuralAction(this, Step::Id_UNSET));
    }
}

IfcStructuralAction *ExpressDataSet::cloneIfcStructuralAction(ExpressDataSet *expressDataSet, const IfcStructuralAction &obj, const CopyOp &copyop)
{
    IfcStructuralAction *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralAction(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralAction_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralAction *ExpressDataSet::cloneIfcStructuralAction(const IfcStructuralAction &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralAction(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralAction(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralAction  > &ExpressDataSet::getAllIfcStructuralAction ()
{
    return m_refIfcStructuralActionList;
}



IfcStructuralActivity *ExpressDataSet::getIfcStructuralActivity(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralActivity * > (current->second.get());
    }
    else
    {
        IfcStructuralActivity *ret = static_cast< IfcStructuralActivity * > (allocateIfcStructuralActivity(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralActivity(IfcStructuralActivity *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralActivity_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralActivity(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralActivity *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralActivity(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralActivity_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralActivity > ExpressDataSet::createIfcStructuralActivity(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralActivity(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralActivity * > (allocateIfcStructuralActivity(this, Step::Id_UNSET));
    }
}

IfcStructuralActivity *ExpressDataSet::cloneIfcStructuralActivity(ExpressDataSet *expressDataSet, const IfcStructuralActivity &obj, const CopyOp &copyop)
{
    IfcStructuralActivity *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralActivity(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralActivity_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralActivity *ExpressDataSet::cloneIfcStructuralActivity(const IfcStructuralActivity &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralActivity(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralActivity(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralActivity  > &ExpressDataSet::getAllIfcStructuralActivity ()
{
    return m_refIfcStructuralActivityList;
}



IfcStructuralAnalysisModel *ExpressDataSet::getIfcStructuralAnalysisModel(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralAnalysisModel * > (current->second.get());
    }
    else
    {
        IfcStructuralAnalysisModel *ret = static_cast< IfcStructuralAnalysisModel * > (allocateIfcStructuralAnalysisModel(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralAnalysisModel(IfcStructuralAnalysisModel *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralAnalysisModel_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralAnalysisModel(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralAnalysisModel *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralAnalysisModel(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralAnalysisModel_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralAnalysisModel > ExpressDataSet::createIfcStructuralAnalysisModel(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralAnalysisModel(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralAnalysisModel * > (allocateIfcStructuralAnalysisModel(this, Step::Id_UNSET));
    }
}

IfcStructuralAnalysisModel *ExpressDataSet::cloneIfcStructuralAnalysisModel(ExpressDataSet *expressDataSet, const IfcStructuralAnalysisModel &obj, const CopyOp &copyop)
{
    IfcStructuralAnalysisModel *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralAnalysisModel(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralAnalysisModel_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralAnalysisModel *ExpressDataSet::cloneIfcStructuralAnalysisModel(const IfcStructuralAnalysisModel &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralAnalysisModel(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralAnalysisModel(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralAnalysisModel  > &ExpressDataSet::getAllIfcStructuralAnalysisModel ()
{
    return m_refIfcStructuralAnalysisModelList;
}



IfcStructuralConnection *ExpressDataSet::getIfcStructuralConnection(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralConnection * > (current->second.get());
    }
    else
    {
        IfcStructuralConnection *ret = static_cast< IfcStructuralConnection * > (allocateIfcStructuralConnection(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralConnection(IfcStructuralConnection *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralConnection_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralConnection(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralConnection *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralConnection(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralConnection_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralConnection > ExpressDataSet::createIfcStructuralConnection(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralConnection(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralConnection * > (allocateIfcStructuralConnection(this, Step::Id_UNSET));
    }
}

IfcStructuralConnection *ExpressDataSet::cloneIfcStructuralConnection(ExpressDataSet *expressDataSet, const IfcStructuralConnection &obj, const CopyOp &copyop)
{
    IfcStructuralConnection *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralConnection(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralConnection_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralConnection *ExpressDataSet::cloneIfcStructuralConnection(const IfcStructuralConnection &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralConnection(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralConnection(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralConnection  > &ExpressDataSet::getAllIfcStructuralConnection ()
{
    return m_refIfcStructuralConnectionList;
}



IfcStructuralConnectionCondition *ExpressDataSet::getIfcStructuralConnectionCondition(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralConnectionCondition * > (current->second.get());
    }
    else
    {
        IfcStructuralConnectionCondition *ret = static_cast< IfcStructuralConnectionCondition * > (allocateIfcStructuralConnectionCondition(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralConnectionCondition(IfcStructuralConnectionCondition *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralConnectionCondition_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralConnectionCondition(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralConnectionCondition *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralConnectionCondition(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralConnectionCondition_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralConnectionCondition > ExpressDataSet::createIfcStructuralConnectionCondition(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralConnectionCondition(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralConnectionCondition * > (allocateIfcStructuralConnectionCondition(this, Step::Id_UNSET));
    }
}

IfcStructuralConnectionCondition *ExpressDataSet::cloneIfcStructuralConnectionCondition(ExpressDataSet *expressDataSet, const IfcStructuralConnectionCondition &obj, const CopyOp &copyop)
{
    IfcStructuralConnectionCondition *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralConnectionCondition(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralConnectionCondition_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralConnectionCondition *ExpressDataSet::cloneIfcStructuralConnectionCondition(const IfcStructuralConnectionCondition &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralConnectionCondition(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralConnectionCondition(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralConnectionCondition  > &ExpressDataSet::getAllIfcStructuralConnectionCondition ()
{
    return m_refIfcStructuralConnectionConditionList;
}



IfcStructuralCurveConnection *ExpressDataSet::getIfcStructuralCurveConnection(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralCurveConnection * > (current->second.get());
    }
    else
    {
        IfcStructuralCurveConnection *ret = static_cast< IfcStructuralCurveConnection * > (allocateIfcStructuralCurveConnection(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralCurveConnection(IfcStructuralCurveConnection *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralCurveConnection_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralCurveConnection(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralCurveConnection *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralCurveConnection(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralCurveConnection_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralCurveConnection > ExpressDataSet::createIfcStructuralCurveConnection(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralCurveConnection(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralCurveConnection * > (allocateIfcStructuralCurveConnection(this, Step::Id_UNSET));
    }
}

IfcStructuralCurveConnection *ExpressDataSet::cloneIfcStructuralCurveConnection(ExpressDataSet *expressDataSet, const IfcStructuralCurveConnection &obj, const CopyOp &copyop)
{
    IfcStructuralCurveConnection *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralCurveConnection(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralCurveConnection_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralCurveConnection *ExpressDataSet::cloneIfcStructuralCurveConnection(const IfcStructuralCurveConnection &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralCurveConnection(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralCurveConnection(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralCurveConnection  > &ExpressDataSet::getAllIfcStructuralCurveConnection ()
{
    return m_refIfcStructuralCurveConnectionList;
}



IfcStructuralCurveMember *ExpressDataSet::getIfcStructuralCurveMember(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralCurveMember * > (current->second.get());
    }
    else
    {
        IfcStructuralCurveMember *ret = static_cast< IfcStructuralCurveMember * > (allocateIfcStructuralCurveMember(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralCurveMember(IfcStructuralCurveMember *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralCurveMember_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralCurveMember(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralCurveMember *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralCurveMember(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralCurveMember_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralCurveMember > ExpressDataSet::createIfcStructuralCurveMember(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralCurveMember(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralCurveMember * > (allocateIfcStructuralCurveMember(this, Step::Id_UNSET));
    }
}

IfcStructuralCurveMember *ExpressDataSet::cloneIfcStructuralCurveMember(ExpressDataSet *expressDataSet, const IfcStructuralCurveMember &obj, const CopyOp &copyop)
{
    IfcStructuralCurveMember *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralCurveMember(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralCurveMember_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralCurveMember *ExpressDataSet::cloneIfcStructuralCurveMember(const IfcStructuralCurveMember &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralCurveMember(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralCurveMember(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralCurveMember  > &ExpressDataSet::getAllIfcStructuralCurveMember ()
{
    return m_refIfcStructuralCurveMemberList;
}



IfcStructuralCurveMemberVarying *ExpressDataSet::getIfcStructuralCurveMemberVarying(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralCurveMemberVarying * > (current->second.get());
    }
    else
    {
        IfcStructuralCurveMemberVarying *ret = static_cast< IfcStructuralCurveMemberVarying * > (allocateIfcStructuralCurveMemberVarying(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralCurveMemberVarying(IfcStructuralCurveMemberVarying *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralCurveMemberVarying_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralCurveMemberVarying(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralCurveMemberVarying *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralCurveMemberVarying(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralCurveMemberVarying_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralCurveMemberVarying > ExpressDataSet::createIfcStructuralCurveMemberVarying(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralCurveMemberVarying(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralCurveMemberVarying * > (allocateIfcStructuralCurveMemberVarying(this, Step::Id_UNSET));
    }
}

IfcStructuralCurveMemberVarying *ExpressDataSet::cloneIfcStructuralCurveMemberVarying(ExpressDataSet *expressDataSet, const IfcStructuralCurveMemberVarying &obj, const CopyOp &copyop)
{
    IfcStructuralCurveMemberVarying *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralCurveMemberVarying(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralCurveMemberVarying_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralCurveMemberVarying *ExpressDataSet::cloneIfcStructuralCurveMemberVarying(const IfcStructuralCurveMemberVarying &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralCurveMemberVarying(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralCurveMemberVarying(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralCurveMemberVarying  > &ExpressDataSet::getAllIfcStructuralCurveMemberVarying ()
{
    return m_refIfcStructuralCurveMemberVaryingList;
}



IfcStructuralItem *ExpressDataSet::getIfcStructuralItem(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralItem * > (current->second.get());
    }
    else
    {
        IfcStructuralItem *ret = static_cast< IfcStructuralItem * > (allocateIfcStructuralItem(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralItem(IfcStructuralItem *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralItem_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralItem(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralItem *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralItem(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralItem_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralItem > ExpressDataSet::createIfcStructuralItem(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralItem(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralItem * > (allocateIfcStructuralItem(this, Step::Id_UNSET));
    }
}

IfcStructuralItem *ExpressDataSet::cloneIfcStructuralItem(ExpressDataSet *expressDataSet, const IfcStructuralItem &obj, const CopyOp &copyop)
{
    IfcStructuralItem *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralItem(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralItem_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralItem *ExpressDataSet::cloneIfcStructuralItem(const IfcStructuralItem &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralItem(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralItem(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralItem  > &ExpressDataSet::getAllIfcStructuralItem ()
{
    return m_refIfcStructuralItemList;
}



IfcStructuralLinearAction *ExpressDataSet::getIfcStructuralLinearAction(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralLinearAction * > (current->second.get());
    }
    else
    {
        IfcStructuralLinearAction *ret = static_cast< IfcStructuralLinearAction * > (allocateIfcStructuralLinearAction(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralLinearAction(IfcStructuralLinearAction *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralLinearAction_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralLinearAction(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralLinearAction *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralLinearAction(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralLinearAction_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralLinearAction > ExpressDataSet::createIfcStructuralLinearAction(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralLinearAction(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralLinearAction * > (allocateIfcStructuralLinearAction(this, Step::Id_UNSET));
    }
}

IfcStructuralLinearAction *ExpressDataSet::cloneIfcStructuralLinearAction(ExpressDataSet *expressDataSet, const IfcStructuralLinearAction &obj, const CopyOp &copyop)
{
    IfcStructuralLinearAction *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralLinearAction(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralLinearAction_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralLinearAction *ExpressDataSet::cloneIfcStructuralLinearAction(const IfcStructuralLinearAction &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralLinearAction(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralLinearAction(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralLinearAction  > &ExpressDataSet::getAllIfcStructuralLinearAction ()
{
    return m_refIfcStructuralLinearActionList;
}



IfcStructuralLinearActionVarying *ExpressDataSet::getIfcStructuralLinearActionVarying(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralLinearActionVarying * > (current->second.get());
    }
    else
    {
        IfcStructuralLinearActionVarying *ret = static_cast< IfcStructuralLinearActionVarying * > (allocateIfcStructuralLinearActionVarying(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralLinearActionVarying(IfcStructuralLinearActionVarying *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralLinearActionVarying_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralLinearActionVarying(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralLinearActionVarying *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralLinearActionVarying(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralLinearActionVarying_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralLinearActionVarying > ExpressDataSet::createIfcStructuralLinearActionVarying(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralLinearActionVarying(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralLinearActionVarying * > (allocateIfcStructuralLinearActionVarying(this, Step::Id_UNSET));
    }
}

IfcStructuralLinearActionVarying *ExpressDataSet::cloneIfcStructuralLinearActionVarying(ExpressDataSet *expressDataSet, const IfcStructuralLinearActionVarying &obj, const CopyOp &copyop)
{
    IfcStructuralLinearActionVarying *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralLinearActionVarying(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralLinearActionVarying_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralLinearActionVarying *ExpressDataSet::cloneIfcStructuralLinearActionVarying(const IfcStructuralLinearActionVarying &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralLinearActionVarying(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralLinearActionVarying(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralLinearActionVarying  > &ExpressDataSet::getAllIfcStructuralLinearActionVarying ()
{
    return m_refIfcStructuralLinearActionVaryingList;
}



IfcStructuralLoad *ExpressDataSet::getIfcStructuralLoad(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralLoad * > (current->second.get());
    }
    else
    {
        IfcStructuralLoad *ret = static_cast< IfcStructuralLoad * > (allocateIfcStructuralLoad(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralLoad(IfcStructuralLoad *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralLoad_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralLoad(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralLoad *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralLoad(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralLoad_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralLoad > ExpressDataSet::createIfcStructuralLoad(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralLoad(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralLoad * > (allocateIfcStructuralLoad(this, Step::Id_UNSET));
    }
}

IfcStructuralLoad *ExpressDataSet::cloneIfcStructuralLoad(ExpressDataSet *expressDataSet, const IfcStructuralLoad &obj, const CopyOp &copyop)
{
    IfcStructuralLoad *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralLoad(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralLoad_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralLoad *ExpressDataSet::cloneIfcStructuralLoad(const IfcStructuralLoad &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralLoad(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralLoad(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralLoad  > &ExpressDataSet::getAllIfcStructuralLoad ()
{
    return m_refIfcStructuralLoadList;
}



IfcStructuralLoadGroup *ExpressDataSet::getIfcStructuralLoadGroup(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralLoadGroup * > (current->second.get());
    }
    else
    {
        IfcStructuralLoadGroup *ret = static_cast< IfcStructuralLoadGroup * > (allocateIfcStructuralLoadGroup(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralLoadGroup(IfcStructuralLoadGroup *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralLoadGroup_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralLoadGroup(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralLoadGroup *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralLoadGroup(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralLoadGroup_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralLoadGroup > ExpressDataSet::createIfcStructuralLoadGroup(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralLoadGroup(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralLoadGroup * > (allocateIfcStructuralLoadGroup(this, Step::Id_UNSET));
    }
}

IfcStructuralLoadGroup *ExpressDataSet::cloneIfcStructuralLoadGroup(ExpressDataSet *expressDataSet, const IfcStructuralLoadGroup &obj, const CopyOp &copyop)
{
    IfcStructuralLoadGroup *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralLoadGroup(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralLoadGroup_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralLoadGroup *ExpressDataSet::cloneIfcStructuralLoadGroup(const IfcStructuralLoadGroup &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralLoadGroup(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralLoadGroup(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralLoadGroup  > &ExpressDataSet::getAllIfcStructuralLoadGroup ()
{
    return m_refIfcStructuralLoadGroupList;
}



IfcStructuralLoadLinearForce *ExpressDataSet::getIfcStructuralLoadLinearForce(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralLoadLinearForce * > (current->second.get());
    }
    else
    {
        IfcStructuralLoadLinearForce *ret = static_cast< IfcStructuralLoadLinearForce * > (allocateIfcStructuralLoadLinearForce(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralLoadLinearForce(IfcStructuralLoadLinearForce *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralLoadLinearForce_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralLoadLinearForce(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralLoadLinearForce *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralLoadLinearForce(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralLoadLinearForce_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralLoadLinearForce > ExpressDataSet::createIfcStructuralLoadLinearForce(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralLoadLinearForce(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralLoadLinearForce * > (allocateIfcStructuralLoadLinearForce(this, Step::Id_UNSET));
    }
}

IfcStructuralLoadLinearForce *ExpressDataSet::cloneIfcStructuralLoadLinearForce(ExpressDataSet *expressDataSet, const IfcStructuralLoadLinearForce &obj, const CopyOp &copyop)
{
    IfcStructuralLoadLinearForce *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralLoadLinearForce(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralLoadLinearForce_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralLoadLinearForce *ExpressDataSet::cloneIfcStructuralLoadLinearForce(const IfcStructuralLoadLinearForce &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralLoadLinearForce(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralLoadLinearForce(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralLoadLinearForce  > &ExpressDataSet::getAllIfcStructuralLoadLinearForce ()
{
    return m_refIfcStructuralLoadLinearForceList;
}



IfcStructuralLoadPlanarForce *ExpressDataSet::getIfcStructuralLoadPlanarForce(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralLoadPlanarForce * > (current->second.get());
    }
    else
    {
        IfcStructuralLoadPlanarForce *ret = static_cast< IfcStructuralLoadPlanarForce * > (allocateIfcStructuralLoadPlanarForce(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralLoadPlanarForce(IfcStructuralLoadPlanarForce *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralLoadPlanarForce_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralLoadPlanarForce(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralLoadPlanarForce *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralLoadPlanarForce(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralLoadPlanarForce_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralLoadPlanarForce > ExpressDataSet::createIfcStructuralLoadPlanarForce(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralLoadPlanarForce(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralLoadPlanarForce * > (allocateIfcStructuralLoadPlanarForce(this, Step::Id_UNSET));
    }
}

IfcStructuralLoadPlanarForce *ExpressDataSet::cloneIfcStructuralLoadPlanarForce(ExpressDataSet *expressDataSet, const IfcStructuralLoadPlanarForce &obj, const CopyOp &copyop)
{
    IfcStructuralLoadPlanarForce *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralLoadPlanarForce(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralLoadPlanarForce_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralLoadPlanarForce *ExpressDataSet::cloneIfcStructuralLoadPlanarForce(const IfcStructuralLoadPlanarForce &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralLoadPlanarForce(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralLoadPlanarForce(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralLoadPlanarForce  > &ExpressDataSet::getAllIfcStructuralLoadPlanarForce ()
{
    return m_refIfcStructuralLoadPlanarForceList;
}



IfcStructuralLoadSingleDisplacement *ExpressDataSet::getIfcStructuralLoadSingleDisplacement(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralLoadSingleDisplacement * > (current->second.get());
    }
    else
    {
        IfcStructuralLoadSingleDisplacement *ret = static_cast< IfcStructuralLoadSingleDisplacement * > (allocateIfcStructuralLoadSingleDisplacement(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralLoadSingleDisplacement(IfcStructuralLoadSingleDisplacement *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralLoadSingleDisplacement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralLoadSingleDisplacement(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralLoadSingleDisplacement *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralLoadSingleDisplacement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralLoadSingleDisplacement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralLoadSingleDisplacement > ExpressDataSet::createIfcStructuralLoadSingleDisplacement(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralLoadSingleDisplacement(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralLoadSingleDisplacement * > (allocateIfcStructuralLoadSingleDisplacement(this, Step::Id_UNSET));
    }
}

IfcStructuralLoadSingleDisplacement *ExpressDataSet::cloneIfcStructuralLoadSingleDisplacement(ExpressDataSet *expressDataSet, const IfcStructuralLoadSingleDisplacement &obj, const CopyOp &copyop)
{
    IfcStructuralLoadSingleDisplacement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralLoadSingleDisplacement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralLoadSingleDisplacement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralLoadSingleDisplacement *ExpressDataSet::cloneIfcStructuralLoadSingleDisplacement(const IfcStructuralLoadSingleDisplacement &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralLoadSingleDisplacement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralLoadSingleDisplacement(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralLoadSingleDisplacement  > &ExpressDataSet::getAllIfcStructuralLoadSingleDisplacement ()
{
    return m_refIfcStructuralLoadSingleDisplacementList;
}



IfcStructuralLoadSingleDisplacementDistortion *ExpressDataSet::getIfcStructuralLoadSingleDisplacementDistortion(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralLoadSingleDisplacementDistortion * > (current->second.get());
    }
    else
    {
        IfcStructuralLoadSingleDisplacementDistortion *ret = static_cast< IfcStructuralLoadSingleDisplacementDistortion * > (allocateIfcStructuralLoadSingleDisplacementDistortion(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralLoadSingleDisplacementDistortion(IfcStructuralLoadSingleDisplacementDistortion *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralLoadSingleDisplacementDistortion_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralLoadSingleDisplacementDistortion(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralLoadSingleDisplacementDistortion *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralLoadSingleDisplacementDistortion(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralLoadSingleDisplacementDistortion_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralLoadSingleDisplacementDistortion > ExpressDataSet::createIfcStructuralLoadSingleDisplacementDistortion(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralLoadSingleDisplacementDistortion(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralLoadSingleDisplacementDistortion * > (allocateIfcStructuralLoadSingleDisplacementDistortion(this, Step::Id_UNSET));
    }
}

IfcStructuralLoadSingleDisplacementDistortion *ExpressDataSet::cloneIfcStructuralLoadSingleDisplacementDistortion(ExpressDataSet *expressDataSet, const IfcStructuralLoadSingleDisplacementDistortion &obj, const CopyOp &copyop)
{
    IfcStructuralLoadSingleDisplacementDistortion *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralLoadSingleDisplacementDistortion(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralLoadSingleDisplacementDistortion_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralLoadSingleDisplacementDistortion *ExpressDataSet::cloneIfcStructuralLoadSingleDisplacementDistortion(const IfcStructuralLoadSingleDisplacementDistortion &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralLoadSingleDisplacementDistortion(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralLoadSingleDisplacementDistortion(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralLoadSingleDisplacementDistortion  > &ExpressDataSet::getAllIfcStructuralLoadSingleDisplacementDistortion ()
{
    return m_refIfcStructuralLoadSingleDisplacementDistortionList;
}



IfcStructuralLoadSingleForce *ExpressDataSet::getIfcStructuralLoadSingleForce(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralLoadSingleForce * > (current->second.get());
    }
    else
    {
        IfcStructuralLoadSingleForce *ret = static_cast< IfcStructuralLoadSingleForce * > (allocateIfcStructuralLoadSingleForce(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralLoadSingleForce(IfcStructuralLoadSingleForce *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralLoadSingleForce_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralLoadSingleForce(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralLoadSingleForce *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralLoadSingleForce(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralLoadSingleForce_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralLoadSingleForce > ExpressDataSet::createIfcStructuralLoadSingleForce(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralLoadSingleForce(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralLoadSingleForce * > (allocateIfcStructuralLoadSingleForce(this, Step::Id_UNSET));
    }
}

IfcStructuralLoadSingleForce *ExpressDataSet::cloneIfcStructuralLoadSingleForce(ExpressDataSet *expressDataSet, const IfcStructuralLoadSingleForce &obj, const CopyOp &copyop)
{
    IfcStructuralLoadSingleForce *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralLoadSingleForce(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralLoadSingleForce_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralLoadSingleForce *ExpressDataSet::cloneIfcStructuralLoadSingleForce(const IfcStructuralLoadSingleForce &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralLoadSingleForce(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralLoadSingleForce(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralLoadSingleForce  > &ExpressDataSet::getAllIfcStructuralLoadSingleForce ()
{
    return m_refIfcStructuralLoadSingleForceList;
}



IfcStructuralLoadSingleForceWarping *ExpressDataSet::getIfcStructuralLoadSingleForceWarping(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralLoadSingleForceWarping * > (current->second.get());
    }
    else
    {
        IfcStructuralLoadSingleForceWarping *ret = static_cast< IfcStructuralLoadSingleForceWarping * > (allocateIfcStructuralLoadSingleForceWarping(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralLoadSingleForceWarping(IfcStructuralLoadSingleForceWarping *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralLoadSingleForceWarping_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralLoadSingleForceWarping(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralLoadSingleForceWarping *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralLoadSingleForceWarping(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralLoadSingleForceWarping_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralLoadSingleForceWarping > ExpressDataSet::createIfcStructuralLoadSingleForceWarping(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralLoadSingleForceWarping(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralLoadSingleForceWarping * > (allocateIfcStructuralLoadSingleForceWarping(this, Step::Id_UNSET));
    }
}

IfcStructuralLoadSingleForceWarping *ExpressDataSet::cloneIfcStructuralLoadSingleForceWarping(ExpressDataSet *expressDataSet, const IfcStructuralLoadSingleForceWarping &obj, const CopyOp &copyop)
{
    IfcStructuralLoadSingleForceWarping *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralLoadSingleForceWarping(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralLoadSingleForceWarping_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralLoadSingleForceWarping *ExpressDataSet::cloneIfcStructuralLoadSingleForceWarping(const IfcStructuralLoadSingleForceWarping &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralLoadSingleForceWarping(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralLoadSingleForceWarping(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralLoadSingleForceWarping  > &ExpressDataSet::getAllIfcStructuralLoadSingleForceWarping ()
{
    return m_refIfcStructuralLoadSingleForceWarpingList;
}



IfcStructuralLoadStatic *ExpressDataSet::getIfcStructuralLoadStatic(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralLoadStatic * > (current->second.get());
    }
    else
    {
        IfcStructuralLoadStatic *ret = static_cast< IfcStructuralLoadStatic * > (allocateIfcStructuralLoadStatic(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralLoadStatic(IfcStructuralLoadStatic *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralLoadStatic_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralLoadStatic(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralLoadStatic *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralLoadStatic(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralLoadStatic_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralLoadStatic > ExpressDataSet::createIfcStructuralLoadStatic(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralLoadStatic(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralLoadStatic * > (allocateIfcStructuralLoadStatic(this, Step::Id_UNSET));
    }
}

IfcStructuralLoadStatic *ExpressDataSet::cloneIfcStructuralLoadStatic(ExpressDataSet *expressDataSet, const IfcStructuralLoadStatic &obj, const CopyOp &copyop)
{
    IfcStructuralLoadStatic *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralLoadStatic(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralLoadStatic_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralLoadStatic *ExpressDataSet::cloneIfcStructuralLoadStatic(const IfcStructuralLoadStatic &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralLoadStatic(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralLoadStatic(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralLoadStatic  > &ExpressDataSet::getAllIfcStructuralLoadStatic ()
{
    return m_refIfcStructuralLoadStaticList;
}



IfcStructuralLoadTemperature *ExpressDataSet::getIfcStructuralLoadTemperature(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralLoadTemperature * > (current->second.get());
    }
    else
    {
        IfcStructuralLoadTemperature *ret = static_cast< IfcStructuralLoadTemperature * > (allocateIfcStructuralLoadTemperature(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralLoadTemperature(IfcStructuralLoadTemperature *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralLoadTemperature_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralLoadTemperature(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralLoadTemperature *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralLoadTemperature(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralLoadTemperature_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralLoadTemperature > ExpressDataSet::createIfcStructuralLoadTemperature(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralLoadTemperature(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralLoadTemperature * > (allocateIfcStructuralLoadTemperature(this, Step::Id_UNSET));
    }
}

IfcStructuralLoadTemperature *ExpressDataSet::cloneIfcStructuralLoadTemperature(ExpressDataSet *expressDataSet, const IfcStructuralLoadTemperature &obj, const CopyOp &copyop)
{
    IfcStructuralLoadTemperature *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralLoadTemperature(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralLoadTemperature_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralLoadTemperature *ExpressDataSet::cloneIfcStructuralLoadTemperature(const IfcStructuralLoadTemperature &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralLoadTemperature(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralLoadTemperature(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralLoadTemperature  > &ExpressDataSet::getAllIfcStructuralLoadTemperature ()
{
    return m_refIfcStructuralLoadTemperatureList;
}



IfcStructuralMember *ExpressDataSet::getIfcStructuralMember(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralMember * > (current->second.get());
    }
    else
    {
        IfcStructuralMember *ret = static_cast< IfcStructuralMember * > (allocateIfcStructuralMember(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralMember(IfcStructuralMember *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralMember_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralMember(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralMember *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralMember(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralMember_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralMember > ExpressDataSet::createIfcStructuralMember(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralMember(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralMember * > (allocateIfcStructuralMember(this, Step::Id_UNSET));
    }
}

IfcStructuralMember *ExpressDataSet::cloneIfcStructuralMember(ExpressDataSet *expressDataSet, const IfcStructuralMember &obj, const CopyOp &copyop)
{
    IfcStructuralMember *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralMember(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralMember_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralMember *ExpressDataSet::cloneIfcStructuralMember(const IfcStructuralMember &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralMember(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralMember(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralMember  > &ExpressDataSet::getAllIfcStructuralMember ()
{
    return m_refIfcStructuralMemberList;
}



IfcStructuralPlanarAction *ExpressDataSet::getIfcStructuralPlanarAction(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralPlanarAction * > (current->second.get());
    }
    else
    {
        IfcStructuralPlanarAction *ret = static_cast< IfcStructuralPlanarAction * > (allocateIfcStructuralPlanarAction(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralPlanarAction(IfcStructuralPlanarAction *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralPlanarAction_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralPlanarAction(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralPlanarAction *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralPlanarAction(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralPlanarAction_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralPlanarAction > ExpressDataSet::createIfcStructuralPlanarAction(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralPlanarAction(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralPlanarAction * > (allocateIfcStructuralPlanarAction(this, Step::Id_UNSET));
    }
}

IfcStructuralPlanarAction *ExpressDataSet::cloneIfcStructuralPlanarAction(ExpressDataSet *expressDataSet, const IfcStructuralPlanarAction &obj, const CopyOp &copyop)
{
    IfcStructuralPlanarAction *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralPlanarAction(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralPlanarAction_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralPlanarAction *ExpressDataSet::cloneIfcStructuralPlanarAction(const IfcStructuralPlanarAction &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralPlanarAction(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralPlanarAction(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralPlanarAction  > &ExpressDataSet::getAllIfcStructuralPlanarAction ()
{
    return m_refIfcStructuralPlanarActionList;
}



IfcStructuralPlanarActionVarying *ExpressDataSet::getIfcStructuralPlanarActionVarying(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralPlanarActionVarying * > (current->second.get());
    }
    else
    {
        IfcStructuralPlanarActionVarying *ret = static_cast< IfcStructuralPlanarActionVarying * > (allocateIfcStructuralPlanarActionVarying(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralPlanarActionVarying(IfcStructuralPlanarActionVarying *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralPlanarActionVarying_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralPlanarActionVarying(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralPlanarActionVarying *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralPlanarActionVarying(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralPlanarActionVarying_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralPlanarActionVarying > ExpressDataSet::createIfcStructuralPlanarActionVarying(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralPlanarActionVarying(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralPlanarActionVarying * > (allocateIfcStructuralPlanarActionVarying(this, Step::Id_UNSET));
    }
}

IfcStructuralPlanarActionVarying *ExpressDataSet::cloneIfcStructuralPlanarActionVarying(ExpressDataSet *expressDataSet, const IfcStructuralPlanarActionVarying &obj, const CopyOp &copyop)
{
    IfcStructuralPlanarActionVarying *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralPlanarActionVarying(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralPlanarActionVarying_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralPlanarActionVarying *ExpressDataSet::cloneIfcStructuralPlanarActionVarying(const IfcStructuralPlanarActionVarying &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralPlanarActionVarying(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralPlanarActionVarying(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralPlanarActionVarying  > &ExpressDataSet::getAllIfcStructuralPlanarActionVarying ()
{
    return m_refIfcStructuralPlanarActionVaryingList;
}



IfcStructuralPointAction *ExpressDataSet::getIfcStructuralPointAction(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralPointAction * > (current->second.get());
    }
    else
    {
        IfcStructuralPointAction *ret = static_cast< IfcStructuralPointAction * > (allocateIfcStructuralPointAction(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralPointAction(IfcStructuralPointAction *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralPointAction_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralPointAction(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralPointAction *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralPointAction(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralPointAction_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralPointAction > ExpressDataSet::createIfcStructuralPointAction(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralPointAction(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralPointAction * > (allocateIfcStructuralPointAction(this, Step::Id_UNSET));
    }
}

IfcStructuralPointAction *ExpressDataSet::cloneIfcStructuralPointAction(ExpressDataSet *expressDataSet, const IfcStructuralPointAction &obj, const CopyOp &copyop)
{
    IfcStructuralPointAction *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralPointAction(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralPointAction_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralPointAction *ExpressDataSet::cloneIfcStructuralPointAction(const IfcStructuralPointAction &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralPointAction(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralPointAction(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralPointAction  > &ExpressDataSet::getAllIfcStructuralPointAction ()
{
    return m_refIfcStructuralPointActionList;
}



IfcStructuralPointConnection *ExpressDataSet::getIfcStructuralPointConnection(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralPointConnection * > (current->second.get());
    }
    else
    {
        IfcStructuralPointConnection *ret = static_cast< IfcStructuralPointConnection * > (allocateIfcStructuralPointConnection(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralPointConnection(IfcStructuralPointConnection *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralPointConnection_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralPointConnection(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralPointConnection *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralPointConnection(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralPointConnection_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralPointConnection > ExpressDataSet::createIfcStructuralPointConnection(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralPointConnection(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralPointConnection * > (allocateIfcStructuralPointConnection(this, Step::Id_UNSET));
    }
}

IfcStructuralPointConnection *ExpressDataSet::cloneIfcStructuralPointConnection(ExpressDataSet *expressDataSet, const IfcStructuralPointConnection &obj, const CopyOp &copyop)
{
    IfcStructuralPointConnection *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralPointConnection(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralPointConnection_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralPointConnection *ExpressDataSet::cloneIfcStructuralPointConnection(const IfcStructuralPointConnection &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralPointConnection(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralPointConnection(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralPointConnection  > &ExpressDataSet::getAllIfcStructuralPointConnection ()
{
    return m_refIfcStructuralPointConnectionList;
}



IfcStructuralPointReaction *ExpressDataSet::getIfcStructuralPointReaction(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralPointReaction * > (current->second.get());
    }
    else
    {
        IfcStructuralPointReaction *ret = static_cast< IfcStructuralPointReaction * > (allocateIfcStructuralPointReaction(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralPointReaction(IfcStructuralPointReaction *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralPointReaction_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralPointReaction(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralPointReaction *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralPointReaction(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralPointReaction_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralPointReaction > ExpressDataSet::createIfcStructuralPointReaction(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralPointReaction(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralPointReaction * > (allocateIfcStructuralPointReaction(this, Step::Id_UNSET));
    }
}

IfcStructuralPointReaction *ExpressDataSet::cloneIfcStructuralPointReaction(ExpressDataSet *expressDataSet, const IfcStructuralPointReaction &obj, const CopyOp &copyop)
{
    IfcStructuralPointReaction *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralPointReaction(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralPointReaction_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralPointReaction *ExpressDataSet::cloneIfcStructuralPointReaction(const IfcStructuralPointReaction &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralPointReaction(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralPointReaction(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralPointReaction  > &ExpressDataSet::getAllIfcStructuralPointReaction ()
{
    return m_refIfcStructuralPointReactionList;
}



IfcStructuralProfileProperties *ExpressDataSet::getIfcStructuralProfileProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralProfileProperties * > (current->second.get());
    }
    else
    {
        IfcStructuralProfileProperties *ret = static_cast< IfcStructuralProfileProperties * > (allocateIfcStructuralProfileProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralProfileProperties(IfcStructuralProfileProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralProfileProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralProfileProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralProfileProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralProfileProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralProfileProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralProfileProperties > ExpressDataSet::createIfcStructuralProfileProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralProfileProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralProfileProperties * > (allocateIfcStructuralProfileProperties(this, Step::Id_UNSET));
    }
}

IfcStructuralProfileProperties *ExpressDataSet::cloneIfcStructuralProfileProperties(ExpressDataSet *expressDataSet, const IfcStructuralProfileProperties &obj, const CopyOp &copyop)
{
    IfcStructuralProfileProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralProfileProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralProfileProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralProfileProperties *ExpressDataSet::cloneIfcStructuralProfileProperties(const IfcStructuralProfileProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralProfileProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralProfileProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralProfileProperties  > &ExpressDataSet::getAllIfcStructuralProfileProperties ()
{
    return m_refIfcStructuralProfilePropertiesList;
}



IfcStructuralReaction *ExpressDataSet::getIfcStructuralReaction(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralReaction * > (current->second.get());
    }
    else
    {
        IfcStructuralReaction *ret = static_cast< IfcStructuralReaction * > (allocateIfcStructuralReaction(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralReaction(IfcStructuralReaction *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralReaction_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralReaction(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralReaction *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralReaction(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralReaction_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralReaction > ExpressDataSet::createIfcStructuralReaction(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralReaction(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralReaction * > (allocateIfcStructuralReaction(this, Step::Id_UNSET));
    }
}

IfcStructuralReaction *ExpressDataSet::cloneIfcStructuralReaction(ExpressDataSet *expressDataSet, const IfcStructuralReaction &obj, const CopyOp &copyop)
{
    IfcStructuralReaction *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralReaction(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralReaction_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralReaction *ExpressDataSet::cloneIfcStructuralReaction(const IfcStructuralReaction &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralReaction(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralReaction(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralReaction  > &ExpressDataSet::getAllIfcStructuralReaction ()
{
    return m_refIfcStructuralReactionList;
}



IfcStructuralResultGroup *ExpressDataSet::getIfcStructuralResultGroup(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralResultGroup * > (current->second.get());
    }
    else
    {
        IfcStructuralResultGroup *ret = static_cast< IfcStructuralResultGroup * > (allocateIfcStructuralResultGroup(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralResultGroup(IfcStructuralResultGroup *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralResultGroup_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralResultGroup(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralResultGroup *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralResultGroup(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralResultGroup_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralResultGroup > ExpressDataSet::createIfcStructuralResultGroup(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralResultGroup(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralResultGroup * > (allocateIfcStructuralResultGroup(this, Step::Id_UNSET));
    }
}

IfcStructuralResultGroup *ExpressDataSet::cloneIfcStructuralResultGroup(ExpressDataSet *expressDataSet, const IfcStructuralResultGroup &obj, const CopyOp &copyop)
{
    IfcStructuralResultGroup *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralResultGroup(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralResultGroup_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralResultGroup *ExpressDataSet::cloneIfcStructuralResultGroup(const IfcStructuralResultGroup &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralResultGroup(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralResultGroup(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralResultGroup  > &ExpressDataSet::getAllIfcStructuralResultGroup ()
{
    return m_refIfcStructuralResultGroupList;
}



IfcStructuralSteelProfileProperties *ExpressDataSet::getIfcStructuralSteelProfileProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralSteelProfileProperties * > (current->second.get());
    }
    else
    {
        IfcStructuralSteelProfileProperties *ret = static_cast< IfcStructuralSteelProfileProperties * > (allocateIfcStructuralSteelProfileProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralSteelProfileProperties(IfcStructuralSteelProfileProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralSteelProfileProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralSteelProfileProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralSteelProfileProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralSteelProfileProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralSteelProfileProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralSteelProfileProperties > ExpressDataSet::createIfcStructuralSteelProfileProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralSteelProfileProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralSteelProfileProperties * > (allocateIfcStructuralSteelProfileProperties(this, Step::Id_UNSET));
    }
}

IfcStructuralSteelProfileProperties *ExpressDataSet::cloneIfcStructuralSteelProfileProperties(ExpressDataSet *expressDataSet, const IfcStructuralSteelProfileProperties &obj, const CopyOp &copyop)
{
    IfcStructuralSteelProfileProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralSteelProfileProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralSteelProfileProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralSteelProfileProperties *ExpressDataSet::cloneIfcStructuralSteelProfileProperties(const IfcStructuralSteelProfileProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralSteelProfileProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralSteelProfileProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralSteelProfileProperties  > &ExpressDataSet::getAllIfcStructuralSteelProfileProperties ()
{
    return m_refIfcStructuralSteelProfilePropertiesList;
}



IfcStructuralSurfaceConnection *ExpressDataSet::getIfcStructuralSurfaceConnection(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralSurfaceConnection * > (current->second.get());
    }
    else
    {
        IfcStructuralSurfaceConnection *ret = static_cast< IfcStructuralSurfaceConnection * > (allocateIfcStructuralSurfaceConnection(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralSurfaceConnection(IfcStructuralSurfaceConnection *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralSurfaceConnection_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralSurfaceConnection(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralSurfaceConnection *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralSurfaceConnection(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralSurfaceConnection_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralSurfaceConnection > ExpressDataSet::createIfcStructuralSurfaceConnection(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralSurfaceConnection(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralSurfaceConnection * > (allocateIfcStructuralSurfaceConnection(this, Step::Id_UNSET));
    }
}

IfcStructuralSurfaceConnection *ExpressDataSet::cloneIfcStructuralSurfaceConnection(ExpressDataSet *expressDataSet, const IfcStructuralSurfaceConnection &obj, const CopyOp &copyop)
{
    IfcStructuralSurfaceConnection *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralSurfaceConnection(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralSurfaceConnection_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralSurfaceConnection *ExpressDataSet::cloneIfcStructuralSurfaceConnection(const IfcStructuralSurfaceConnection &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralSurfaceConnection(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralSurfaceConnection(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralSurfaceConnection  > &ExpressDataSet::getAllIfcStructuralSurfaceConnection ()
{
    return m_refIfcStructuralSurfaceConnectionList;
}



IfcStructuralSurfaceMember *ExpressDataSet::getIfcStructuralSurfaceMember(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralSurfaceMember * > (current->second.get());
    }
    else
    {
        IfcStructuralSurfaceMember *ret = static_cast< IfcStructuralSurfaceMember * > (allocateIfcStructuralSurfaceMember(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralSurfaceMember(IfcStructuralSurfaceMember *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralSurfaceMember_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralSurfaceMember(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralSurfaceMember *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralSurfaceMember(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralSurfaceMember_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralSurfaceMember > ExpressDataSet::createIfcStructuralSurfaceMember(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralSurfaceMember(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralSurfaceMember * > (allocateIfcStructuralSurfaceMember(this, Step::Id_UNSET));
    }
}

IfcStructuralSurfaceMember *ExpressDataSet::cloneIfcStructuralSurfaceMember(ExpressDataSet *expressDataSet, const IfcStructuralSurfaceMember &obj, const CopyOp &copyop)
{
    IfcStructuralSurfaceMember *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralSurfaceMember(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralSurfaceMember_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralSurfaceMember *ExpressDataSet::cloneIfcStructuralSurfaceMember(const IfcStructuralSurfaceMember &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralSurfaceMember(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralSurfaceMember(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralSurfaceMember  > &ExpressDataSet::getAllIfcStructuralSurfaceMember ()
{
    return m_refIfcStructuralSurfaceMemberList;
}



IfcStructuralSurfaceMemberVarying *ExpressDataSet::getIfcStructuralSurfaceMemberVarying(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuralSurfaceMemberVarying * > (current->second.get());
    }
    else
    {
        IfcStructuralSurfaceMemberVarying *ret = static_cast< IfcStructuralSurfaceMemberVarying * > (allocateIfcStructuralSurfaceMemberVarying(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuralSurfaceMemberVarying(IfcStructuralSurfaceMemberVarying *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuralSurfaceMemberVarying_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralSurfaceMemberVarying(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuralSurfaceMemberVarying *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralSurfaceMemberVarying(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralSurfaceMemberVarying_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralSurfaceMemberVarying > ExpressDataSet::createIfcStructuralSurfaceMemberVarying(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuralSurfaceMemberVarying(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuralSurfaceMemberVarying * > (allocateIfcStructuralSurfaceMemberVarying(this, Step::Id_UNSET));
    }
}

IfcStructuralSurfaceMemberVarying *ExpressDataSet::cloneIfcStructuralSurfaceMemberVarying(ExpressDataSet *expressDataSet, const IfcStructuralSurfaceMemberVarying &obj, const CopyOp &copyop)
{
    IfcStructuralSurfaceMemberVarying *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralSurfaceMemberVarying(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralSurfaceMemberVarying_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralSurfaceMemberVarying *ExpressDataSet::cloneIfcStructuralSurfaceMemberVarying(const IfcStructuralSurfaceMemberVarying &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuralSurfaceMemberVarying(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuralSurfaceMemberVarying(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuralSurfaceMemberVarying  > &ExpressDataSet::getAllIfcStructuralSurfaceMemberVarying ()
{
    return m_refIfcStructuralSurfaceMemberVaryingList;
}



IfcStructuredDimensionCallout *ExpressDataSet::getIfcStructuredDimensionCallout(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStructuredDimensionCallout * > (current->second.get());
    }
    else
    {
        IfcStructuredDimensionCallout *ret = static_cast< IfcStructuredDimensionCallout * > (allocateIfcStructuredDimensionCallout(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStructuredDimensionCallout(IfcStructuredDimensionCallout *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStructuredDimensionCallout_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuredDimensionCallout(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStructuredDimensionCallout *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuredDimensionCallout(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuredDimensionCallout_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuredDimensionCallout > ExpressDataSet::createIfcStructuredDimensionCallout(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStructuredDimensionCallout(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStructuredDimensionCallout * > (allocateIfcStructuredDimensionCallout(this, Step::Id_UNSET));
    }
}

IfcStructuredDimensionCallout *ExpressDataSet::cloneIfcStructuredDimensionCallout(ExpressDataSet *expressDataSet, const IfcStructuredDimensionCallout &obj, const CopyOp &copyop)
{
    IfcStructuredDimensionCallout *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuredDimensionCallout(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuredDimensionCallout_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuredDimensionCallout *ExpressDataSet::cloneIfcStructuredDimensionCallout(const IfcStructuredDimensionCallout &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStructuredDimensionCallout(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStructuredDimensionCallout(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStructuredDimensionCallout  > &ExpressDataSet::getAllIfcStructuredDimensionCallout ()
{
    return m_refIfcStructuredDimensionCalloutList;
}



IfcStyledItem *ExpressDataSet::getIfcStyledItem(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStyledItem * > (current->second.get());
    }
    else
    {
        IfcStyledItem *ret = static_cast< IfcStyledItem * > (allocateIfcStyledItem(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStyledItem(IfcStyledItem *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStyledItem_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStyledItem(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStyledItem *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStyledItem(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStyledItem_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStyledItem > ExpressDataSet::createIfcStyledItem(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStyledItem(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStyledItem * > (allocateIfcStyledItem(this, Step::Id_UNSET));
    }
}

IfcStyledItem *ExpressDataSet::cloneIfcStyledItem(ExpressDataSet *expressDataSet, const IfcStyledItem &obj, const CopyOp &copyop)
{
    IfcStyledItem *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStyledItem(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStyledItem_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStyledItem *ExpressDataSet::cloneIfcStyledItem(const IfcStyledItem &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStyledItem(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStyledItem(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStyledItem  > &ExpressDataSet::getAllIfcStyledItem ()
{
    return m_refIfcStyledItemList;
}



IfcStyledRepresentation *ExpressDataSet::getIfcStyledRepresentation(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStyledRepresentation * > (current->second.get());
    }
    else
    {
        IfcStyledRepresentation *ret = static_cast< IfcStyledRepresentation * > (allocateIfcStyledRepresentation(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStyledRepresentation(IfcStyledRepresentation *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStyledRepresentation_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStyledRepresentation(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStyledRepresentation *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStyledRepresentation(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStyledRepresentation_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStyledRepresentation > ExpressDataSet::createIfcStyledRepresentation(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStyledRepresentation(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStyledRepresentation * > (allocateIfcStyledRepresentation(this, Step::Id_UNSET));
    }
}

IfcStyledRepresentation *ExpressDataSet::cloneIfcStyledRepresentation(ExpressDataSet *expressDataSet, const IfcStyledRepresentation &obj, const CopyOp &copyop)
{
    IfcStyledRepresentation *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStyledRepresentation(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStyledRepresentation_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStyledRepresentation *ExpressDataSet::cloneIfcStyledRepresentation(const IfcStyledRepresentation &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStyledRepresentation(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStyledRepresentation(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStyledRepresentation  > &ExpressDataSet::getAllIfcStyledRepresentation ()
{
    return m_refIfcStyledRepresentationList;
}



IfcStyleModel *ExpressDataSet::getIfcStyleModel(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcStyleModel * > (current->second.get());
    }
    else
    {
        IfcStyleModel *ret = static_cast< IfcStyleModel * > (allocateIfcStyleModel(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcStyleModel(IfcStyleModel *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcStyleModel_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStyleModel(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcStyleModel *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStyleModel(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStyleModel_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStyleModel > ExpressDataSet::createIfcStyleModel(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcStyleModel(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcStyleModel * > (allocateIfcStyleModel(this, Step::Id_UNSET));
    }
}

IfcStyleModel *ExpressDataSet::cloneIfcStyleModel(ExpressDataSet *expressDataSet, const IfcStyleModel &obj, const CopyOp &copyop)
{
    IfcStyleModel *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStyleModel(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStyleModel_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStyleModel *ExpressDataSet::cloneIfcStyleModel(const IfcStyleModel &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcStyleModel(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcStyleModel(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcStyleModel  > &ExpressDataSet::getAllIfcStyleModel ()
{
    return m_refIfcStyleModelList;
}



IfcSubContractResource *ExpressDataSet::getIfcSubContractResource(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSubContractResource * > (current->second.get());
    }
    else
    {
        IfcSubContractResource *ret = static_cast< IfcSubContractResource * > (allocateIfcSubContractResource(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSubContractResource(IfcSubContractResource *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSubContractResource_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSubContractResource(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSubContractResource *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSubContractResource(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSubContractResource_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSubContractResource > ExpressDataSet::createIfcSubContractResource(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSubContractResource(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSubContractResource * > (allocateIfcSubContractResource(this, Step::Id_UNSET));
    }
}

IfcSubContractResource *ExpressDataSet::cloneIfcSubContractResource(ExpressDataSet *expressDataSet, const IfcSubContractResource &obj, const CopyOp &copyop)
{
    IfcSubContractResource *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSubContractResource(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSubContractResource_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSubContractResource *ExpressDataSet::cloneIfcSubContractResource(const IfcSubContractResource &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSubContractResource(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSubContractResource(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSubContractResource  > &ExpressDataSet::getAllIfcSubContractResource ()
{
    return m_refIfcSubContractResourceList;
}



IfcSubedge *ExpressDataSet::getIfcSubedge(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSubedge * > (current->second.get());
    }
    else
    {
        IfcSubedge *ret = static_cast< IfcSubedge * > (allocateIfcSubedge(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSubedge(IfcSubedge *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSubedge_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSubedge(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSubedge *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSubedge(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSubedge_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSubedge > ExpressDataSet::createIfcSubedge(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSubedge(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSubedge * > (allocateIfcSubedge(this, Step::Id_UNSET));
    }
}

IfcSubedge *ExpressDataSet::cloneIfcSubedge(ExpressDataSet *expressDataSet, const IfcSubedge &obj, const CopyOp &copyop)
{
    IfcSubedge *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSubedge(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSubedge_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSubedge *ExpressDataSet::cloneIfcSubedge(const IfcSubedge &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSubedge(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSubedge(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSubedge  > &ExpressDataSet::getAllIfcSubedge ()
{
    return m_refIfcSubedgeList;
}



IfcSurface *ExpressDataSet::getIfcSurface(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSurface * > (current->second.get());
    }
    else
    {
        IfcSurface *ret = static_cast< IfcSurface * > (allocateIfcSurface(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSurface(IfcSurface *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSurface_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSurface(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSurface *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSurface(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSurface_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSurface > ExpressDataSet::createIfcSurface(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSurface(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSurface * > (allocateIfcSurface(this, Step::Id_UNSET));
    }
}

IfcSurface *ExpressDataSet::cloneIfcSurface(ExpressDataSet *expressDataSet, const IfcSurface &obj, const CopyOp &copyop)
{
    IfcSurface *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSurface(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSurface_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSurface *ExpressDataSet::cloneIfcSurface(const IfcSurface &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSurface(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSurface(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSurface  > &ExpressDataSet::getAllIfcSurface ()
{
    return m_refIfcSurfaceList;
}



IfcSurfaceCurveSweptAreaSolid *ExpressDataSet::getIfcSurfaceCurveSweptAreaSolid(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSurfaceCurveSweptAreaSolid * > (current->second.get());
    }
    else
    {
        IfcSurfaceCurveSweptAreaSolid *ret = static_cast< IfcSurfaceCurveSweptAreaSolid * > (allocateIfcSurfaceCurveSweptAreaSolid(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSurfaceCurveSweptAreaSolid(IfcSurfaceCurveSweptAreaSolid *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSurfaceCurveSweptAreaSolid_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSurfaceCurveSweptAreaSolid(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSurfaceCurveSweptAreaSolid *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSurfaceCurveSweptAreaSolid(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSurfaceCurveSweptAreaSolid_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSurfaceCurveSweptAreaSolid > ExpressDataSet::createIfcSurfaceCurveSweptAreaSolid(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSurfaceCurveSweptAreaSolid(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSurfaceCurveSweptAreaSolid * > (allocateIfcSurfaceCurveSweptAreaSolid(this, Step::Id_UNSET));
    }
}

IfcSurfaceCurveSweptAreaSolid *ExpressDataSet::cloneIfcSurfaceCurveSweptAreaSolid(ExpressDataSet *expressDataSet, const IfcSurfaceCurveSweptAreaSolid &obj, const CopyOp &copyop)
{
    IfcSurfaceCurveSweptAreaSolid *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSurfaceCurveSweptAreaSolid(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSurfaceCurveSweptAreaSolid_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSurfaceCurveSweptAreaSolid *ExpressDataSet::cloneIfcSurfaceCurveSweptAreaSolid(const IfcSurfaceCurveSweptAreaSolid &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSurfaceCurveSweptAreaSolid(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSurfaceCurveSweptAreaSolid(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSurfaceCurveSweptAreaSolid  > &ExpressDataSet::getAllIfcSurfaceCurveSweptAreaSolid ()
{
    return m_refIfcSurfaceCurveSweptAreaSolidList;
}



IfcSurfaceOfLinearExtrusion *ExpressDataSet::getIfcSurfaceOfLinearExtrusion(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSurfaceOfLinearExtrusion * > (current->second.get());
    }
    else
    {
        IfcSurfaceOfLinearExtrusion *ret = static_cast< IfcSurfaceOfLinearExtrusion * > (allocateIfcSurfaceOfLinearExtrusion(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSurfaceOfLinearExtrusion(IfcSurfaceOfLinearExtrusion *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSurfaceOfLinearExtrusion_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSurfaceOfLinearExtrusion(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSurfaceOfLinearExtrusion *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSurfaceOfLinearExtrusion(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSurfaceOfLinearExtrusion_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSurfaceOfLinearExtrusion > ExpressDataSet::createIfcSurfaceOfLinearExtrusion(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSurfaceOfLinearExtrusion(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSurfaceOfLinearExtrusion * > (allocateIfcSurfaceOfLinearExtrusion(this, Step::Id_UNSET));
    }
}

IfcSurfaceOfLinearExtrusion *ExpressDataSet::cloneIfcSurfaceOfLinearExtrusion(ExpressDataSet *expressDataSet, const IfcSurfaceOfLinearExtrusion &obj, const CopyOp &copyop)
{
    IfcSurfaceOfLinearExtrusion *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSurfaceOfLinearExtrusion(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSurfaceOfLinearExtrusion_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSurfaceOfLinearExtrusion *ExpressDataSet::cloneIfcSurfaceOfLinearExtrusion(const IfcSurfaceOfLinearExtrusion &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSurfaceOfLinearExtrusion(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSurfaceOfLinearExtrusion(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSurfaceOfLinearExtrusion  > &ExpressDataSet::getAllIfcSurfaceOfLinearExtrusion ()
{
    return m_refIfcSurfaceOfLinearExtrusionList;
}



IfcSurfaceOfRevolution *ExpressDataSet::getIfcSurfaceOfRevolution(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSurfaceOfRevolution * > (current->second.get());
    }
    else
    {
        IfcSurfaceOfRevolution *ret = static_cast< IfcSurfaceOfRevolution * > (allocateIfcSurfaceOfRevolution(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSurfaceOfRevolution(IfcSurfaceOfRevolution *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSurfaceOfRevolution_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSurfaceOfRevolution(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSurfaceOfRevolution *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSurfaceOfRevolution(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSurfaceOfRevolution_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSurfaceOfRevolution > ExpressDataSet::createIfcSurfaceOfRevolution(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSurfaceOfRevolution(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSurfaceOfRevolution * > (allocateIfcSurfaceOfRevolution(this, Step::Id_UNSET));
    }
}

IfcSurfaceOfRevolution *ExpressDataSet::cloneIfcSurfaceOfRevolution(ExpressDataSet *expressDataSet, const IfcSurfaceOfRevolution &obj, const CopyOp &copyop)
{
    IfcSurfaceOfRevolution *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSurfaceOfRevolution(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSurfaceOfRevolution_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSurfaceOfRevolution *ExpressDataSet::cloneIfcSurfaceOfRevolution(const IfcSurfaceOfRevolution &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSurfaceOfRevolution(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSurfaceOfRevolution(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSurfaceOfRevolution  > &ExpressDataSet::getAllIfcSurfaceOfRevolution ()
{
    return m_refIfcSurfaceOfRevolutionList;
}



IfcSurfaceStyle *ExpressDataSet::getIfcSurfaceStyle(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSurfaceStyle * > (current->second.get());
    }
    else
    {
        IfcSurfaceStyle *ret = static_cast< IfcSurfaceStyle * > (allocateIfcSurfaceStyle(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSurfaceStyle(IfcSurfaceStyle *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSurfaceStyle_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSurfaceStyle(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSurfaceStyle *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSurfaceStyle(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSurfaceStyle_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSurfaceStyle > ExpressDataSet::createIfcSurfaceStyle(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSurfaceStyle(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSurfaceStyle * > (allocateIfcSurfaceStyle(this, Step::Id_UNSET));
    }
}

IfcSurfaceStyle *ExpressDataSet::cloneIfcSurfaceStyle(ExpressDataSet *expressDataSet, const IfcSurfaceStyle &obj, const CopyOp &copyop)
{
    IfcSurfaceStyle *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSurfaceStyle(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSurfaceStyle_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSurfaceStyle *ExpressDataSet::cloneIfcSurfaceStyle(const IfcSurfaceStyle &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSurfaceStyle(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSurfaceStyle(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSurfaceStyle  > &ExpressDataSet::getAllIfcSurfaceStyle ()
{
    return m_refIfcSurfaceStyleList;
}



IfcSurfaceStyleLighting *ExpressDataSet::getIfcSurfaceStyleLighting(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSurfaceStyleLighting * > (current->second.get());
    }
    else
    {
        IfcSurfaceStyleLighting *ret = static_cast< IfcSurfaceStyleLighting * > (allocateIfcSurfaceStyleLighting(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSurfaceStyleLighting(IfcSurfaceStyleLighting *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSurfaceStyleLighting_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSurfaceStyleLighting(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSurfaceStyleLighting *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSurfaceStyleLighting(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSurfaceStyleLighting_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSurfaceStyleLighting > ExpressDataSet::createIfcSurfaceStyleLighting(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSurfaceStyleLighting(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSurfaceStyleLighting * > (allocateIfcSurfaceStyleLighting(this, Step::Id_UNSET));
    }
}

IfcSurfaceStyleLighting *ExpressDataSet::cloneIfcSurfaceStyleLighting(ExpressDataSet *expressDataSet, const IfcSurfaceStyleLighting &obj, const CopyOp &copyop)
{
    IfcSurfaceStyleLighting *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSurfaceStyleLighting(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSurfaceStyleLighting_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSurfaceStyleLighting *ExpressDataSet::cloneIfcSurfaceStyleLighting(const IfcSurfaceStyleLighting &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSurfaceStyleLighting(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSurfaceStyleLighting(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSurfaceStyleLighting  > &ExpressDataSet::getAllIfcSurfaceStyleLighting ()
{
    return m_refIfcSurfaceStyleLightingList;
}



IfcSurfaceStyleRefraction *ExpressDataSet::getIfcSurfaceStyleRefraction(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSurfaceStyleRefraction * > (current->second.get());
    }
    else
    {
        IfcSurfaceStyleRefraction *ret = static_cast< IfcSurfaceStyleRefraction * > (allocateIfcSurfaceStyleRefraction(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSurfaceStyleRefraction(IfcSurfaceStyleRefraction *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSurfaceStyleRefraction_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSurfaceStyleRefraction(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSurfaceStyleRefraction *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSurfaceStyleRefraction(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSurfaceStyleRefraction_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSurfaceStyleRefraction > ExpressDataSet::createIfcSurfaceStyleRefraction(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSurfaceStyleRefraction(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSurfaceStyleRefraction * > (allocateIfcSurfaceStyleRefraction(this, Step::Id_UNSET));
    }
}

IfcSurfaceStyleRefraction *ExpressDataSet::cloneIfcSurfaceStyleRefraction(ExpressDataSet *expressDataSet, const IfcSurfaceStyleRefraction &obj, const CopyOp &copyop)
{
    IfcSurfaceStyleRefraction *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSurfaceStyleRefraction(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSurfaceStyleRefraction_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSurfaceStyleRefraction *ExpressDataSet::cloneIfcSurfaceStyleRefraction(const IfcSurfaceStyleRefraction &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSurfaceStyleRefraction(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSurfaceStyleRefraction(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSurfaceStyleRefraction  > &ExpressDataSet::getAllIfcSurfaceStyleRefraction ()
{
    return m_refIfcSurfaceStyleRefractionList;
}



IfcSurfaceStyleRendering *ExpressDataSet::getIfcSurfaceStyleRendering(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSurfaceStyleRendering * > (current->second.get());
    }
    else
    {
        IfcSurfaceStyleRendering *ret = static_cast< IfcSurfaceStyleRendering * > (allocateIfcSurfaceStyleRendering(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSurfaceStyleRendering(IfcSurfaceStyleRendering *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSurfaceStyleRendering_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSurfaceStyleRendering(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSurfaceStyleRendering *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSurfaceStyleRendering(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSurfaceStyleRendering_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSurfaceStyleRendering > ExpressDataSet::createIfcSurfaceStyleRendering(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSurfaceStyleRendering(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSurfaceStyleRendering * > (allocateIfcSurfaceStyleRendering(this, Step::Id_UNSET));
    }
}

IfcSurfaceStyleRendering *ExpressDataSet::cloneIfcSurfaceStyleRendering(ExpressDataSet *expressDataSet, const IfcSurfaceStyleRendering &obj, const CopyOp &copyop)
{
    IfcSurfaceStyleRendering *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSurfaceStyleRendering(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSurfaceStyleRendering_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSurfaceStyleRendering *ExpressDataSet::cloneIfcSurfaceStyleRendering(const IfcSurfaceStyleRendering &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSurfaceStyleRendering(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSurfaceStyleRendering(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSurfaceStyleRendering  > &ExpressDataSet::getAllIfcSurfaceStyleRendering ()
{
    return m_refIfcSurfaceStyleRenderingList;
}



IfcSurfaceStyleShading *ExpressDataSet::getIfcSurfaceStyleShading(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSurfaceStyleShading * > (current->second.get());
    }
    else
    {
        IfcSurfaceStyleShading *ret = static_cast< IfcSurfaceStyleShading * > (allocateIfcSurfaceStyleShading(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSurfaceStyleShading(IfcSurfaceStyleShading *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSurfaceStyleShading_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSurfaceStyleShading(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSurfaceStyleShading *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSurfaceStyleShading(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSurfaceStyleShading_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSurfaceStyleShading > ExpressDataSet::createIfcSurfaceStyleShading(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSurfaceStyleShading(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSurfaceStyleShading * > (allocateIfcSurfaceStyleShading(this, Step::Id_UNSET));
    }
}

IfcSurfaceStyleShading *ExpressDataSet::cloneIfcSurfaceStyleShading(ExpressDataSet *expressDataSet, const IfcSurfaceStyleShading &obj, const CopyOp &copyop)
{
    IfcSurfaceStyleShading *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSurfaceStyleShading(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSurfaceStyleShading_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSurfaceStyleShading *ExpressDataSet::cloneIfcSurfaceStyleShading(const IfcSurfaceStyleShading &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSurfaceStyleShading(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSurfaceStyleShading(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSurfaceStyleShading  > &ExpressDataSet::getAllIfcSurfaceStyleShading ()
{
    return m_refIfcSurfaceStyleShadingList;
}



IfcSurfaceStyleWithTextures *ExpressDataSet::getIfcSurfaceStyleWithTextures(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSurfaceStyleWithTextures * > (current->second.get());
    }
    else
    {
        IfcSurfaceStyleWithTextures *ret = static_cast< IfcSurfaceStyleWithTextures * > (allocateIfcSurfaceStyleWithTextures(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSurfaceStyleWithTextures(IfcSurfaceStyleWithTextures *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSurfaceStyleWithTextures_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSurfaceStyleWithTextures(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSurfaceStyleWithTextures *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSurfaceStyleWithTextures(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSurfaceStyleWithTextures_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSurfaceStyleWithTextures > ExpressDataSet::createIfcSurfaceStyleWithTextures(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSurfaceStyleWithTextures(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSurfaceStyleWithTextures * > (allocateIfcSurfaceStyleWithTextures(this, Step::Id_UNSET));
    }
}

IfcSurfaceStyleWithTextures *ExpressDataSet::cloneIfcSurfaceStyleWithTextures(ExpressDataSet *expressDataSet, const IfcSurfaceStyleWithTextures &obj, const CopyOp &copyop)
{
    IfcSurfaceStyleWithTextures *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSurfaceStyleWithTextures(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSurfaceStyleWithTextures_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSurfaceStyleWithTextures *ExpressDataSet::cloneIfcSurfaceStyleWithTextures(const IfcSurfaceStyleWithTextures &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSurfaceStyleWithTextures(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSurfaceStyleWithTextures(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSurfaceStyleWithTextures  > &ExpressDataSet::getAllIfcSurfaceStyleWithTextures ()
{
    return m_refIfcSurfaceStyleWithTexturesList;
}



IfcSurfaceTexture *ExpressDataSet::getIfcSurfaceTexture(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSurfaceTexture * > (current->second.get());
    }
    else
    {
        IfcSurfaceTexture *ret = static_cast< IfcSurfaceTexture * > (allocateIfcSurfaceTexture(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSurfaceTexture(IfcSurfaceTexture *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSurfaceTexture_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSurfaceTexture(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSurfaceTexture *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSurfaceTexture(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSurfaceTexture_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSurfaceTexture > ExpressDataSet::createIfcSurfaceTexture(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSurfaceTexture(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSurfaceTexture * > (allocateIfcSurfaceTexture(this, Step::Id_UNSET));
    }
}

IfcSurfaceTexture *ExpressDataSet::cloneIfcSurfaceTexture(ExpressDataSet *expressDataSet, const IfcSurfaceTexture &obj, const CopyOp &copyop)
{
    IfcSurfaceTexture *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSurfaceTexture(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSurfaceTexture_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSurfaceTexture *ExpressDataSet::cloneIfcSurfaceTexture(const IfcSurfaceTexture &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSurfaceTexture(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSurfaceTexture(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSurfaceTexture  > &ExpressDataSet::getAllIfcSurfaceTexture ()
{
    return m_refIfcSurfaceTextureList;
}



IfcSweptAreaSolid *ExpressDataSet::getIfcSweptAreaSolid(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSweptAreaSolid * > (current->second.get());
    }
    else
    {
        IfcSweptAreaSolid *ret = static_cast< IfcSweptAreaSolid * > (allocateIfcSweptAreaSolid(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSweptAreaSolid(IfcSweptAreaSolid *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSweptAreaSolid_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSweptAreaSolid(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSweptAreaSolid *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSweptAreaSolid(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSweptAreaSolid_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSweptAreaSolid > ExpressDataSet::createIfcSweptAreaSolid(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSweptAreaSolid(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSweptAreaSolid * > (allocateIfcSweptAreaSolid(this, Step::Id_UNSET));
    }
}

IfcSweptAreaSolid *ExpressDataSet::cloneIfcSweptAreaSolid(ExpressDataSet *expressDataSet, const IfcSweptAreaSolid &obj, const CopyOp &copyop)
{
    IfcSweptAreaSolid *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSweptAreaSolid(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSweptAreaSolid_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSweptAreaSolid *ExpressDataSet::cloneIfcSweptAreaSolid(const IfcSweptAreaSolid &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSweptAreaSolid(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSweptAreaSolid(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSweptAreaSolid  > &ExpressDataSet::getAllIfcSweptAreaSolid ()
{
    return m_refIfcSweptAreaSolidList;
}



IfcSweptDiskSolid *ExpressDataSet::getIfcSweptDiskSolid(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSweptDiskSolid * > (current->second.get());
    }
    else
    {
        IfcSweptDiskSolid *ret = static_cast< IfcSweptDiskSolid * > (allocateIfcSweptDiskSolid(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSweptDiskSolid(IfcSweptDiskSolid *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSweptDiskSolid_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSweptDiskSolid(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSweptDiskSolid *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSweptDiskSolid(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSweptDiskSolid_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSweptDiskSolid > ExpressDataSet::createIfcSweptDiskSolid(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSweptDiskSolid(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSweptDiskSolid * > (allocateIfcSweptDiskSolid(this, Step::Id_UNSET));
    }
}

IfcSweptDiskSolid *ExpressDataSet::cloneIfcSweptDiskSolid(ExpressDataSet *expressDataSet, const IfcSweptDiskSolid &obj, const CopyOp &copyop)
{
    IfcSweptDiskSolid *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSweptDiskSolid(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSweptDiskSolid_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSweptDiskSolid *ExpressDataSet::cloneIfcSweptDiskSolid(const IfcSweptDiskSolid &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSweptDiskSolid(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSweptDiskSolid(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSweptDiskSolid  > &ExpressDataSet::getAllIfcSweptDiskSolid ()
{
    return m_refIfcSweptDiskSolidList;
}



IfcSweptSurface *ExpressDataSet::getIfcSweptSurface(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSweptSurface * > (current->second.get());
    }
    else
    {
        IfcSweptSurface *ret = static_cast< IfcSweptSurface * > (allocateIfcSweptSurface(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSweptSurface(IfcSweptSurface *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSweptSurface_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSweptSurface(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSweptSurface *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSweptSurface(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSweptSurface_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSweptSurface > ExpressDataSet::createIfcSweptSurface(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSweptSurface(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSweptSurface * > (allocateIfcSweptSurface(this, Step::Id_UNSET));
    }
}

IfcSweptSurface *ExpressDataSet::cloneIfcSweptSurface(ExpressDataSet *expressDataSet, const IfcSweptSurface &obj, const CopyOp &copyop)
{
    IfcSweptSurface *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSweptSurface(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSweptSurface_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSweptSurface *ExpressDataSet::cloneIfcSweptSurface(const IfcSweptSurface &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSweptSurface(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSweptSurface(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSweptSurface  > &ExpressDataSet::getAllIfcSweptSurface ()
{
    return m_refIfcSweptSurfaceList;
}



IfcSwitchingDeviceType *ExpressDataSet::getIfcSwitchingDeviceType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSwitchingDeviceType * > (current->second.get());
    }
    else
    {
        IfcSwitchingDeviceType *ret = static_cast< IfcSwitchingDeviceType * > (allocateIfcSwitchingDeviceType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSwitchingDeviceType(IfcSwitchingDeviceType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSwitchingDeviceType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSwitchingDeviceType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSwitchingDeviceType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSwitchingDeviceType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSwitchingDeviceType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSwitchingDeviceType > ExpressDataSet::createIfcSwitchingDeviceType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSwitchingDeviceType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSwitchingDeviceType * > (allocateIfcSwitchingDeviceType(this, Step::Id_UNSET));
    }
}

IfcSwitchingDeviceType *ExpressDataSet::cloneIfcSwitchingDeviceType(ExpressDataSet *expressDataSet, const IfcSwitchingDeviceType &obj, const CopyOp &copyop)
{
    IfcSwitchingDeviceType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSwitchingDeviceType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSwitchingDeviceType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSwitchingDeviceType *ExpressDataSet::cloneIfcSwitchingDeviceType(const IfcSwitchingDeviceType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSwitchingDeviceType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSwitchingDeviceType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSwitchingDeviceType  > &ExpressDataSet::getAllIfcSwitchingDeviceType ()
{
    return m_refIfcSwitchingDeviceTypeList;
}



IfcSymbolStyle *ExpressDataSet::getIfcSymbolStyle(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSymbolStyle * > (current->second.get());
    }
    else
    {
        IfcSymbolStyle *ret = static_cast< IfcSymbolStyle * > (allocateIfcSymbolStyle(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSymbolStyle(IfcSymbolStyle *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSymbolStyle_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSymbolStyle(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSymbolStyle *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSymbolStyle(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSymbolStyle_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSymbolStyle > ExpressDataSet::createIfcSymbolStyle(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSymbolStyle(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSymbolStyle * > (allocateIfcSymbolStyle(this, Step::Id_UNSET));
    }
}

IfcSymbolStyle *ExpressDataSet::cloneIfcSymbolStyle(ExpressDataSet *expressDataSet, const IfcSymbolStyle &obj, const CopyOp &copyop)
{
    IfcSymbolStyle *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSymbolStyle(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSymbolStyle_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSymbolStyle *ExpressDataSet::cloneIfcSymbolStyle(const IfcSymbolStyle &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSymbolStyle(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSymbolStyle(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSymbolStyle  > &ExpressDataSet::getAllIfcSymbolStyle ()
{
    return m_refIfcSymbolStyleList;
}



IfcSystem *ExpressDataSet::getIfcSystem(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSystem * > (current->second.get());
    }
    else
    {
        IfcSystem *ret = static_cast< IfcSystem * > (allocateIfcSystem(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSystem(IfcSystem *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSystem_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSystem(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSystem *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSystem(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSystem_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSystem > ExpressDataSet::createIfcSystem(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSystem(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSystem * > (allocateIfcSystem(this, Step::Id_UNSET));
    }
}

IfcSystem *ExpressDataSet::cloneIfcSystem(ExpressDataSet *expressDataSet, const IfcSystem &obj, const CopyOp &copyop)
{
    IfcSystem *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSystem(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSystem_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSystem *ExpressDataSet::cloneIfcSystem(const IfcSystem &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSystem(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSystem(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSystem  > &ExpressDataSet::getAllIfcSystem ()
{
    return m_refIfcSystemList;
}



IfcSystemFurnitureElementType *ExpressDataSet::getIfcSystemFurnitureElementType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcSystemFurnitureElementType * > (current->second.get());
    }
    else
    {
        IfcSystemFurnitureElementType *ret = static_cast< IfcSystemFurnitureElementType * > (allocateIfcSystemFurnitureElementType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcSystemFurnitureElementType(IfcSystemFurnitureElementType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcSystemFurnitureElementType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSystemFurnitureElementType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcSystemFurnitureElementType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSystemFurnitureElementType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSystemFurnitureElementType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSystemFurnitureElementType > ExpressDataSet::createIfcSystemFurnitureElementType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcSystemFurnitureElementType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcSystemFurnitureElementType * > (allocateIfcSystemFurnitureElementType(this, Step::Id_UNSET));
    }
}

IfcSystemFurnitureElementType *ExpressDataSet::cloneIfcSystemFurnitureElementType(ExpressDataSet *expressDataSet, const IfcSystemFurnitureElementType &obj, const CopyOp &copyop)
{
    IfcSystemFurnitureElementType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSystemFurnitureElementType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSystemFurnitureElementType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSystemFurnitureElementType *ExpressDataSet::cloneIfcSystemFurnitureElementType(const IfcSystemFurnitureElementType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcSystemFurnitureElementType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcSystemFurnitureElementType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcSystemFurnitureElementType  > &ExpressDataSet::getAllIfcSystemFurnitureElementType ()
{
    return m_refIfcSystemFurnitureElementTypeList;
}



IfcTable *ExpressDataSet::getIfcTable(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTable * > (current->second.get());
    }
    else
    {
        IfcTable *ret = static_cast< IfcTable * > (allocateIfcTable(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTable(IfcTable *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTable_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTable(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTable *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTable(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTable_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTable > ExpressDataSet::createIfcTable(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTable(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTable * > (allocateIfcTable(this, Step::Id_UNSET));
    }
}

IfcTable *ExpressDataSet::cloneIfcTable(ExpressDataSet *expressDataSet, const IfcTable &obj, const CopyOp &copyop)
{
    IfcTable *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTable(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTable_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTable *ExpressDataSet::cloneIfcTable(const IfcTable &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTable(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTable(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTable  > &ExpressDataSet::getAllIfcTable ()
{
    return m_refIfcTableList;
}



IfcTableRow *ExpressDataSet::getIfcTableRow(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTableRow * > (current->second.get());
    }
    else
    {
        IfcTableRow *ret = static_cast< IfcTableRow * > (allocateIfcTableRow(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTableRow(IfcTableRow *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTableRow_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTableRow(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTableRow *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTableRow(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTableRow_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTableRow > ExpressDataSet::createIfcTableRow(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTableRow(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTableRow * > (allocateIfcTableRow(this, Step::Id_UNSET));
    }
}

IfcTableRow *ExpressDataSet::cloneIfcTableRow(ExpressDataSet *expressDataSet, const IfcTableRow &obj, const CopyOp &copyop)
{
    IfcTableRow *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTableRow(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTableRow_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTableRow *ExpressDataSet::cloneIfcTableRow(const IfcTableRow &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTableRow(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTableRow(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTableRow  > &ExpressDataSet::getAllIfcTableRow ()
{
    return m_refIfcTableRowList;
}



IfcTankType *ExpressDataSet::getIfcTankType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTankType * > (current->second.get());
    }
    else
    {
        IfcTankType *ret = static_cast< IfcTankType * > (allocateIfcTankType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTankType(IfcTankType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTankType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTankType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTankType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTankType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTankType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTankType > ExpressDataSet::createIfcTankType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTankType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTankType * > (allocateIfcTankType(this, Step::Id_UNSET));
    }
}

IfcTankType *ExpressDataSet::cloneIfcTankType(ExpressDataSet *expressDataSet, const IfcTankType &obj, const CopyOp &copyop)
{
    IfcTankType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTankType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTankType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTankType *ExpressDataSet::cloneIfcTankType(const IfcTankType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTankType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTankType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTankType  > &ExpressDataSet::getAllIfcTankType ()
{
    return m_refIfcTankTypeList;
}



IfcTask *ExpressDataSet::getIfcTask(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTask * > (current->second.get());
    }
    else
    {
        IfcTask *ret = static_cast< IfcTask * > (allocateIfcTask(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTask(IfcTask *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTask_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTask(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTask *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTask(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTask_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTask > ExpressDataSet::createIfcTask(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTask(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTask * > (allocateIfcTask(this, Step::Id_UNSET));
    }
}

IfcTask *ExpressDataSet::cloneIfcTask(ExpressDataSet *expressDataSet, const IfcTask &obj, const CopyOp &copyop)
{
    IfcTask *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTask(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTask_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTask *ExpressDataSet::cloneIfcTask(const IfcTask &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTask(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTask(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTask  > &ExpressDataSet::getAllIfcTask ()
{
    return m_refIfcTaskList;
}



IfcTelecomAddress *ExpressDataSet::getIfcTelecomAddress(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTelecomAddress * > (current->second.get());
    }
    else
    {
        IfcTelecomAddress *ret = static_cast< IfcTelecomAddress * > (allocateIfcTelecomAddress(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTelecomAddress(IfcTelecomAddress *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTelecomAddress_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTelecomAddress(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTelecomAddress *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTelecomAddress(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTelecomAddress_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTelecomAddress > ExpressDataSet::createIfcTelecomAddress(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTelecomAddress(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTelecomAddress * > (allocateIfcTelecomAddress(this, Step::Id_UNSET));
    }
}

IfcTelecomAddress *ExpressDataSet::cloneIfcTelecomAddress(ExpressDataSet *expressDataSet, const IfcTelecomAddress &obj, const CopyOp &copyop)
{
    IfcTelecomAddress *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTelecomAddress(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTelecomAddress_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTelecomAddress *ExpressDataSet::cloneIfcTelecomAddress(const IfcTelecomAddress &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTelecomAddress(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTelecomAddress(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTelecomAddress  > &ExpressDataSet::getAllIfcTelecomAddress ()
{
    return m_refIfcTelecomAddressList;
}



IfcTendon *ExpressDataSet::getIfcTendon(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTendon * > (current->second.get());
    }
    else
    {
        IfcTendon *ret = static_cast< IfcTendon * > (allocateIfcTendon(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTendon(IfcTendon *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTendon_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTendon(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTendon *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTendon(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTendon_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTendon > ExpressDataSet::createIfcTendon(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTendon(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTendon * > (allocateIfcTendon(this, Step::Id_UNSET));
    }
}

IfcTendon *ExpressDataSet::cloneIfcTendon(ExpressDataSet *expressDataSet, const IfcTendon &obj, const CopyOp &copyop)
{
    IfcTendon *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTendon(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTendon_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTendon *ExpressDataSet::cloneIfcTendon(const IfcTendon &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTendon(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTendon(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTendon  > &ExpressDataSet::getAllIfcTendon ()
{
    return m_refIfcTendonList;
}



IfcTendonAnchor *ExpressDataSet::getIfcTendonAnchor(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTendonAnchor * > (current->second.get());
    }
    else
    {
        IfcTendonAnchor *ret = static_cast< IfcTendonAnchor * > (allocateIfcTendonAnchor(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTendonAnchor(IfcTendonAnchor *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTendonAnchor_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTendonAnchor(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTendonAnchor *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTendonAnchor(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTendonAnchor_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTendonAnchor > ExpressDataSet::createIfcTendonAnchor(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTendonAnchor(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTendonAnchor * > (allocateIfcTendonAnchor(this, Step::Id_UNSET));
    }
}

IfcTendonAnchor *ExpressDataSet::cloneIfcTendonAnchor(ExpressDataSet *expressDataSet, const IfcTendonAnchor &obj, const CopyOp &copyop)
{
    IfcTendonAnchor *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTendonAnchor(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTendonAnchor_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTendonAnchor *ExpressDataSet::cloneIfcTendonAnchor(const IfcTendonAnchor &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTendonAnchor(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTendonAnchor(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTendonAnchor  > &ExpressDataSet::getAllIfcTendonAnchor ()
{
    return m_refIfcTendonAnchorList;
}



IfcTerminatorSymbol *ExpressDataSet::getIfcTerminatorSymbol(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTerminatorSymbol * > (current->second.get());
    }
    else
    {
        IfcTerminatorSymbol *ret = static_cast< IfcTerminatorSymbol * > (allocateIfcTerminatorSymbol(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTerminatorSymbol(IfcTerminatorSymbol *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTerminatorSymbol_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTerminatorSymbol(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTerminatorSymbol *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTerminatorSymbol(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTerminatorSymbol_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTerminatorSymbol > ExpressDataSet::createIfcTerminatorSymbol(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTerminatorSymbol(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTerminatorSymbol * > (allocateIfcTerminatorSymbol(this, Step::Id_UNSET));
    }
}

IfcTerminatorSymbol *ExpressDataSet::cloneIfcTerminatorSymbol(ExpressDataSet *expressDataSet, const IfcTerminatorSymbol &obj, const CopyOp &copyop)
{
    IfcTerminatorSymbol *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTerminatorSymbol(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTerminatorSymbol_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTerminatorSymbol *ExpressDataSet::cloneIfcTerminatorSymbol(const IfcTerminatorSymbol &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTerminatorSymbol(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTerminatorSymbol(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTerminatorSymbol  > &ExpressDataSet::getAllIfcTerminatorSymbol ()
{
    return m_refIfcTerminatorSymbolList;
}



IfcTextLiteral *ExpressDataSet::getIfcTextLiteral(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTextLiteral * > (current->second.get());
    }
    else
    {
        IfcTextLiteral *ret = static_cast< IfcTextLiteral * > (allocateIfcTextLiteral(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTextLiteral(IfcTextLiteral *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTextLiteral_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTextLiteral(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTextLiteral *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTextLiteral(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTextLiteral_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTextLiteral > ExpressDataSet::createIfcTextLiteral(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTextLiteral(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTextLiteral * > (allocateIfcTextLiteral(this, Step::Id_UNSET));
    }
}

IfcTextLiteral *ExpressDataSet::cloneIfcTextLiteral(ExpressDataSet *expressDataSet, const IfcTextLiteral &obj, const CopyOp &copyop)
{
    IfcTextLiteral *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTextLiteral(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTextLiteral_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTextLiteral *ExpressDataSet::cloneIfcTextLiteral(const IfcTextLiteral &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTextLiteral(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTextLiteral(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTextLiteral  > &ExpressDataSet::getAllIfcTextLiteral ()
{
    return m_refIfcTextLiteralList;
}



IfcTextLiteralWithExtent *ExpressDataSet::getIfcTextLiteralWithExtent(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTextLiteralWithExtent * > (current->second.get());
    }
    else
    {
        IfcTextLiteralWithExtent *ret = static_cast< IfcTextLiteralWithExtent * > (allocateIfcTextLiteralWithExtent(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTextLiteralWithExtent(IfcTextLiteralWithExtent *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTextLiteralWithExtent_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTextLiteralWithExtent(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTextLiteralWithExtent *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTextLiteralWithExtent(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTextLiteralWithExtent_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTextLiteralWithExtent > ExpressDataSet::createIfcTextLiteralWithExtent(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTextLiteralWithExtent(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTextLiteralWithExtent * > (allocateIfcTextLiteralWithExtent(this, Step::Id_UNSET));
    }
}

IfcTextLiteralWithExtent *ExpressDataSet::cloneIfcTextLiteralWithExtent(ExpressDataSet *expressDataSet, const IfcTextLiteralWithExtent &obj, const CopyOp &copyop)
{
    IfcTextLiteralWithExtent *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTextLiteralWithExtent(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTextLiteralWithExtent_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTextLiteralWithExtent *ExpressDataSet::cloneIfcTextLiteralWithExtent(const IfcTextLiteralWithExtent &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTextLiteralWithExtent(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTextLiteralWithExtent(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTextLiteralWithExtent  > &ExpressDataSet::getAllIfcTextLiteralWithExtent ()
{
    return m_refIfcTextLiteralWithExtentList;
}



IfcTextStyle *ExpressDataSet::getIfcTextStyle(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTextStyle * > (current->second.get());
    }
    else
    {
        IfcTextStyle *ret = static_cast< IfcTextStyle * > (allocateIfcTextStyle(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTextStyle(IfcTextStyle *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTextStyle_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTextStyle(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTextStyle *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTextStyle(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTextStyle_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTextStyle > ExpressDataSet::createIfcTextStyle(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTextStyle(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTextStyle * > (allocateIfcTextStyle(this, Step::Id_UNSET));
    }
}

IfcTextStyle *ExpressDataSet::cloneIfcTextStyle(ExpressDataSet *expressDataSet, const IfcTextStyle &obj, const CopyOp &copyop)
{
    IfcTextStyle *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTextStyle(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTextStyle_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTextStyle *ExpressDataSet::cloneIfcTextStyle(const IfcTextStyle &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTextStyle(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTextStyle(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTextStyle  > &ExpressDataSet::getAllIfcTextStyle ()
{
    return m_refIfcTextStyleList;
}



IfcTextStyleFontModel *ExpressDataSet::getIfcTextStyleFontModel(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTextStyleFontModel * > (current->second.get());
    }
    else
    {
        IfcTextStyleFontModel *ret = static_cast< IfcTextStyleFontModel * > (allocateIfcTextStyleFontModel(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTextStyleFontModel(IfcTextStyleFontModel *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTextStyleFontModel_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTextStyleFontModel(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTextStyleFontModel *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTextStyleFontModel(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTextStyleFontModel_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTextStyleFontModel > ExpressDataSet::createIfcTextStyleFontModel(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTextStyleFontModel(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTextStyleFontModel * > (allocateIfcTextStyleFontModel(this, Step::Id_UNSET));
    }
}

IfcTextStyleFontModel *ExpressDataSet::cloneIfcTextStyleFontModel(ExpressDataSet *expressDataSet, const IfcTextStyleFontModel &obj, const CopyOp &copyop)
{
    IfcTextStyleFontModel *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTextStyleFontModel(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTextStyleFontModel_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTextStyleFontModel *ExpressDataSet::cloneIfcTextStyleFontModel(const IfcTextStyleFontModel &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTextStyleFontModel(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTextStyleFontModel(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTextStyleFontModel  > &ExpressDataSet::getAllIfcTextStyleFontModel ()
{
    return m_refIfcTextStyleFontModelList;
}



IfcTextStyleForDefinedFont *ExpressDataSet::getIfcTextStyleForDefinedFont(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTextStyleForDefinedFont * > (current->second.get());
    }
    else
    {
        IfcTextStyleForDefinedFont *ret = static_cast< IfcTextStyleForDefinedFont * > (allocateIfcTextStyleForDefinedFont(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTextStyleForDefinedFont(IfcTextStyleForDefinedFont *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTextStyleForDefinedFont_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTextStyleForDefinedFont(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTextStyleForDefinedFont *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTextStyleForDefinedFont(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTextStyleForDefinedFont_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTextStyleForDefinedFont > ExpressDataSet::createIfcTextStyleForDefinedFont(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTextStyleForDefinedFont(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTextStyleForDefinedFont * > (allocateIfcTextStyleForDefinedFont(this, Step::Id_UNSET));
    }
}

IfcTextStyleForDefinedFont *ExpressDataSet::cloneIfcTextStyleForDefinedFont(ExpressDataSet *expressDataSet, const IfcTextStyleForDefinedFont &obj, const CopyOp &copyop)
{
    IfcTextStyleForDefinedFont *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTextStyleForDefinedFont(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTextStyleForDefinedFont_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTextStyleForDefinedFont *ExpressDataSet::cloneIfcTextStyleForDefinedFont(const IfcTextStyleForDefinedFont &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTextStyleForDefinedFont(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTextStyleForDefinedFont(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTextStyleForDefinedFont  > &ExpressDataSet::getAllIfcTextStyleForDefinedFont ()
{
    return m_refIfcTextStyleForDefinedFontList;
}



IfcTextStyleTextModel *ExpressDataSet::getIfcTextStyleTextModel(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTextStyleTextModel * > (current->second.get());
    }
    else
    {
        IfcTextStyleTextModel *ret = static_cast< IfcTextStyleTextModel * > (allocateIfcTextStyleTextModel(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTextStyleTextModel(IfcTextStyleTextModel *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTextStyleTextModel_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTextStyleTextModel(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTextStyleTextModel *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTextStyleTextModel(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTextStyleTextModel_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTextStyleTextModel > ExpressDataSet::createIfcTextStyleTextModel(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTextStyleTextModel(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTextStyleTextModel * > (allocateIfcTextStyleTextModel(this, Step::Id_UNSET));
    }
}

IfcTextStyleTextModel *ExpressDataSet::cloneIfcTextStyleTextModel(ExpressDataSet *expressDataSet, const IfcTextStyleTextModel &obj, const CopyOp &copyop)
{
    IfcTextStyleTextModel *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTextStyleTextModel(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTextStyleTextModel_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTextStyleTextModel *ExpressDataSet::cloneIfcTextStyleTextModel(const IfcTextStyleTextModel &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTextStyleTextModel(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTextStyleTextModel(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTextStyleTextModel  > &ExpressDataSet::getAllIfcTextStyleTextModel ()
{
    return m_refIfcTextStyleTextModelList;
}



IfcTextStyleWithBoxCharacteristics *ExpressDataSet::getIfcTextStyleWithBoxCharacteristics(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTextStyleWithBoxCharacteristics * > (current->second.get());
    }
    else
    {
        IfcTextStyleWithBoxCharacteristics *ret = static_cast< IfcTextStyleWithBoxCharacteristics * > (allocateIfcTextStyleWithBoxCharacteristics(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTextStyleWithBoxCharacteristics(IfcTextStyleWithBoxCharacteristics *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTextStyleWithBoxCharacteristics_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTextStyleWithBoxCharacteristics(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTextStyleWithBoxCharacteristics *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTextStyleWithBoxCharacteristics(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTextStyleWithBoxCharacteristics_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTextStyleWithBoxCharacteristics > ExpressDataSet::createIfcTextStyleWithBoxCharacteristics(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTextStyleWithBoxCharacteristics(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTextStyleWithBoxCharacteristics * > (allocateIfcTextStyleWithBoxCharacteristics(this, Step::Id_UNSET));
    }
}

IfcTextStyleWithBoxCharacteristics *ExpressDataSet::cloneIfcTextStyleWithBoxCharacteristics(ExpressDataSet *expressDataSet, const IfcTextStyleWithBoxCharacteristics &obj, const CopyOp &copyop)
{
    IfcTextStyleWithBoxCharacteristics *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTextStyleWithBoxCharacteristics(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTextStyleWithBoxCharacteristics_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTextStyleWithBoxCharacteristics *ExpressDataSet::cloneIfcTextStyleWithBoxCharacteristics(const IfcTextStyleWithBoxCharacteristics &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTextStyleWithBoxCharacteristics(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTextStyleWithBoxCharacteristics(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTextStyleWithBoxCharacteristics  > &ExpressDataSet::getAllIfcTextStyleWithBoxCharacteristics ()
{
    return m_refIfcTextStyleWithBoxCharacteristicsList;
}



IfcTextureCoordinate *ExpressDataSet::getIfcTextureCoordinate(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTextureCoordinate * > (current->second.get());
    }
    else
    {
        IfcTextureCoordinate *ret = static_cast< IfcTextureCoordinate * > (allocateIfcTextureCoordinate(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTextureCoordinate(IfcTextureCoordinate *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTextureCoordinate_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTextureCoordinate(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTextureCoordinate *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTextureCoordinate(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTextureCoordinate_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTextureCoordinate > ExpressDataSet::createIfcTextureCoordinate(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTextureCoordinate(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTextureCoordinate * > (allocateIfcTextureCoordinate(this, Step::Id_UNSET));
    }
}

IfcTextureCoordinate *ExpressDataSet::cloneIfcTextureCoordinate(ExpressDataSet *expressDataSet, const IfcTextureCoordinate &obj, const CopyOp &copyop)
{
    IfcTextureCoordinate *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTextureCoordinate(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTextureCoordinate_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTextureCoordinate *ExpressDataSet::cloneIfcTextureCoordinate(const IfcTextureCoordinate &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTextureCoordinate(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTextureCoordinate(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTextureCoordinate  > &ExpressDataSet::getAllIfcTextureCoordinate ()
{
    return m_refIfcTextureCoordinateList;
}



IfcTextureCoordinateGenerator *ExpressDataSet::getIfcTextureCoordinateGenerator(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTextureCoordinateGenerator * > (current->second.get());
    }
    else
    {
        IfcTextureCoordinateGenerator *ret = static_cast< IfcTextureCoordinateGenerator * > (allocateIfcTextureCoordinateGenerator(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTextureCoordinateGenerator(IfcTextureCoordinateGenerator *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTextureCoordinateGenerator_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTextureCoordinateGenerator(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTextureCoordinateGenerator *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTextureCoordinateGenerator(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTextureCoordinateGenerator_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTextureCoordinateGenerator > ExpressDataSet::createIfcTextureCoordinateGenerator(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTextureCoordinateGenerator(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTextureCoordinateGenerator * > (allocateIfcTextureCoordinateGenerator(this, Step::Id_UNSET));
    }
}

IfcTextureCoordinateGenerator *ExpressDataSet::cloneIfcTextureCoordinateGenerator(ExpressDataSet *expressDataSet, const IfcTextureCoordinateGenerator &obj, const CopyOp &copyop)
{
    IfcTextureCoordinateGenerator *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTextureCoordinateGenerator(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTextureCoordinateGenerator_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTextureCoordinateGenerator *ExpressDataSet::cloneIfcTextureCoordinateGenerator(const IfcTextureCoordinateGenerator &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTextureCoordinateGenerator(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTextureCoordinateGenerator(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTextureCoordinateGenerator  > &ExpressDataSet::getAllIfcTextureCoordinateGenerator ()
{
    return m_refIfcTextureCoordinateGeneratorList;
}



IfcTextureMap *ExpressDataSet::getIfcTextureMap(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTextureMap * > (current->second.get());
    }
    else
    {
        IfcTextureMap *ret = static_cast< IfcTextureMap * > (allocateIfcTextureMap(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTextureMap(IfcTextureMap *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTextureMap_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTextureMap(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTextureMap *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTextureMap(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTextureMap_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTextureMap > ExpressDataSet::createIfcTextureMap(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTextureMap(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTextureMap * > (allocateIfcTextureMap(this, Step::Id_UNSET));
    }
}

IfcTextureMap *ExpressDataSet::cloneIfcTextureMap(ExpressDataSet *expressDataSet, const IfcTextureMap &obj, const CopyOp &copyop)
{
    IfcTextureMap *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTextureMap(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTextureMap_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTextureMap *ExpressDataSet::cloneIfcTextureMap(const IfcTextureMap &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTextureMap(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTextureMap(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTextureMap  > &ExpressDataSet::getAllIfcTextureMap ()
{
    return m_refIfcTextureMapList;
}



IfcTextureVertex *ExpressDataSet::getIfcTextureVertex(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTextureVertex * > (current->second.get());
    }
    else
    {
        IfcTextureVertex *ret = static_cast< IfcTextureVertex * > (allocateIfcTextureVertex(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTextureVertex(IfcTextureVertex *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTextureVertex_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTextureVertex(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTextureVertex *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTextureVertex(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTextureVertex_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTextureVertex > ExpressDataSet::createIfcTextureVertex(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTextureVertex(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTextureVertex * > (allocateIfcTextureVertex(this, Step::Id_UNSET));
    }
}

IfcTextureVertex *ExpressDataSet::cloneIfcTextureVertex(ExpressDataSet *expressDataSet, const IfcTextureVertex &obj, const CopyOp &copyop)
{
    IfcTextureVertex *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTextureVertex(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTextureVertex_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTextureVertex *ExpressDataSet::cloneIfcTextureVertex(const IfcTextureVertex &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTextureVertex(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTextureVertex(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTextureVertex  > &ExpressDataSet::getAllIfcTextureVertex ()
{
    return m_refIfcTextureVertexList;
}



IfcThermalMaterialProperties *ExpressDataSet::getIfcThermalMaterialProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcThermalMaterialProperties * > (current->second.get());
    }
    else
    {
        IfcThermalMaterialProperties *ret = static_cast< IfcThermalMaterialProperties * > (allocateIfcThermalMaterialProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcThermalMaterialProperties(IfcThermalMaterialProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcThermalMaterialProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcThermalMaterialProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcThermalMaterialProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcThermalMaterialProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcThermalMaterialProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcThermalMaterialProperties > ExpressDataSet::createIfcThermalMaterialProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcThermalMaterialProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcThermalMaterialProperties * > (allocateIfcThermalMaterialProperties(this, Step::Id_UNSET));
    }
}

IfcThermalMaterialProperties *ExpressDataSet::cloneIfcThermalMaterialProperties(ExpressDataSet *expressDataSet, const IfcThermalMaterialProperties &obj, const CopyOp &copyop)
{
    IfcThermalMaterialProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcThermalMaterialProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcThermalMaterialProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcThermalMaterialProperties *ExpressDataSet::cloneIfcThermalMaterialProperties(const IfcThermalMaterialProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcThermalMaterialProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcThermalMaterialProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcThermalMaterialProperties  > &ExpressDataSet::getAllIfcThermalMaterialProperties ()
{
    return m_refIfcThermalMaterialPropertiesList;
}



IfcTimeSeries *ExpressDataSet::getIfcTimeSeries(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTimeSeries * > (current->second.get());
    }
    else
    {
        IfcTimeSeries *ret = static_cast< IfcTimeSeries * > (allocateIfcTimeSeries(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTimeSeries(IfcTimeSeries *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTimeSeries_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTimeSeries(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTimeSeries *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTimeSeries(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTimeSeries_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTimeSeries > ExpressDataSet::createIfcTimeSeries(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTimeSeries(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTimeSeries * > (allocateIfcTimeSeries(this, Step::Id_UNSET));
    }
}

IfcTimeSeries *ExpressDataSet::cloneIfcTimeSeries(ExpressDataSet *expressDataSet, const IfcTimeSeries &obj, const CopyOp &copyop)
{
    IfcTimeSeries *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTimeSeries(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTimeSeries_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTimeSeries *ExpressDataSet::cloneIfcTimeSeries(const IfcTimeSeries &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTimeSeries(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTimeSeries(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTimeSeries  > &ExpressDataSet::getAllIfcTimeSeries ()
{
    return m_refIfcTimeSeriesList;
}



IfcTimeSeriesReferenceRelationship *ExpressDataSet::getIfcTimeSeriesReferenceRelationship(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTimeSeriesReferenceRelationship * > (current->second.get());
    }
    else
    {
        IfcTimeSeriesReferenceRelationship *ret = static_cast< IfcTimeSeriesReferenceRelationship * > (allocateIfcTimeSeriesReferenceRelationship(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTimeSeriesReferenceRelationship(IfcTimeSeriesReferenceRelationship *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTimeSeriesReferenceRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTimeSeriesReferenceRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTimeSeriesReferenceRelationship *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTimeSeriesReferenceRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTimeSeriesReferenceRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTimeSeriesReferenceRelationship > ExpressDataSet::createIfcTimeSeriesReferenceRelationship(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTimeSeriesReferenceRelationship(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTimeSeriesReferenceRelationship * > (allocateIfcTimeSeriesReferenceRelationship(this, Step::Id_UNSET));
    }
}

IfcTimeSeriesReferenceRelationship *ExpressDataSet::cloneIfcTimeSeriesReferenceRelationship(ExpressDataSet *expressDataSet, const IfcTimeSeriesReferenceRelationship &obj, const CopyOp &copyop)
{
    IfcTimeSeriesReferenceRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTimeSeriesReferenceRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTimeSeriesReferenceRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTimeSeriesReferenceRelationship *ExpressDataSet::cloneIfcTimeSeriesReferenceRelationship(const IfcTimeSeriesReferenceRelationship &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTimeSeriesReferenceRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTimeSeriesReferenceRelationship(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTimeSeriesReferenceRelationship  > &ExpressDataSet::getAllIfcTimeSeriesReferenceRelationship ()
{
    return m_refIfcTimeSeriesReferenceRelationshipList;
}



IfcTimeSeriesSchedule *ExpressDataSet::getIfcTimeSeriesSchedule(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTimeSeriesSchedule * > (current->second.get());
    }
    else
    {
        IfcTimeSeriesSchedule *ret = static_cast< IfcTimeSeriesSchedule * > (allocateIfcTimeSeriesSchedule(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTimeSeriesSchedule(IfcTimeSeriesSchedule *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTimeSeriesSchedule_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTimeSeriesSchedule(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTimeSeriesSchedule *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTimeSeriesSchedule(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTimeSeriesSchedule_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTimeSeriesSchedule > ExpressDataSet::createIfcTimeSeriesSchedule(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTimeSeriesSchedule(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTimeSeriesSchedule * > (allocateIfcTimeSeriesSchedule(this, Step::Id_UNSET));
    }
}

IfcTimeSeriesSchedule *ExpressDataSet::cloneIfcTimeSeriesSchedule(ExpressDataSet *expressDataSet, const IfcTimeSeriesSchedule &obj, const CopyOp &copyop)
{
    IfcTimeSeriesSchedule *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTimeSeriesSchedule(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTimeSeriesSchedule_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTimeSeriesSchedule *ExpressDataSet::cloneIfcTimeSeriesSchedule(const IfcTimeSeriesSchedule &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTimeSeriesSchedule(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTimeSeriesSchedule(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTimeSeriesSchedule  > &ExpressDataSet::getAllIfcTimeSeriesSchedule ()
{
    return m_refIfcTimeSeriesScheduleList;
}



IfcTimeSeriesValue *ExpressDataSet::getIfcTimeSeriesValue(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTimeSeriesValue * > (current->second.get());
    }
    else
    {
        IfcTimeSeriesValue *ret = static_cast< IfcTimeSeriesValue * > (allocateIfcTimeSeriesValue(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTimeSeriesValue(IfcTimeSeriesValue *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTimeSeriesValue_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTimeSeriesValue(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTimeSeriesValue *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTimeSeriesValue(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTimeSeriesValue_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTimeSeriesValue > ExpressDataSet::createIfcTimeSeriesValue(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTimeSeriesValue(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTimeSeriesValue * > (allocateIfcTimeSeriesValue(this, Step::Id_UNSET));
    }
}

IfcTimeSeriesValue *ExpressDataSet::cloneIfcTimeSeriesValue(ExpressDataSet *expressDataSet, const IfcTimeSeriesValue &obj, const CopyOp &copyop)
{
    IfcTimeSeriesValue *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTimeSeriesValue(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTimeSeriesValue_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTimeSeriesValue *ExpressDataSet::cloneIfcTimeSeriesValue(const IfcTimeSeriesValue &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTimeSeriesValue(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTimeSeriesValue(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTimeSeriesValue  > &ExpressDataSet::getAllIfcTimeSeriesValue ()
{
    return m_refIfcTimeSeriesValueList;
}



IfcTopologicalRepresentationItem *ExpressDataSet::getIfcTopologicalRepresentationItem(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTopologicalRepresentationItem * > (current->second.get());
    }
    else
    {
        IfcTopologicalRepresentationItem *ret = static_cast< IfcTopologicalRepresentationItem * > (allocateIfcTopologicalRepresentationItem(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTopologicalRepresentationItem(IfcTopologicalRepresentationItem *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTopologicalRepresentationItem_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTopologicalRepresentationItem(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTopologicalRepresentationItem *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTopologicalRepresentationItem(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTopologicalRepresentationItem_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTopologicalRepresentationItem > ExpressDataSet::createIfcTopologicalRepresentationItem(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTopologicalRepresentationItem(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTopologicalRepresentationItem * > (allocateIfcTopologicalRepresentationItem(this, Step::Id_UNSET));
    }
}

IfcTopologicalRepresentationItem *ExpressDataSet::cloneIfcTopologicalRepresentationItem(ExpressDataSet *expressDataSet, const IfcTopologicalRepresentationItem &obj, const CopyOp &copyop)
{
    IfcTopologicalRepresentationItem *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTopologicalRepresentationItem(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTopologicalRepresentationItem_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTopologicalRepresentationItem *ExpressDataSet::cloneIfcTopologicalRepresentationItem(const IfcTopologicalRepresentationItem &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTopologicalRepresentationItem(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTopologicalRepresentationItem(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTopologicalRepresentationItem  > &ExpressDataSet::getAllIfcTopologicalRepresentationItem ()
{
    return m_refIfcTopologicalRepresentationItemList;
}



IfcTopologyRepresentation *ExpressDataSet::getIfcTopologyRepresentation(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTopologyRepresentation * > (current->second.get());
    }
    else
    {
        IfcTopologyRepresentation *ret = static_cast< IfcTopologyRepresentation * > (allocateIfcTopologyRepresentation(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTopologyRepresentation(IfcTopologyRepresentation *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTopologyRepresentation_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTopologyRepresentation(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTopologyRepresentation *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTopologyRepresentation(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTopologyRepresentation_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTopologyRepresentation > ExpressDataSet::createIfcTopologyRepresentation(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTopologyRepresentation(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTopologyRepresentation * > (allocateIfcTopologyRepresentation(this, Step::Id_UNSET));
    }
}

IfcTopologyRepresentation *ExpressDataSet::cloneIfcTopologyRepresentation(ExpressDataSet *expressDataSet, const IfcTopologyRepresentation &obj, const CopyOp &copyop)
{
    IfcTopologyRepresentation *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTopologyRepresentation(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTopologyRepresentation_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTopologyRepresentation *ExpressDataSet::cloneIfcTopologyRepresentation(const IfcTopologyRepresentation &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTopologyRepresentation(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTopologyRepresentation(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTopologyRepresentation  > &ExpressDataSet::getAllIfcTopologyRepresentation ()
{
    return m_refIfcTopologyRepresentationList;
}



IfcTransformerType *ExpressDataSet::getIfcTransformerType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTransformerType * > (current->second.get());
    }
    else
    {
        IfcTransformerType *ret = static_cast< IfcTransformerType * > (allocateIfcTransformerType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTransformerType(IfcTransformerType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTransformerType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTransformerType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTransformerType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTransformerType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTransformerType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTransformerType > ExpressDataSet::createIfcTransformerType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTransformerType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTransformerType * > (allocateIfcTransformerType(this, Step::Id_UNSET));
    }
}

IfcTransformerType *ExpressDataSet::cloneIfcTransformerType(ExpressDataSet *expressDataSet, const IfcTransformerType &obj, const CopyOp &copyop)
{
    IfcTransformerType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTransformerType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTransformerType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTransformerType *ExpressDataSet::cloneIfcTransformerType(const IfcTransformerType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTransformerType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTransformerType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTransformerType  > &ExpressDataSet::getAllIfcTransformerType ()
{
    return m_refIfcTransformerTypeList;
}



IfcTransportElement *ExpressDataSet::getIfcTransportElement(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTransportElement * > (current->second.get());
    }
    else
    {
        IfcTransportElement *ret = static_cast< IfcTransportElement * > (allocateIfcTransportElement(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTransportElement(IfcTransportElement *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTransportElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTransportElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTransportElement *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTransportElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTransportElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTransportElement > ExpressDataSet::createIfcTransportElement(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTransportElement(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTransportElement * > (allocateIfcTransportElement(this, Step::Id_UNSET));
    }
}

IfcTransportElement *ExpressDataSet::cloneIfcTransportElement(ExpressDataSet *expressDataSet, const IfcTransportElement &obj, const CopyOp &copyop)
{
    IfcTransportElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTransportElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTransportElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTransportElement *ExpressDataSet::cloneIfcTransportElement(const IfcTransportElement &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTransportElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTransportElement(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTransportElement  > &ExpressDataSet::getAllIfcTransportElement ()
{
    return m_refIfcTransportElementList;
}



IfcTransportElementType *ExpressDataSet::getIfcTransportElementType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTransportElementType * > (current->second.get());
    }
    else
    {
        IfcTransportElementType *ret = static_cast< IfcTransportElementType * > (allocateIfcTransportElementType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTransportElementType(IfcTransportElementType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTransportElementType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTransportElementType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTransportElementType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTransportElementType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTransportElementType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTransportElementType > ExpressDataSet::createIfcTransportElementType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTransportElementType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTransportElementType * > (allocateIfcTransportElementType(this, Step::Id_UNSET));
    }
}

IfcTransportElementType *ExpressDataSet::cloneIfcTransportElementType(ExpressDataSet *expressDataSet, const IfcTransportElementType &obj, const CopyOp &copyop)
{
    IfcTransportElementType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTransportElementType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTransportElementType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTransportElementType *ExpressDataSet::cloneIfcTransportElementType(const IfcTransportElementType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTransportElementType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTransportElementType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTransportElementType  > &ExpressDataSet::getAllIfcTransportElementType ()
{
    return m_refIfcTransportElementTypeList;
}



IfcTrapeziumProfileDef *ExpressDataSet::getIfcTrapeziumProfileDef(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTrapeziumProfileDef * > (current->second.get());
    }
    else
    {
        IfcTrapeziumProfileDef *ret = static_cast< IfcTrapeziumProfileDef * > (allocateIfcTrapeziumProfileDef(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTrapeziumProfileDef(IfcTrapeziumProfileDef *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTrapeziumProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTrapeziumProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTrapeziumProfileDef *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTrapeziumProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTrapeziumProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTrapeziumProfileDef > ExpressDataSet::createIfcTrapeziumProfileDef(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTrapeziumProfileDef(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTrapeziumProfileDef * > (allocateIfcTrapeziumProfileDef(this, Step::Id_UNSET));
    }
}

IfcTrapeziumProfileDef *ExpressDataSet::cloneIfcTrapeziumProfileDef(ExpressDataSet *expressDataSet, const IfcTrapeziumProfileDef &obj, const CopyOp &copyop)
{
    IfcTrapeziumProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTrapeziumProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTrapeziumProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTrapeziumProfileDef *ExpressDataSet::cloneIfcTrapeziumProfileDef(const IfcTrapeziumProfileDef &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTrapeziumProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTrapeziumProfileDef(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTrapeziumProfileDef  > &ExpressDataSet::getAllIfcTrapeziumProfileDef ()
{
    return m_refIfcTrapeziumProfileDefList;
}



IfcTrimmedCurve *ExpressDataSet::getIfcTrimmedCurve(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTrimmedCurve * > (current->second.get());
    }
    else
    {
        IfcTrimmedCurve *ret = static_cast< IfcTrimmedCurve * > (allocateIfcTrimmedCurve(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTrimmedCurve(IfcTrimmedCurve *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTrimmedCurve_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTrimmedCurve(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTrimmedCurve *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTrimmedCurve(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTrimmedCurve_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTrimmedCurve > ExpressDataSet::createIfcTrimmedCurve(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTrimmedCurve(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTrimmedCurve * > (allocateIfcTrimmedCurve(this, Step::Id_UNSET));
    }
}

IfcTrimmedCurve *ExpressDataSet::cloneIfcTrimmedCurve(ExpressDataSet *expressDataSet, const IfcTrimmedCurve &obj, const CopyOp &copyop)
{
    IfcTrimmedCurve *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTrimmedCurve(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTrimmedCurve_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTrimmedCurve *ExpressDataSet::cloneIfcTrimmedCurve(const IfcTrimmedCurve &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTrimmedCurve(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTrimmedCurve(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTrimmedCurve  > &ExpressDataSet::getAllIfcTrimmedCurve ()
{
    return m_refIfcTrimmedCurveList;
}



IfcTShapeProfileDef *ExpressDataSet::getIfcTShapeProfileDef(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTShapeProfileDef * > (current->second.get());
    }
    else
    {
        IfcTShapeProfileDef *ret = static_cast< IfcTShapeProfileDef * > (allocateIfcTShapeProfileDef(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTShapeProfileDef(IfcTShapeProfileDef *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTShapeProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTShapeProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTShapeProfileDef *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTShapeProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTShapeProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTShapeProfileDef > ExpressDataSet::createIfcTShapeProfileDef(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTShapeProfileDef(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTShapeProfileDef * > (allocateIfcTShapeProfileDef(this, Step::Id_UNSET));
    }
}

IfcTShapeProfileDef *ExpressDataSet::cloneIfcTShapeProfileDef(ExpressDataSet *expressDataSet, const IfcTShapeProfileDef &obj, const CopyOp &copyop)
{
    IfcTShapeProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTShapeProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTShapeProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTShapeProfileDef *ExpressDataSet::cloneIfcTShapeProfileDef(const IfcTShapeProfileDef &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTShapeProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTShapeProfileDef(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTShapeProfileDef  > &ExpressDataSet::getAllIfcTShapeProfileDef ()
{
    return m_refIfcTShapeProfileDefList;
}



IfcTubeBundleType *ExpressDataSet::getIfcTubeBundleType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTubeBundleType * > (current->second.get());
    }
    else
    {
        IfcTubeBundleType *ret = static_cast< IfcTubeBundleType * > (allocateIfcTubeBundleType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTubeBundleType(IfcTubeBundleType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTubeBundleType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTubeBundleType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTubeBundleType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTubeBundleType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTubeBundleType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTubeBundleType > ExpressDataSet::createIfcTubeBundleType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTubeBundleType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTubeBundleType * > (allocateIfcTubeBundleType(this, Step::Id_UNSET));
    }
}

IfcTubeBundleType *ExpressDataSet::cloneIfcTubeBundleType(ExpressDataSet *expressDataSet, const IfcTubeBundleType &obj, const CopyOp &copyop)
{
    IfcTubeBundleType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTubeBundleType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTubeBundleType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTubeBundleType *ExpressDataSet::cloneIfcTubeBundleType(const IfcTubeBundleType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTubeBundleType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTubeBundleType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTubeBundleType  > &ExpressDataSet::getAllIfcTubeBundleType ()
{
    return m_refIfcTubeBundleTypeList;
}



IfcTwoDirectionRepeatFactor *ExpressDataSet::getIfcTwoDirectionRepeatFactor(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTwoDirectionRepeatFactor * > (current->second.get());
    }
    else
    {
        IfcTwoDirectionRepeatFactor *ret = static_cast< IfcTwoDirectionRepeatFactor * > (allocateIfcTwoDirectionRepeatFactor(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTwoDirectionRepeatFactor(IfcTwoDirectionRepeatFactor *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTwoDirectionRepeatFactor_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTwoDirectionRepeatFactor(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTwoDirectionRepeatFactor *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTwoDirectionRepeatFactor(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTwoDirectionRepeatFactor_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTwoDirectionRepeatFactor > ExpressDataSet::createIfcTwoDirectionRepeatFactor(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTwoDirectionRepeatFactor(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTwoDirectionRepeatFactor * > (allocateIfcTwoDirectionRepeatFactor(this, Step::Id_UNSET));
    }
}

IfcTwoDirectionRepeatFactor *ExpressDataSet::cloneIfcTwoDirectionRepeatFactor(ExpressDataSet *expressDataSet, const IfcTwoDirectionRepeatFactor &obj, const CopyOp &copyop)
{
    IfcTwoDirectionRepeatFactor *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTwoDirectionRepeatFactor(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTwoDirectionRepeatFactor_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTwoDirectionRepeatFactor *ExpressDataSet::cloneIfcTwoDirectionRepeatFactor(const IfcTwoDirectionRepeatFactor &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTwoDirectionRepeatFactor(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTwoDirectionRepeatFactor(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTwoDirectionRepeatFactor  > &ExpressDataSet::getAllIfcTwoDirectionRepeatFactor ()
{
    return m_refIfcTwoDirectionRepeatFactorList;
}



IfcTypeObject *ExpressDataSet::getIfcTypeObject(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTypeObject * > (current->second.get());
    }
    else
    {
        IfcTypeObject *ret = static_cast< IfcTypeObject * > (allocateIfcTypeObject(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTypeObject(IfcTypeObject *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTypeObject_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTypeObject(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTypeObject *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTypeObject(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTypeObject_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTypeObject > ExpressDataSet::createIfcTypeObject(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTypeObject(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTypeObject * > (allocateIfcTypeObject(this, Step::Id_UNSET));
    }
}

IfcTypeObject *ExpressDataSet::cloneIfcTypeObject(ExpressDataSet *expressDataSet, const IfcTypeObject &obj, const CopyOp &copyop)
{
    IfcTypeObject *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTypeObject(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTypeObject_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTypeObject *ExpressDataSet::cloneIfcTypeObject(const IfcTypeObject &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTypeObject(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTypeObject(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTypeObject  > &ExpressDataSet::getAllIfcTypeObject ()
{
    return m_refIfcTypeObjectList;
}



IfcTypeProduct *ExpressDataSet::getIfcTypeProduct(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcTypeProduct * > (current->second.get());
    }
    else
    {
        IfcTypeProduct *ret = static_cast< IfcTypeProduct * > (allocateIfcTypeProduct(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcTypeProduct(IfcTypeProduct *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcTypeProduct_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTypeProduct(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcTypeProduct *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTypeProduct(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTypeProduct_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTypeProduct > ExpressDataSet::createIfcTypeProduct(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcTypeProduct(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcTypeProduct * > (allocateIfcTypeProduct(this, Step::Id_UNSET));
    }
}

IfcTypeProduct *ExpressDataSet::cloneIfcTypeProduct(ExpressDataSet *expressDataSet, const IfcTypeProduct &obj, const CopyOp &copyop)
{
    IfcTypeProduct *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTypeProduct(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTypeProduct_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTypeProduct *ExpressDataSet::cloneIfcTypeProduct(const IfcTypeProduct &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcTypeProduct(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcTypeProduct(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcTypeProduct  > &ExpressDataSet::getAllIfcTypeProduct ()
{
    return m_refIfcTypeProductList;
}



IfcUnitaryEquipmentType *ExpressDataSet::getIfcUnitaryEquipmentType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcUnitaryEquipmentType * > (current->second.get());
    }
    else
    {
        IfcUnitaryEquipmentType *ret = static_cast< IfcUnitaryEquipmentType * > (allocateIfcUnitaryEquipmentType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcUnitaryEquipmentType(IfcUnitaryEquipmentType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcUnitaryEquipmentType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcUnitaryEquipmentType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcUnitaryEquipmentType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcUnitaryEquipmentType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcUnitaryEquipmentType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcUnitaryEquipmentType > ExpressDataSet::createIfcUnitaryEquipmentType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcUnitaryEquipmentType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcUnitaryEquipmentType * > (allocateIfcUnitaryEquipmentType(this, Step::Id_UNSET));
    }
}

IfcUnitaryEquipmentType *ExpressDataSet::cloneIfcUnitaryEquipmentType(ExpressDataSet *expressDataSet, const IfcUnitaryEquipmentType &obj, const CopyOp &copyop)
{
    IfcUnitaryEquipmentType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcUnitaryEquipmentType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcUnitaryEquipmentType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcUnitaryEquipmentType *ExpressDataSet::cloneIfcUnitaryEquipmentType(const IfcUnitaryEquipmentType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcUnitaryEquipmentType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcUnitaryEquipmentType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcUnitaryEquipmentType  > &ExpressDataSet::getAllIfcUnitaryEquipmentType ()
{
    return m_refIfcUnitaryEquipmentTypeList;
}



IfcUnitAssignment *ExpressDataSet::getIfcUnitAssignment(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcUnitAssignment * > (current->second.get());
    }
    else
    {
        IfcUnitAssignment *ret = static_cast< IfcUnitAssignment * > (allocateIfcUnitAssignment(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcUnitAssignment(IfcUnitAssignment *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcUnitAssignment_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcUnitAssignment(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcUnitAssignment *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcUnitAssignment(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcUnitAssignment_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcUnitAssignment > ExpressDataSet::createIfcUnitAssignment(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcUnitAssignment(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcUnitAssignment * > (allocateIfcUnitAssignment(this, Step::Id_UNSET));
    }
}

IfcUnitAssignment *ExpressDataSet::cloneIfcUnitAssignment(ExpressDataSet *expressDataSet, const IfcUnitAssignment &obj, const CopyOp &copyop)
{
    IfcUnitAssignment *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcUnitAssignment(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcUnitAssignment_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcUnitAssignment *ExpressDataSet::cloneIfcUnitAssignment(const IfcUnitAssignment &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcUnitAssignment(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcUnitAssignment(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcUnitAssignment  > &ExpressDataSet::getAllIfcUnitAssignment ()
{
    return m_refIfcUnitAssignmentList;
}



IfcUShapeProfileDef *ExpressDataSet::getIfcUShapeProfileDef(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcUShapeProfileDef * > (current->second.get());
    }
    else
    {
        IfcUShapeProfileDef *ret = static_cast< IfcUShapeProfileDef * > (allocateIfcUShapeProfileDef(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcUShapeProfileDef(IfcUShapeProfileDef *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcUShapeProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcUShapeProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcUShapeProfileDef *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcUShapeProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcUShapeProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcUShapeProfileDef > ExpressDataSet::createIfcUShapeProfileDef(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcUShapeProfileDef(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcUShapeProfileDef * > (allocateIfcUShapeProfileDef(this, Step::Id_UNSET));
    }
}

IfcUShapeProfileDef *ExpressDataSet::cloneIfcUShapeProfileDef(ExpressDataSet *expressDataSet, const IfcUShapeProfileDef &obj, const CopyOp &copyop)
{
    IfcUShapeProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcUShapeProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcUShapeProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcUShapeProfileDef *ExpressDataSet::cloneIfcUShapeProfileDef(const IfcUShapeProfileDef &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcUShapeProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcUShapeProfileDef(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcUShapeProfileDef  > &ExpressDataSet::getAllIfcUShapeProfileDef ()
{
    return m_refIfcUShapeProfileDefList;
}



IfcValveType *ExpressDataSet::getIfcValveType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcValveType * > (current->second.get());
    }
    else
    {
        IfcValveType *ret = static_cast< IfcValveType * > (allocateIfcValveType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcValveType(IfcValveType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcValveType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcValveType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcValveType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcValveType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcValveType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcValveType > ExpressDataSet::createIfcValveType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcValveType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcValveType * > (allocateIfcValveType(this, Step::Id_UNSET));
    }
}

IfcValveType *ExpressDataSet::cloneIfcValveType(ExpressDataSet *expressDataSet, const IfcValveType &obj, const CopyOp &copyop)
{
    IfcValveType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcValveType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcValveType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcValveType *ExpressDataSet::cloneIfcValveType(const IfcValveType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcValveType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcValveType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcValveType  > &ExpressDataSet::getAllIfcValveType ()
{
    return m_refIfcValveTypeList;
}



IfcVector *ExpressDataSet::getIfcVector(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcVector * > (current->second.get());
    }
    else
    {
        IfcVector *ret = static_cast< IfcVector * > (allocateIfcVector(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcVector(IfcVector *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcVector_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcVector(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcVector *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcVector(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcVector_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcVector > ExpressDataSet::createIfcVector(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcVector(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcVector * > (allocateIfcVector(this, Step::Id_UNSET));
    }
}

IfcVector *ExpressDataSet::cloneIfcVector(ExpressDataSet *expressDataSet, const IfcVector &obj, const CopyOp &copyop)
{
    IfcVector *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcVector(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcVector_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcVector *ExpressDataSet::cloneIfcVector(const IfcVector &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcVector(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcVector(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcVector  > &ExpressDataSet::getAllIfcVector ()
{
    return m_refIfcVectorList;
}



IfcVertex *ExpressDataSet::getIfcVertex(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcVertex * > (current->second.get());
    }
    else
    {
        IfcVertex *ret = static_cast< IfcVertex * > (allocateIfcVertex(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcVertex(IfcVertex *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcVertex_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcVertex(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcVertex *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcVertex(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcVertex_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcVertex > ExpressDataSet::createIfcVertex(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcVertex(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcVertex * > (allocateIfcVertex(this, Step::Id_UNSET));
    }
}

IfcVertex *ExpressDataSet::cloneIfcVertex(ExpressDataSet *expressDataSet, const IfcVertex &obj, const CopyOp &copyop)
{
    IfcVertex *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcVertex(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcVertex_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcVertex *ExpressDataSet::cloneIfcVertex(const IfcVertex &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcVertex(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcVertex(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcVertex  > &ExpressDataSet::getAllIfcVertex ()
{
    return m_refIfcVertexList;
}



IfcVertexBasedTextureMap *ExpressDataSet::getIfcVertexBasedTextureMap(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcVertexBasedTextureMap * > (current->second.get());
    }
    else
    {
        IfcVertexBasedTextureMap *ret = static_cast< IfcVertexBasedTextureMap * > (allocateIfcVertexBasedTextureMap(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcVertexBasedTextureMap(IfcVertexBasedTextureMap *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcVertexBasedTextureMap_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcVertexBasedTextureMap(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcVertexBasedTextureMap *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcVertexBasedTextureMap(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcVertexBasedTextureMap_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcVertexBasedTextureMap > ExpressDataSet::createIfcVertexBasedTextureMap(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcVertexBasedTextureMap(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcVertexBasedTextureMap * > (allocateIfcVertexBasedTextureMap(this, Step::Id_UNSET));
    }
}

IfcVertexBasedTextureMap *ExpressDataSet::cloneIfcVertexBasedTextureMap(ExpressDataSet *expressDataSet, const IfcVertexBasedTextureMap &obj, const CopyOp &copyop)
{
    IfcVertexBasedTextureMap *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcVertexBasedTextureMap(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcVertexBasedTextureMap_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcVertexBasedTextureMap *ExpressDataSet::cloneIfcVertexBasedTextureMap(const IfcVertexBasedTextureMap &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcVertexBasedTextureMap(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcVertexBasedTextureMap(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcVertexBasedTextureMap  > &ExpressDataSet::getAllIfcVertexBasedTextureMap ()
{
    return m_refIfcVertexBasedTextureMapList;
}



IfcVertexLoop *ExpressDataSet::getIfcVertexLoop(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcVertexLoop * > (current->second.get());
    }
    else
    {
        IfcVertexLoop *ret = static_cast< IfcVertexLoop * > (allocateIfcVertexLoop(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcVertexLoop(IfcVertexLoop *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcVertexLoop_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcVertexLoop(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcVertexLoop *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcVertexLoop(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcVertexLoop_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcVertexLoop > ExpressDataSet::createIfcVertexLoop(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcVertexLoop(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcVertexLoop * > (allocateIfcVertexLoop(this, Step::Id_UNSET));
    }
}

IfcVertexLoop *ExpressDataSet::cloneIfcVertexLoop(ExpressDataSet *expressDataSet, const IfcVertexLoop &obj, const CopyOp &copyop)
{
    IfcVertexLoop *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcVertexLoop(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcVertexLoop_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcVertexLoop *ExpressDataSet::cloneIfcVertexLoop(const IfcVertexLoop &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcVertexLoop(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcVertexLoop(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcVertexLoop  > &ExpressDataSet::getAllIfcVertexLoop ()
{
    return m_refIfcVertexLoopList;
}



IfcVertexPoint *ExpressDataSet::getIfcVertexPoint(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcVertexPoint * > (current->second.get());
    }
    else
    {
        IfcVertexPoint *ret = static_cast< IfcVertexPoint * > (allocateIfcVertexPoint(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcVertexPoint(IfcVertexPoint *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcVertexPoint_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcVertexPoint(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcVertexPoint *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcVertexPoint(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcVertexPoint_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcVertexPoint > ExpressDataSet::createIfcVertexPoint(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcVertexPoint(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcVertexPoint * > (allocateIfcVertexPoint(this, Step::Id_UNSET));
    }
}

IfcVertexPoint *ExpressDataSet::cloneIfcVertexPoint(ExpressDataSet *expressDataSet, const IfcVertexPoint &obj, const CopyOp &copyop)
{
    IfcVertexPoint *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcVertexPoint(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcVertexPoint_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcVertexPoint *ExpressDataSet::cloneIfcVertexPoint(const IfcVertexPoint &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcVertexPoint(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcVertexPoint(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcVertexPoint  > &ExpressDataSet::getAllIfcVertexPoint ()
{
    return m_refIfcVertexPointList;
}



IfcVibrationIsolatorType *ExpressDataSet::getIfcVibrationIsolatorType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcVibrationIsolatorType * > (current->second.get());
    }
    else
    {
        IfcVibrationIsolatorType *ret = static_cast< IfcVibrationIsolatorType * > (allocateIfcVibrationIsolatorType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcVibrationIsolatorType(IfcVibrationIsolatorType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcVibrationIsolatorType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcVibrationIsolatorType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcVibrationIsolatorType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcVibrationIsolatorType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcVibrationIsolatorType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcVibrationIsolatorType > ExpressDataSet::createIfcVibrationIsolatorType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcVibrationIsolatorType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcVibrationIsolatorType * > (allocateIfcVibrationIsolatorType(this, Step::Id_UNSET));
    }
}

IfcVibrationIsolatorType *ExpressDataSet::cloneIfcVibrationIsolatorType(ExpressDataSet *expressDataSet, const IfcVibrationIsolatorType &obj, const CopyOp &copyop)
{
    IfcVibrationIsolatorType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcVibrationIsolatorType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcVibrationIsolatorType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcVibrationIsolatorType *ExpressDataSet::cloneIfcVibrationIsolatorType(const IfcVibrationIsolatorType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcVibrationIsolatorType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcVibrationIsolatorType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcVibrationIsolatorType  > &ExpressDataSet::getAllIfcVibrationIsolatorType ()
{
    return m_refIfcVibrationIsolatorTypeList;
}



IfcVirtualElement *ExpressDataSet::getIfcVirtualElement(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcVirtualElement * > (current->second.get());
    }
    else
    {
        IfcVirtualElement *ret = static_cast< IfcVirtualElement * > (allocateIfcVirtualElement(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcVirtualElement(IfcVirtualElement *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcVirtualElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcVirtualElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcVirtualElement *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcVirtualElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcVirtualElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcVirtualElement > ExpressDataSet::createIfcVirtualElement(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcVirtualElement(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcVirtualElement * > (allocateIfcVirtualElement(this, Step::Id_UNSET));
    }
}

IfcVirtualElement *ExpressDataSet::cloneIfcVirtualElement(ExpressDataSet *expressDataSet, const IfcVirtualElement &obj, const CopyOp &copyop)
{
    IfcVirtualElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcVirtualElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcVirtualElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcVirtualElement *ExpressDataSet::cloneIfcVirtualElement(const IfcVirtualElement &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcVirtualElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcVirtualElement(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcVirtualElement  > &ExpressDataSet::getAllIfcVirtualElement ()
{
    return m_refIfcVirtualElementList;
}



IfcVirtualGridIntersection *ExpressDataSet::getIfcVirtualGridIntersection(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcVirtualGridIntersection * > (current->second.get());
    }
    else
    {
        IfcVirtualGridIntersection *ret = static_cast< IfcVirtualGridIntersection * > (allocateIfcVirtualGridIntersection(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcVirtualGridIntersection(IfcVirtualGridIntersection *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcVirtualGridIntersection_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcVirtualGridIntersection(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcVirtualGridIntersection *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcVirtualGridIntersection(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcVirtualGridIntersection_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcVirtualGridIntersection > ExpressDataSet::createIfcVirtualGridIntersection(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcVirtualGridIntersection(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcVirtualGridIntersection * > (allocateIfcVirtualGridIntersection(this, Step::Id_UNSET));
    }
}

IfcVirtualGridIntersection *ExpressDataSet::cloneIfcVirtualGridIntersection(ExpressDataSet *expressDataSet, const IfcVirtualGridIntersection &obj, const CopyOp &copyop)
{
    IfcVirtualGridIntersection *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcVirtualGridIntersection(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcVirtualGridIntersection_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcVirtualGridIntersection *ExpressDataSet::cloneIfcVirtualGridIntersection(const IfcVirtualGridIntersection &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcVirtualGridIntersection(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcVirtualGridIntersection(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcVirtualGridIntersection  > &ExpressDataSet::getAllIfcVirtualGridIntersection ()
{
    return m_refIfcVirtualGridIntersectionList;
}



IfcWall *ExpressDataSet::getIfcWall(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcWall * > (current->second.get());
    }
    else
    {
        IfcWall *ret = static_cast< IfcWall * > (allocateIfcWall(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcWall(IfcWall *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcWall_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcWall(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcWall *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcWall(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcWall_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcWall > ExpressDataSet::createIfcWall(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcWall(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcWall * > (allocateIfcWall(this, Step::Id_UNSET));
    }
}

IfcWall *ExpressDataSet::cloneIfcWall(ExpressDataSet *expressDataSet, const IfcWall &obj, const CopyOp &copyop)
{
    IfcWall *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcWall(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcWall_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcWall *ExpressDataSet::cloneIfcWall(const IfcWall &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcWall(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcWall(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcWall  > &ExpressDataSet::getAllIfcWall ()
{
    return m_refIfcWallList;
}



IfcWallStandardCase *ExpressDataSet::getIfcWallStandardCase(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcWallStandardCase * > (current->second.get());
    }
    else
    {
        IfcWallStandardCase *ret = static_cast< IfcWallStandardCase * > (allocateIfcWallStandardCase(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcWallStandardCase(IfcWallStandardCase *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcWallStandardCase_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcWallStandardCase(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcWallStandardCase *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcWallStandardCase(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcWallStandardCase_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcWallStandardCase > ExpressDataSet::createIfcWallStandardCase(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcWallStandardCase(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcWallStandardCase * > (allocateIfcWallStandardCase(this, Step::Id_UNSET));
    }
}

IfcWallStandardCase *ExpressDataSet::cloneIfcWallStandardCase(ExpressDataSet *expressDataSet, const IfcWallStandardCase &obj, const CopyOp &copyop)
{
    IfcWallStandardCase *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcWallStandardCase(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcWallStandardCase_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcWallStandardCase *ExpressDataSet::cloneIfcWallStandardCase(const IfcWallStandardCase &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcWallStandardCase(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcWallStandardCase(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcWallStandardCase  > &ExpressDataSet::getAllIfcWallStandardCase ()
{
    return m_refIfcWallStandardCaseList;
}



IfcWallType *ExpressDataSet::getIfcWallType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcWallType * > (current->second.get());
    }
    else
    {
        IfcWallType *ret = static_cast< IfcWallType * > (allocateIfcWallType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcWallType(IfcWallType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcWallType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcWallType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcWallType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcWallType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcWallType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcWallType > ExpressDataSet::createIfcWallType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcWallType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcWallType * > (allocateIfcWallType(this, Step::Id_UNSET));
    }
}

IfcWallType *ExpressDataSet::cloneIfcWallType(ExpressDataSet *expressDataSet, const IfcWallType &obj, const CopyOp &copyop)
{
    IfcWallType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcWallType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcWallType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcWallType *ExpressDataSet::cloneIfcWallType(const IfcWallType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcWallType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcWallType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcWallType  > &ExpressDataSet::getAllIfcWallType ()
{
    return m_refIfcWallTypeList;
}



IfcWasteTerminalType *ExpressDataSet::getIfcWasteTerminalType(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcWasteTerminalType * > (current->second.get());
    }
    else
    {
        IfcWasteTerminalType *ret = static_cast< IfcWasteTerminalType * > (allocateIfcWasteTerminalType(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcWasteTerminalType(IfcWasteTerminalType *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcWasteTerminalType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcWasteTerminalType(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcWasteTerminalType *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcWasteTerminalType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcWasteTerminalType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcWasteTerminalType > ExpressDataSet::createIfcWasteTerminalType(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcWasteTerminalType(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcWasteTerminalType * > (allocateIfcWasteTerminalType(this, Step::Id_UNSET));
    }
}

IfcWasteTerminalType *ExpressDataSet::cloneIfcWasteTerminalType(ExpressDataSet *expressDataSet, const IfcWasteTerminalType &obj, const CopyOp &copyop)
{
    IfcWasteTerminalType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcWasteTerminalType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcWasteTerminalType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcWasteTerminalType *ExpressDataSet::cloneIfcWasteTerminalType(const IfcWasteTerminalType &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcWasteTerminalType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcWasteTerminalType(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcWasteTerminalType  > &ExpressDataSet::getAllIfcWasteTerminalType ()
{
    return m_refIfcWasteTerminalTypeList;
}



IfcWaterProperties *ExpressDataSet::getIfcWaterProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcWaterProperties * > (current->second.get());
    }
    else
    {
        IfcWaterProperties *ret = static_cast< IfcWaterProperties * > (allocateIfcWaterProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcWaterProperties(IfcWaterProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcWaterProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcWaterProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcWaterProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcWaterProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcWaterProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcWaterProperties > ExpressDataSet::createIfcWaterProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcWaterProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcWaterProperties * > (allocateIfcWaterProperties(this, Step::Id_UNSET));
    }
}

IfcWaterProperties *ExpressDataSet::cloneIfcWaterProperties(ExpressDataSet *expressDataSet, const IfcWaterProperties &obj, const CopyOp &copyop)
{
    IfcWaterProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcWaterProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcWaterProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcWaterProperties *ExpressDataSet::cloneIfcWaterProperties(const IfcWaterProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcWaterProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcWaterProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcWaterProperties  > &ExpressDataSet::getAllIfcWaterProperties ()
{
    return m_refIfcWaterPropertiesList;
}



IfcWindow *ExpressDataSet::getIfcWindow(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcWindow * > (current->second.get());
    }
    else
    {
        IfcWindow *ret = static_cast< IfcWindow * > (allocateIfcWindow(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcWindow(IfcWindow *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcWindow_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcWindow(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcWindow *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcWindow(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcWindow_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcWindow > ExpressDataSet::createIfcWindow(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcWindow(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcWindow * > (allocateIfcWindow(this, Step::Id_UNSET));
    }
}

IfcWindow *ExpressDataSet::cloneIfcWindow(ExpressDataSet *expressDataSet, const IfcWindow &obj, const CopyOp &copyop)
{
    IfcWindow *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcWindow(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcWindow_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcWindow *ExpressDataSet::cloneIfcWindow(const IfcWindow &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcWindow(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcWindow(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcWindow  > &ExpressDataSet::getAllIfcWindow ()
{
    return m_refIfcWindowList;
}



IfcWindowLiningProperties *ExpressDataSet::getIfcWindowLiningProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcWindowLiningProperties * > (current->second.get());
    }
    else
    {
        IfcWindowLiningProperties *ret = static_cast< IfcWindowLiningProperties * > (allocateIfcWindowLiningProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcWindowLiningProperties(IfcWindowLiningProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcWindowLiningProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcWindowLiningProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcWindowLiningProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcWindowLiningProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcWindowLiningProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcWindowLiningProperties > ExpressDataSet::createIfcWindowLiningProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcWindowLiningProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcWindowLiningProperties * > (allocateIfcWindowLiningProperties(this, Step::Id_UNSET));
    }
}

IfcWindowLiningProperties *ExpressDataSet::cloneIfcWindowLiningProperties(ExpressDataSet *expressDataSet, const IfcWindowLiningProperties &obj, const CopyOp &copyop)
{
    IfcWindowLiningProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcWindowLiningProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcWindowLiningProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcWindowLiningProperties *ExpressDataSet::cloneIfcWindowLiningProperties(const IfcWindowLiningProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcWindowLiningProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcWindowLiningProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcWindowLiningProperties  > &ExpressDataSet::getAllIfcWindowLiningProperties ()
{
    return m_refIfcWindowLiningPropertiesList;
}



IfcWindowPanelProperties *ExpressDataSet::getIfcWindowPanelProperties(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcWindowPanelProperties * > (current->second.get());
    }
    else
    {
        IfcWindowPanelProperties *ret = static_cast< IfcWindowPanelProperties * > (allocateIfcWindowPanelProperties(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcWindowPanelProperties(IfcWindowPanelProperties *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcWindowPanelProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcWindowPanelProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcWindowPanelProperties *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcWindowPanelProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcWindowPanelProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcWindowPanelProperties > ExpressDataSet::createIfcWindowPanelProperties(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcWindowPanelProperties(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcWindowPanelProperties * > (allocateIfcWindowPanelProperties(this, Step::Id_UNSET));
    }
}

IfcWindowPanelProperties *ExpressDataSet::cloneIfcWindowPanelProperties(ExpressDataSet *expressDataSet, const IfcWindowPanelProperties &obj, const CopyOp &copyop)
{
    IfcWindowPanelProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcWindowPanelProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcWindowPanelProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcWindowPanelProperties *ExpressDataSet::cloneIfcWindowPanelProperties(const IfcWindowPanelProperties &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcWindowPanelProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcWindowPanelProperties(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcWindowPanelProperties  > &ExpressDataSet::getAllIfcWindowPanelProperties ()
{
    return m_refIfcWindowPanelPropertiesList;
}



IfcWindowStyle *ExpressDataSet::getIfcWindowStyle(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcWindowStyle * > (current->second.get());
    }
    else
    {
        IfcWindowStyle *ret = static_cast< IfcWindowStyle * > (allocateIfcWindowStyle(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcWindowStyle(IfcWindowStyle *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcWindowStyle_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcWindowStyle(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcWindowStyle *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcWindowStyle(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcWindowStyle_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcWindowStyle > ExpressDataSet::createIfcWindowStyle(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcWindowStyle(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcWindowStyle * > (allocateIfcWindowStyle(this, Step::Id_UNSET));
    }
}

IfcWindowStyle *ExpressDataSet::cloneIfcWindowStyle(ExpressDataSet *expressDataSet, const IfcWindowStyle &obj, const CopyOp &copyop)
{
    IfcWindowStyle *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcWindowStyle(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcWindowStyle_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcWindowStyle *ExpressDataSet::cloneIfcWindowStyle(const IfcWindowStyle &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcWindowStyle(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcWindowStyle(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcWindowStyle  > &ExpressDataSet::getAllIfcWindowStyle ()
{
    return m_refIfcWindowStyleList;
}



IfcWorkControl *ExpressDataSet::getIfcWorkControl(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcWorkControl * > (current->second.get());
    }
    else
    {
        IfcWorkControl *ret = static_cast< IfcWorkControl * > (allocateIfcWorkControl(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcWorkControl(IfcWorkControl *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcWorkControl_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcWorkControl(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcWorkControl *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcWorkControl(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcWorkControl_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcWorkControl > ExpressDataSet::createIfcWorkControl(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcWorkControl(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcWorkControl * > (allocateIfcWorkControl(this, Step::Id_UNSET));
    }
}

IfcWorkControl *ExpressDataSet::cloneIfcWorkControl(ExpressDataSet *expressDataSet, const IfcWorkControl &obj, const CopyOp &copyop)
{
    IfcWorkControl *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcWorkControl(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcWorkControl_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcWorkControl *ExpressDataSet::cloneIfcWorkControl(const IfcWorkControl &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcWorkControl(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcWorkControl(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcWorkControl  > &ExpressDataSet::getAllIfcWorkControl ()
{
    return m_refIfcWorkControlList;
}



IfcWorkPlan *ExpressDataSet::getIfcWorkPlan(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcWorkPlan * > (current->second.get());
    }
    else
    {
        IfcWorkPlan *ret = static_cast< IfcWorkPlan * > (allocateIfcWorkPlan(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcWorkPlan(IfcWorkPlan *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcWorkPlan_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcWorkPlan(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcWorkPlan *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcWorkPlan(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcWorkPlan_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcWorkPlan > ExpressDataSet::createIfcWorkPlan(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcWorkPlan(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcWorkPlan * > (allocateIfcWorkPlan(this, Step::Id_UNSET));
    }
}

IfcWorkPlan *ExpressDataSet::cloneIfcWorkPlan(ExpressDataSet *expressDataSet, const IfcWorkPlan &obj, const CopyOp &copyop)
{
    IfcWorkPlan *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcWorkPlan(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcWorkPlan_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcWorkPlan *ExpressDataSet::cloneIfcWorkPlan(const IfcWorkPlan &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcWorkPlan(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcWorkPlan(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcWorkPlan  > &ExpressDataSet::getAllIfcWorkPlan ()
{
    return m_refIfcWorkPlanList;
}



IfcWorkSchedule *ExpressDataSet::getIfcWorkSchedule(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcWorkSchedule * > (current->second.get());
    }
    else
    {
        IfcWorkSchedule *ret = static_cast< IfcWorkSchedule * > (allocateIfcWorkSchedule(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcWorkSchedule(IfcWorkSchedule *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcWorkSchedule_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcWorkSchedule(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcWorkSchedule *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcWorkSchedule(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcWorkSchedule_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcWorkSchedule > ExpressDataSet::createIfcWorkSchedule(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcWorkSchedule(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcWorkSchedule * > (allocateIfcWorkSchedule(this, Step::Id_UNSET));
    }
}

IfcWorkSchedule *ExpressDataSet::cloneIfcWorkSchedule(ExpressDataSet *expressDataSet, const IfcWorkSchedule &obj, const CopyOp &copyop)
{
    IfcWorkSchedule *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcWorkSchedule(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcWorkSchedule_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcWorkSchedule *ExpressDataSet::cloneIfcWorkSchedule(const IfcWorkSchedule &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcWorkSchedule(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcWorkSchedule(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcWorkSchedule  > &ExpressDataSet::getAllIfcWorkSchedule ()
{
    return m_refIfcWorkScheduleList;
}



IfcZone *ExpressDataSet::getIfcZone(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcZone * > (current->second.get());
    }
    else
    {
        IfcZone *ret = static_cast< IfcZone * > (allocateIfcZone(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcZone(IfcZone *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcZone_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcZone(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcZone *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcZone(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcZone_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcZone > ExpressDataSet::createIfcZone(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcZone(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcZone * > (allocateIfcZone(this, Step::Id_UNSET));
    }
}

IfcZone *ExpressDataSet::cloneIfcZone(ExpressDataSet *expressDataSet, const IfcZone &obj, const CopyOp &copyop)
{
    IfcZone *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcZone(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcZone_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcZone *ExpressDataSet::cloneIfcZone(const IfcZone &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcZone(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcZone(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcZone  > &ExpressDataSet::getAllIfcZone ()
{
    return m_refIfcZoneList;
}



IfcZShapeProfileDef *ExpressDataSet::getIfcZShapeProfileDef(Step::Id id)
{
    Step::MapOfEntities::iterator current = getAll().find(id);

    if (current == getAll().end())
    {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType()))
    {
        return static_cast< IfcZShapeProfileDef * > (current->second.get());
    }
    else
    {
        IfcZShapeProfileDef *ret = static_cast< IfcZShapeProfileDef * > (allocateIfcZShapeProfileDef(this, id));
        return ret;
    }    
}

bool ExpressDataSet::removeIfcZShapeProfileDef(IfcZShapeProfileDef *arg)
{
    getAll().erase(arg->getKey());
    return m_IfcZShapeProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcZShapeProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id)
{
    Step::SPFData *arg;
    IfcZShapeProfileDef *ret;
    if (id == Step::Id_UNSET)
    {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else
    {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcZShapeProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcZShapeProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcZShapeProfileDef > ExpressDataSet::createIfcZShapeProfileDef(bool isVolatile) {
    if (isVolatile)
    {
        return new IfcZShapeProfileDef(Step::Id_UNSET, 0);
    }
    else
    {
        return static_cast< IfcZShapeProfileDef * > (allocateIfcZShapeProfileDef(this, Step::Id_UNSET));
    }
}

IfcZShapeProfileDef *ExpressDataSet::cloneIfcZShapeProfileDef(ExpressDataSet *expressDataSet, const IfcZShapeProfileDef &obj, const CopyOp &copyop)
{
    IfcZShapeProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcZShapeProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcZShapeProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcZShapeProfileDef *ExpressDataSet::cloneIfcZShapeProfileDef(const IfcZShapeProfileDef &obj, const CopyOp &copyop)
{
    if (copyop.getExpressDataSet())
    {
        return ExpressDataSet::cloneIfcZShapeProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else
    {
        return ExpressDataSet::cloneIfcZShapeProfileDef(this, obj, copyop);
    }
}


Step::RefLinkedList< IfcZShapeProfileDef  > &ExpressDataSet::getAllIfcZShapeProfileDef ()
{
    return m_refIfcZShapeProfileDefList;
}


